---
status: diagnosed
trigger: "Investigate why symbolic names registered via qt.names.register don't resolve when used as objectId in other qt.* methods"
created: 2026-01-31T00:00:00Z
updated: 2026-01-31T00:00:00Z
---

## Current Focus

hypothesis: ObjectResolver::resolve() works correctly for symbolic names, but ObjectRegistry::findById() fails because IDs contain collision-disambiguation suffixes (~N) that don't match the hierarchical paths stored in SymbolicNameMap
test: Trace the full resolution path for each ID format
expecting: Mismatch between registered path format and what findById can actually look up
next_action: Document root cause

## Symptoms

expected: qt.objects.info with objectId="myStyle" resolves via SymbolicNameMap -> path -> object
actual: Returns "Object not found: myStyle"
errors: "Object not found: myStyle", numeric IDs (#1) and hierarchical paths also fail
reproduction: Register name, then use it as objectId in any qt.* method
started: Since implementation

## Eliminated

- hypothesis: ObjectResolver doesn't call SymbolicNameMap
  evidence: Code at object_resolver.cpp:39 explicitly calls SymbolicNameMap::instance()->resolve(id)
  timestamp: 2026-01-31

- hypothesis: SymbolicNameMap singleton is different instance
  evidence: Both use Q_GLOBAL_STATIC pattern, same instance()
  timestamp: 2026-01-31

## Evidence

- timestamp: 2026-01-31
  checked: ObjectResolver::resolve() code path (object_resolver.cpp:16-49)
  found: Resolution order is correct - numeric, symbolic, hierarchical. Symbolic name lookup calls SymbolicNameMap::resolve() then ObjectRegistry::findById() with the resolved path.
  implication: The issue is downstream - findById fails to match the path

- timestamp: 2026-01-31
  checked: ObjectRegistry::findById() (object_registry.cpp:274-295)
  found: Two-step lookup - first checks m_idToObject cache (exact string match), then falls back to findByObjectId() tree walk
  implication: If the registered path doesn't exactly match a cached ID key, cache lookup fails

- timestamp: 2026-01-31
  checked: ObjectRegistry::registerObject() (object_registry.cpp:110-163)
  found: IDs are generated at registration time. When collisions occur, a "~N" suffix is appended (line 137). The CACHED ID includes this suffix.
  implication: Path "QApplication/windows11" might be stored as "QApplication/windows11~2" in cache - exact match fails

- timestamp: 2026-01-31
  checked: findByObjectId() tree walk fallback (object_id.cpp:258-276)
  found: Searches QCoreApplication::instance()->children() as roots. Does NOT include QCoreApplication itself as a searchable node.
  implication: Any path starting with "QApplication" will NEVER match because QApplication is the root, not a child of the root

- timestamp: 2026-01-31
  checked: getTopLevelObjects() (object_id.cpp:106-116)
  found: Returns app->children() only. QCoreApplication itself is NOT in the list.
  implication: CRITICAL - the tree walk starts searching children OF QApplication, but paths generated by generateObjectId include "QApplication" as the first segment. So findBySegments tries to match "QApplication" against app's children (which are things like windows, not QApplication itself).

- timestamp: 2026-01-31
  checked: generateObjectId() (object_id.cpp:241-256)
  found: Walks parent chain all the way up. For QApplication's children, the path is "QApplication/childSegment". For QApplication itself, the path is just "QApplication".
  implication: Confirmed - generated IDs include QApplication as first segment, but findByObjectId starts searching from children of QApplication, never matching that first segment

- timestamp: 2026-01-31
  checked: Numeric ID (#1) resolution path (object_resolver.cpp:22-36)
  found: Parses "#1" into numericId=1, calls findByNumericId(1). This should work IF the object was previously assigned numeric ID 1 via assignNumericId().
  implication: Numeric IDs from findByClass DO work (user confirmed "QObject~3" resolves). The "#1" format works only if that specific numeric ID was assigned in the current session.

## Resolution

root_cause: THREE distinct but related failures:

1. **PRIMARY - Hierarchical path lookup is broken (affects symbolic names AND direct path usage)**
   - File: `src/probe/introspection/object_id.cpp`, function `findByObjectId()` line 258-276
   - `getTopLevelObjects()` (line 106-116) returns `QCoreApplication::instance()->children()` - i.e., the children OF QApplication
   - But `generateObjectId()` (line 241-256) generates paths that START with "QApplication" as the first segment
   - So when `findBySegments()` tries to match segment[0]="QApplication" against QApplication's children, it never matches because QApplication's children are windows/widgets, not QApplication itself
   - This means ALL hierarchical path lookups via tree walk fail for any path that includes the application root

2. **SECONDARY - Cache lookup requires exact ID match including collision suffixes**
   - File: `src/probe/core/object_registry.cpp`, function `findById()` line 274-295
   - The cache uses exact string keys. If an object's cached ID is "QApplication/windows11~2" (with collision suffix), looking up "QApplication/windows11" won't match
   - The symbolic name map stores the "clean" path from qt.names.register, but the cache may contain a suffixed version

3. **TERTIARY - Numeric ID format mismatch**
   - File: `src/probe/core/object_resolver.cpp`, lines 22-36
   - The `#N` format works correctly in ObjectResolver. However, the numeric IDs shown in findByClass responses (e.g., numericId: 1) require the `#1` prefix format to be used. If the user passes just "1", it IS handled (line 28, plain digits path). This path actually works - the user symptom about "#1 not resolving" likely means the object was deleted or the ID wasn't assigned.

fix: (not applied - diagnosis only)
verification: (not verified - diagnosis only)
files_changed: []
