---
phase: 02-core-introspection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/probe/core/object_registry.h
  - src/probe/core/object_registry.cpp
  - src/probe/CMakeLists.txt
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "All QObjects created after hook installation are tracked in registry"
    - "Objects removed from registry when destroyed"
    - "Registry access is thread-safe"
    - "Existing hooks (e.g., GammaRay) are preserved via daisy-chaining"
  artifacts:
    - path: "src/probe/core/object_registry.h"
      provides: "ObjectRegistry singleton class declaration"
      exports: ["ObjectRegistry", "installObjectHooks", "uninstallObjectHooks"]
    - path: "src/probe/core/object_registry.cpp"
      provides: "Hook installation and object tracking implementation"
      contains: "qtHookData"
  key_links:
    - from: "src/probe/core/object_registry.cpp"
      to: "private/qhooks_p.h"
      via: "qtHookData array access"
      pattern: "qtHookData\\[QHooks::"
    - from: "src/probe/core/object_registry.cpp"
      to: "QRecursiveMutex"
      via: "mutex protection"
      pattern: "QMutexLocker"
---

<objective>
Create the Object Registry that tracks all QObjects in the target application using Qt's private qtHookData hooks.

Purpose: Foundation for all introspection - every other feature needs to find and reference objects. Uses the same hook mechanism as GammaRay for proven compatibility.

Output: ObjectRegistry singleton with thread-safe object storage, hook installation/uninstallation, and basic lookup methods.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-introspection/02-RESEARCH.md
@src/probe/core/probe.h
@src/probe/core/probe.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ObjectRegistry with qtHookData hooks</name>
  <files>
    src/probe/core/object_registry.h
    src/probe/core/object_registry.cpp
    CMakeLists.txt
    src/probe/CMakeLists.txt
  </files>
  <action>
Create ObjectRegistry class that tracks all QObjects via Qt's private hooks:

**src/probe/core/object_registry.h:**
```cpp
#pragma once
#include <QObject>
#include <QHash>
#include <QPointer>
#include <QRecursiveMutex>

namespace qtmcp {

class QTMCP_EXPORT ObjectRegistry : public QObject {
    Q_OBJECT
public:
    static ObjectRegistry* instance();

    // Basic lookup (IDs will be added in Plan 02)
    QObject* findByObjectName(const QString& name, QObject* root = nullptr);
    QList<QObject*> findAllByClassName(const QString& className, QObject* root = nullptr);
    QList<QObject*> allObjects();
    int objectCount() const;

    // Check if object is tracked
    bool contains(QObject* obj) const;

signals:
    void objectAdded(QObject* obj);
    void objectRemoved(QObject* obj);

private:
    friend void qtmcpAddObjectHook(QObject*);
    friend void qtmcpRemoveObjectHook(QObject*);

    void registerObject(QObject* obj);
    void unregisterObject(QObject* obj);

    QSet<QObject*> m_objects;  // Simple set for now, IDs added in Plan 02
    mutable QRecursiveMutex m_mutex;

public:
    ObjectRegistry();
    ~ObjectRegistry() override;
};

// Hook management - called from Probe::initialize()
void installObjectHooks();
void uninstallObjectHooks();

}  // namespace qtmcp
```

**src/probe/core/object_registry.cpp:**
- Include `<private/qhooks_p.h>` for qtHookData access
- Store previous callbacks for daisy-chaining (preserve GammaRay compatibility)
- Hook callbacks: qtmcpAddObjectHook and qtmcpRemoveObjectHook
- Use QRecursiveMutex for thread safety (hooks called from any thread)
- Emit signals via QMetaObject::invokeMethod with Qt::QueuedConnection
- Use Q_GLOBAL_STATIC for singleton storage (same pattern as Probe)

**CMakeLists.txt changes:**
- Add Qt6::CorePrivate (or Qt5::CorePrivate) to probe target link libraries
- This enables access to `<private/qhooks_p.h>`

**src/probe/CMakeLists.txt:**
- Add object_registry.h and object_registry.cpp to probe sources

**Key implementation details per RESEARCH.md:**
1. Check qtHookData[QHooks::HookDataVersion] >= 1 before installing
2. Save existing callbacks before overwriting (daisy-chain pattern)
3. Keep critical section minimal in hook callbacks
4. Use QPointer-style tracking (objects can be deleted any time)
  </action>
  <verify>
Build succeeds with `cmake --build build`
No unresolved symbols for qtHookData
  </verify>
  <done>
ObjectRegistry compiles and links against Qt6::CorePrivate
Hook installation functions exist
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ObjectRegistry with Probe lifecycle</name>
  <files>
    src/probe/core/probe.cpp
  </files>
  <action>
Wire ObjectRegistry into Probe initialization and shutdown:

**In Probe::initialize():**
- After server creation, call `installObjectHooks()`
- Walk existing QApplication::topLevelWidgets() to register objects created before hooks
- Connect ObjectRegistry signals to Probe for future signal forwarding

**In Probe::shutdown():**
- Call `uninstallObjectHooks()` before server cleanup
- This restores original hooks (or nullptr)

**Add helper to enumerate existing objects:**
```cpp
void enumerateExistingObjects(QObject* root) {
    if (!root) return;
    ObjectRegistry::instance()->registerObject(root);
    for (QObject* child : root->children()) {
        enumerateExistingObjects(child);
    }
}
```

Call this on each QApplication::topLevelWidgets() in initialize().

**Why enumerate existing objects:**
Objects created before hook installation (including QApplication itself) won't trigger the AddQObject hook. Walking the tree ensures complete coverage.
  </action>
  <verify>
Build succeeds
Manual test: inject into test app, verify objects are tracked by adding a debug log
  </verify>
  <done>
Probe::initialize() installs hooks and enumerates existing objects
Probe::shutdown() uninstalls hooks
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for ObjectRegistry</name>
  <files>
    tests/test_object_registry.cpp
    tests/CMakeLists.txt
  </files>
  <action>
Create Qt Test suite for ObjectRegistry:

**tests/test_object_registry.cpp:**
```cpp
#include <QtTest>
#include "probe/core/object_registry.h"

class TestObjectRegistry : public QObject {
    Q_OBJECT
private slots:
    void initTestCase();
    void cleanupTestCase();

    void testSingleton();
    void testObjectTracking();
    void testFindByObjectName();
    void testFindAllByClassName();
    void testObjectRemoval();
    void testThreadSafety();
};
```

**Test cases:**
1. `testSingleton`: instance() returns same pointer
2. `testObjectTracking`: Create QObject, verify it's in allObjects()
3. `testFindByObjectName`: Create named object, find it
4. `testFindAllByClassName`: Create multiple QPushButtons, find all
5. `testObjectRemoval`: Delete object, verify removed from registry
6. `testThreadSafety`: Create objects from multiple threads, verify no crashes

**tests/CMakeLists.txt:**
- Add test_object_registry executable
- Link Qt6::CorePrivate for the registry

**Note:** Tests must call installObjectHooks() in initTestCase() and uninstallObjectHooks() in cleanupTestCase().
  </action>
  <verify>
`ctest --test-dir build -R object_registry` passes
All 6 test cases pass
  </verify>
  <done>
ObjectRegistry has unit tests proving:
- Singleton works
- Object tracking works
- Lookup by name/class works
- Removal on destruction works
- Thread safety doesn't crash
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build` succeeds without errors
2. Tests: `ctest --test-dir build -R object_registry` shows all tests passing
3. Manual: Inject into test app, add qDebug() to registerObject, verify objects logged
</verification>

<success_criteria>
- ObjectRegistry singleton exists and compiles
- qtHookData hooks installed via installObjectHooks()
- Objects tracked when created, removed when destroyed
- Thread-safe access with QRecursiveMutex
- Daisy-chains to existing hooks (GammaRay coexistence)
- Unit tests pass for all lookup methods
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-introspection/02-01-SUMMARY.md`
</output>
