---
phase: 02-core-introspection
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/probe/introspection/object_id.h
  - src/probe/introspection/object_id.cpp
  - src/probe/core/object_registry.h
  - src/probe/core/object_registry.cpp
  - src/probe/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Every tracked object has a unique hierarchical ID"
    - "IDs use objectName when available, fall back to text property, then className#N"
    - "Object tree can be serialized to JSON with hierarchical structure"
    - "Objects can be found by their hierarchical ID"
  artifacts:
    - path: "src/probe/introspection/object_id.h"
      provides: "Hierarchical ID generation functions"
      exports: ["generateObjectId", "parseObjectId"]
    - path: "src/probe/introspection/object_id.cpp"
      provides: "ID generation logic per CONTEXT.md rules"
      contains: "objectName"
  key_links:
    - from: "src/probe/core/object_registry.cpp"
      to: "src/probe/introspection/object_id.h"
      via: "ID generation on registration"
      pattern: "generateObjectId"
---

<objective>
Implement hierarchical object IDs and object tree serialization for OBJ-03 and OBJ-11.

Purpose: Human-readable, debuggable object references that reflect the actual Qt object tree. IDs are stable when based on objectName, gracefully degrade to position-based for unnamed objects.

Output: ID generation module, registry integration, and tree serialization to JSON.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-introspection/02-RESEARCH.md
@.planning/phases/02-core-introspection/02-CONTEXT.md
@src/probe/core/object_registry.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hierarchical ID generation module</name>
  <files>
    src/probe/introspection/object_id.h
    src/probe/introspection/object_id.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
Create the object ID generation module following CONTEXT.md decisions:

**Create src/probe/introspection/ directory**

**src/probe/introspection/object_id.h:**
```cpp
#pragma once
#include <QObject>
#include <QString>
#include <QJsonObject>

namespace qtmcp {

/// Generate a hierarchical ID for a QObject.
/// Format: "segment/segment/segment" where each segment is:
///   - objectName (if set and non-empty)
///   - text_<sanitized> (if text property exists)
///   - ClassName or ClassName#N (for disambiguation)
QString generateObjectId(QObject* obj);

/// Find an object by its hierarchical ID.
/// @param id The hierarchical ID (e.g., "mainWindow/central/submitBtn")
/// @param root Starting point for search (nullptr = all top-level objects)
/// @return The object, or nullptr if not found
QObject* findByObjectId(const QString& id, QObject* root = nullptr);

/// Serialize an object tree to JSON.
/// @param root Root object (nullptr = all top-level objects)
/// @param maxDepth Maximum depth (-1 = unlimited)
/// @return JSON object with id, className, objectName, children[]
QJsonObject serializeObjectTree(QObject* root, int maxDepth = -1);

/// Serialize a single object's basic info (no children).
QJsonObject serializeObjectInfo(QObject* obj);

}  // namespace qtmcp
```

**src/probe/introspection/object_id.cpp:**

ID generation algorithm per CONTEXT.md:
1. Walk from object to root, building path segments
2. For each object in path:
   - If objectName is set: use objectName
   - Else if "text" property exists and non-empty: use "text_<sanitized>"
     - Sanitize: take first 20 chars, replace non-alnum with underscore
   - Else: use className, with #N suffix if there are siblings of same class
3. Join segments with "/"

Tree serialization:
- Include: id, className, objectName, visible (for widgets), geometry (for widgets)
- Recurse into children up to maxDepth
- Return QJsonObject

**src/probe/CMakeLists.txt:**
- Add introspection/object_id.h and introspection/object_id.cpp to sources
  </action>
  <verify>
Build succeeds with `cmake --build build`
  </verify>
  <done>
object_id.h and object_id.cpp created
generateObjectId and serializeObjectTree functions compile
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate IDs into ObjectRegistry</name>
  <files>
    src/probe/core/object_registry.h
    src/probe/core/object_registry.cpp
  </files>
  <action>
Add ID-based lookup and storage to ObjectRegistry:

**Update ObjectRegistry class:**
```cpp
// Add to ObjectRegistry class:
QString objectId(QObject* obj);  // Get cached ID or generate
QObject* findById(const QString& id);  // Find by hierarchical ID

// Add private members:
QHash<QObject*, QString> m_objectToId;
QHash<QString, QPointer<QObject>> m_idToObject;
```

**Update registerObject():**
- Generate ID using generateObjectId()
- Store in both maps
- Handle ID collisions (append unique suffix if needed)

**Update unregisterObject():**
- Remove from both maps
- Use stored ID (don't regenerate)

**Add objectId() method:**
- Return cached ID from m_objectToId
- If not found (shouldn't happen), generate and cache

**Add findById() method:**
- Look up in m_idToObject
- Check QPointer validity before returning
- Return nullptr if not found or deleted

**Important:** IDs may become stale if object hierarchy changes (reparenting). For MVP, don't track reparenting - document that IDs are computed once at creation time.
  </action>
  <verify>
Build succeeds
ObjectRegistry::findById() returns correct object
ObjectRegistry::objectId() returns consistent ID
  </verify>
  <done>
ObjectRegistry has ID-based lookup
IDs cached on registration
findById() works for hierarchical IDs
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for ID generation and tree serialization</name>
  <files>
    tests/test_object_id.cpp
    tests/CMakeLists.txt
  </files>
  <action>
Create tests for object ID functionality:

**tests/test_object_id.cpp:**
```cpp
#include <QtTest>
#include <QWidget>
#include <QPushButton>
#include "probe/introspection/object_id.h"
#include "probe/core/object_registry.h"

class TestObjectId : public QObject {
    Q_OBJECT
private slots:
    void initTestCase();
    void cleanupTestCase();

    void testIdWithObjectName();
    void testIdWithTextProperty();
    void testIdWithClassName();
    void testIdSiblingDisambiguation();
    void testFindById();
    void testSerializeTree();
    void testSerializeTreeDepthLimit();
};
```

**Test cases:**
1. `testIdWithObjectName`: Object with name "submitBtn" -> path ends with "submitBtn"
2. `testIdWithTextProperty`: QPushButton with text "OK" but no name -> "text_OK"
3. `testIdWithClassName`: Unnamed object -> "ClassName" or "ClassName#N"
4. `testIdSiblingDisambiguation`: Two unnamed QPushButtons -> "#1" and "#2" suffixes
5. `testFindById`: Create hierarchy, verify findById returns correct object
6. `testSerializeTree`: Verify JSON structure has id, className, children
7. `testSerializeTreeDepthLimit`: Verify maxDepth limits recursion

**tests/CMakeLists.txt:**
- Add test_object_id executable
- Link Qt6::Widgets for widget tests
  </action>
  <verify>
`ctest --test-dir build -R object_id` passes
All 7 test cases pass
  </verify>
  <done>
ID generation follows CONTEXT.md rules
Tree serialization produces valid JSON
All tests pass
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build` succeeds
2. Tests: `ctest --test-dir build -R object_id` shows all tests passing
3. Manual: Create hierarchy in test app, print IDs, verify format matches spec
</verification>

<success_criteria>
- Hierarchical IDs generated per CONTEXT.md rules (objectName > text > className#N)
- ObjectRegistry caches and looks up objects by ID
- serializeObjectTree produces JSON with id, className, objectName, children
- Unit tests prove ID generation and lookup work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-introspection/02-02-SUMMARY.md`
</output>
