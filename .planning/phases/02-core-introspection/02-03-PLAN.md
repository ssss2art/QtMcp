---
phase: 02-core-introspection
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/probe/introspection/meta_inspector.h
  - src/probe/introspection/meta_inspector.cpp
  - src/probe/introspection/variant_json.h
  - src/probe/introspection/variant_json.cpp
  - src/probe/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "All properties of any QObject can be listed with names, types, and values"
    - "All invokable methods (slots, Q_INVOKABLE) can be listed"
    - "All signals can be listed with their signatures"
    - "Qt types (QPoint, QSize, QRect, QColor) convert correctly to JSON"
  artifacts:
    - path: "src/probe/introspection/meta_inspector.h"
      provides: "Property/method/signal listing functions"
      exports: ["listProperties", "listMethods", "listSignals", "objectInfo"]
    - path: "src/probe/introspection/variant_json.h"
      provides: "QVariant to/from JSON conversion"
      exports: ["variantToJson", "jsonToVariant"]
  key_links:
    - from: "src/probe/introspection/meta_inspector.cpp"
      to: "QMetaObject"
      via: "introspection API"
      pattern: "metaObject\\(\\)->property"
    - from: "src/probe/introspection/variant_json.cpp"
      to: "QJsonValue"
      via: "type conversion"
      pattern: "QJsonValue::from"
---

<objective>
Create the Meta Inspector that exposes QObject properties, methods, and signals via Qt's QMetaObject system.

Purpose: Core introspection for OBJ-04 (object info), OBJ-05 (list properties), OBJ-08 (list methods), OBJ-10 (list signals). Provides the read-only inspection capability.

Output: MetaInspector utility class with JSON-friendly output for all introspection queries.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-introspection/02-RESEARCH.md
@src/probe/core/object_registry.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QVariant/JSON conversion utilities</name>
  <files>
    src/probe/introspection/variant_json.h
    src/probe/introspection/variant_json.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
Create type conversion utilities for QVariant <-> JSON:

**src/probe/introspection/variant_json.h:**
```cpp
#pragma once
#include <QVariant>
#include <QJsonValue>
#include <QJsonObject>
#include <QJsonArray>

namespace qtmcp {

/// Convert QVariant to JSON value.
/// Handles: bool, int, double, QString, QPoint, QSize, QRect, QColor,
/// QStringList, QVariantList, QVariantMap, and falls back to toString().
QJsonValue variantToJson(const QVariant& value);

/// Convert JSON value to QVariant.
/// Used for setProperty and invokeMethod arguments.
QVariant jsonToVariant(const QJsonValue& value, int targetTypeId = QMetaType::UnknownType);

/// Get a human-readable type name for a QVariant.
QString variantTypeName(const QVariant& value);

}  // namespace qtmcp
```

**src/probe/introspection/variant_json.cpp:**

Handle these Qt types explicitly (per RESEARCH.md pitfall #3):
- `QPoint` -> `{"x": N, "y": N}`
- `QPointF` -> `{"x": F, "y": F}`
- `QSize` -> `{"width": N, "height": N}`
- `QSizeF` -> `{"width": F, "height": F}`
- `QRect` -> `{"x": N, "y": N, "width": N, "height": N}`
- `QRectF` -> same with floats
- `QColor` -> `{"r": N, "g": N, "b": N, "a": N}` or `"#RRGGBB"`
- `QStringList` -> JSON array of strings
- `QVariantList` -> JSON array (recursive)
- `QVariantMap` -> JSON object (recursive)
- `QUrl` -> string
- `QDateTime` -> ISO 8601 string

For unknown types:
- Try QVariant::toString()
- Include type name in output for debugging: `{"_type": "QFont", "value": "..."}`

**jsonToVariant:**
- If targetTypeId provided, use QMetaType::convert
- Otherwise infer from JSON type (bool, number, string, array, object)
  </action>
  <verify>
Build succeeds
Unit tests for QPoint, QSize, QRect, QColor conversion pass
  </verify>
  <done>
variantToJson handles all common Qt types
jsonToVariant can convert back for setProperty
Unknown types fall back gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MetaInspector for property/method/signal listing</name>
  <files>
    src/probe/introspection/meta_inspector.h
    src/probe/introspection/meta_inspector.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
Create MetaInspector utility class:

**src/probe/introspection/meta_inspector.h:**
```cpp
#pragma once
#include <QObject>
#include <QJsonObject>
#include <QJsonArray>
#include <QJsonValue>

namespace qtmcp {

/// Utility class for QMetaObject introspection with JSON output.
class MetaInspector {
public:
    /// Get detailed object info (OBJ-04).
    /// Returns: className, superClasses[], objectName, geometry (if widget), visible
    static QJsonObject objectInfo(QObject* obj);

    /// List all properties (OBJ-05).
    /// Returns array of: {name, type, readable, writable, value}
    static QJsonArray listProperties(QObject* obj);

    /// List all invokable methods (OBJ-08).
    /// Returns array of: {name, signature, returnType, parameterTypes[], access}
    static QJsonArray listMethods(QObject* obj);

    /// List all signals (OBJ-10).
    /// Returns array of: {name, signature, parameterTypes[]}
    static QJsonArray listSignals(QObject* obj);

    /// Get inheritance chain.
    /// Returns: ["QPushButton", "QAbstractButton", "QWidget", "QObject"]
    static QStringList inheritanceChain(QObject* obj);
};

}  // namespace qtmcp
```

**src/probe/introspection/meta_inspector.cpp:**

**objectInfo() implementation:**
```cpp
QJsonObject MetaInspector::objectInfo(QObject* obj) {
    QJsonObject info;
    info["className"] = QString::fromLatin1(obj->metaObject()->className());
    info["objectName"] = obj->objectName();
    info["superClasses"] = QJsonArray::fromStringList(inheritanceChain(obj));

    // Add widget-specific info
    if (auto* widget = qobject_cast<QWidget*>(obj)) {
        info["visible"] = widget->isVisible();
        info["enabled"] = widget->isEnabled();
        // Geometry added via separate function (Plan 06)
    }

    return info;
}
```

**listProperties() implementation:**
- Use meta->propertyOffset() to skip QObject base properties (or include all)
- For each property: name, typeName, isReadable, isWritable
- Include current value via variantToJson(prop.read(obj))

**listMethods() implementation:**
- Filter for Slot or Invokable method types
- Include: name (just the name), signature (full), returnType, parameterTypes[]
- Access: "public", "protected", "private"

**listSignals() implementation:**
- Filter for Signal method type
- Include: name, signature, parameterTypes[]
  </action>
  <verify>
Build succeeds
MetaInspector::listProperties returns valid JSON array
MetaInspector::listMethods includes slots and Q_INVOKABLE
MetaInspector::listSignals lists all signals
  </verify>
  <done>
MetaInspector provides complete introspection
Properties include types and current values
Methods include signatures and parameter types
Signals include parameter types
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for MetaInspector</name>
  <files>
    tests/test_meta_inspector.cpp
    tests/CMakeLists.txt
  </files>
  <action>
Create comprehensive tests for MetaInspector:

**tests/test_meta_inspector.cpp:**
```cpp
#include <QtTest>
#include <QWidget>
#include <QPushButton>
#include "probe/introspection/meta_inspector.h"
#include "probe/introspection/variant_json.h"

class TestMetaInspector : public QObject {
    Q_OBJECT
private slots:
    void testVariantToJsonBool();
    void testVariantToJsonNumbers();
    void testVariantToJsonString();
    void testVariantToJsonPoint();
    void testVariantToJsonRect();
    void testVariantToJsonColor();
    void testVariantToJsonUnknown();

    void testJsonToVariant();

    void testObjectInfo();
    void testListProperties();
    void testListMethods();
    void testListSignals();
    void testInheritanceChain();
};
```

**Test cases:**

*Variant conversion:*
1. Bool -> true/false
2. Int/Double -> JSON number
3. QString -> JSON string
4. QPoint(10, 20) -> {"x": 10, "y": 20}
5. QRect(0, 0, 100, 50) -> {"x": 0, "y": 0, "width": 100, "height": 50}
6. QColor(255, 0, 0) -> includes r, g, b components
7. Unknown type -> falls back to toString with _type field

*JSON to variant:*
8. Round-trip test: variantToJson -> jsonToVariant preserves value

*MetaInspector:*
9. objectInfo: QPushButton has className "QPushButton", visible property
10. listProperties: QPushButton has "text", "enabled", "visible" properties
11. listMethods: QPushButton has "click()" slot
12. listSignals: QPushButton has "clicked()" signal
13. inheritanceChain: QPushButton -> ["QPushButton", "QAbstractButton", "QWidget", "QObject"]

**tests/CMakeLists.txt:**
- Add test_meta_inspector executable
- Link Qt6::Widgets
  </action>
  <verify>
`ctest --test-dir build -R meta_inspector` passes
All 13+ test cases pass
  </verify>
  <done>
Variant conversion fully tested
MetaInspector listing functions fully tested
All tests pass
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build` succeeds
2. Tests: `ctest --test-dir build -R meta_inspector` shows all tests passing
3. Manual: Call listProperties on a widget, verify JSON output is correct
</verification>

<success_criteria>
- variantToJson handles QPoint, QSize, QRect, QColor correctly
- jsonToVariant can reconstruct values for setProperty
- MetaInspector::objectInfo returns complete object information
- MetaInspector::listProperties lists all properties with values
- MetaInspector::listMethods lists all slots and Q_INVOKABLE methods
- MetaInspector::listSignals lists all signals with signatures
- Unit tests prove all functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-introspection/02-03-SUMMARY.md`
</output>
