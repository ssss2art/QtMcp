---
phase: 02-core-introspection
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/probe/introspection/meta_inspector.h
  - src/probe/introspection/meta_inspector.cpp
  - tests/test_meta_inspector.cpp
autonomous: true

must_haves:
  truths:
    - "Any readable property value can be retrieved"
    - "Writable properties can be set with appropriate type coercion"
    - "Methods can be invoked with JSON arguments"
    - "Read-only properties return clear error on write attempt"
    - "Method invocation with wrong argument types returns clear error"
  artifacts:
    - path: "src/probe/introspection/meta_inspector.h"
      provides: "Property get/set and method invoke functions"
      exports: ["getProperty", "setProperty", "invokeMethod"]
  key_links:
    - from: "src/probe/introspection/meta_inspector.cpp"
      to: "QMetaProperty"
      via: "property read/write"
      pattern: "prop\\.read\\(|prop\\.write\\("
    - from: "src/probe/introspection/meta_inspector.cpp"
      to: "QMetaMethod"
      via: "method invocation"
      pattern: "method\\.invoke\\("
---

<objective>
Add property get/set and method invocation to MetaInspector for OBJ-06, OBJ-07, and OBJ-09.

Purpose: Allow clients to read property values, modify properties, and invoke methods on any QObject. This is the "mutation" capability that enables automation.

Output: Extended MetaInspector with getProperty, setProperty, and invokeMethod functions.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-introspection/02-RESEARCH.md
@.planning/phases/02-core-introspection/02-CONTEXT.md
@src/probe/introspection/meta_inspector.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement getProperty and setProperty</name>
  <files>
    src/probe/introspection/meta_inspector.h
    src/probe/introspection/meta_inspector.cpp
  </files>
  <action>
Add property read/write methods to MetaInspector:

**Add to meta_inspector.h:**
```cpp
/// Get a single property value (OBJ-06).
/// @param obj Target object
/// @param name Property name
/// @return JSON value of property
/// @throws std::runtime_error if property not found
static QJsonValue getProperty(QObject* obj, const QString& name);

/// Set a property value (OBJ-07).
/// @param obj Target object
/// @param name Property name
/// @param value New value as JSON
/// @return true if successful
/// @throws std::runtime_error if property not found or read-only
static bool setProperty(QObject* obj, const QString& name, const QJsonValue& value);
```

**getProperty() implementation:**
```cpp
QJsonValue MetaInspector::getProperty(QObject* obj, const QString& name) {
    const QMetaObject* meta = obj->metaObject();
    int propIndex = meta->indexOfProperty(name.toLatin1().constData());

    if (propIndex < 0) {
        // Try dynamic property
        QVariant value = obj->property(name.toLatin1().constData());
        if (value.isValid())
            return variantToJson(value);
        throw std::runtime_error("Property not found: " + name.toStdString());
    }

    QMetaProperty prop = meta->property(propIndex);
    if (!prop.isReadable())
        throw std::runtime_error("Property not readable: " + name.toStdString());

    return variantToJson(prop.read(obj));
}
```

**setProperty() implementation:**
```cpp
bool MetaInspector::setProperty(QObject* obj, const QString& name, const QJsonValue& value) {
    const QMetaObject* meta = obj->metaObject();
    int propIndex = meta->indexOfProperty(name.toLatin1().constData());

    if (propIndex < 0) {
        // Allow setting dynamic properties
        QVariant var = jsonToVariant(value);
        return obj->setProperty(name.toLatin1().constData(), var);
    }

    QMetaProperty prop = meta->property(propIndex);
    if (!prop.isWritable()) {
        throw std::runtime_error("Property is read-only: " + name.toStdString());
    }

    // Convert JSON to appropriate type
    QVariant var = jsonToVariant(value, prop.userType());
    if (!var.convert(prop.metaType())) {
        throw std::runtime_error("Cannot convert value to type: " +
            QString::fromLatin1(prop.typeName()).toStdString());
    }

    return prop.write(obj, var);
}
```

**Per CONTEXT.md decisions:**
- Let Qt's meta-object system attempt type coercion
- Error only if conversion fails
- Return clear error explaining property is read-only (include property name)
  </action>
  <verify>
Build succeeds
getProperty returns correct values
setProperty changes writable properties
setProperty throws on read-only properties
  </verify>
  <done>
getProperty reads any property
setProperty writes writable properties with type coercion
Read-only properties return clear error
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement invokeMethod</name>
  <files>
    src/probe/introspection/meta_inspector.h
    src/probe/introspection/meta_inspector.cpp
  </files>
  <action>
Add method invocation to MetaInspector:

**Add to meta_inspector.h:**
```cpp
/// Invoke a method on an object (OBJ-09).
/// @param obj Target object
/// @param methodName Method name (without signature)
/// @param args Arguments as JSON array
/// @return Return value as JSON (null for void)
/// @throws std::runtime_error if method not found or invocation fails
static QJsonValue invokeMethod(QObject* obj, const QString& methodName,
                               const QJsonArray& args = QJsonArray());
```

**invokeMethod() implementation:**

This is the most complex function. Key challenges:
1. Find method by name (may have multiple overloads)
2. Match argument count
3. Convert JSON args to QVariant with correct types
4. Handle return value

```cpp
QJsonValue MetaInspector::invokeMethod(QObject* obj, const QString& methodName,
                                        const QJsonArray& args) {
    const QMetaObject* meta = obj->metaObject();

    // Find method by name, matching argument count
    QMetaMethod foundMethod;
    for (int i = 0; i < meta->methodCount(); ++i) {
        QMetaMethod method = meta->method(i);
        if (QString::fromLatin1(method.name()) == methodName) {
            // Check if slot or invokable
            if (method.methodType() != QMetaMethod::Slot &&
                method.methodType() != QMetaMethod::Method)
                continue;

            // Check argument count
            if (method.parameterCount() == args.count()) {
                foundMethod = method;
                break;
            }
        }
    }

    if (!foundMethod.isValid())
        throw std::runtime_error("Method not found or wrong argument count: " +
            methodName.toStdString());

    // Build arguments
    QList<QGenericArgument> genericArgs;
    QList<QVariant> variantArgs;  // Must stay in scope

    for (int i = 0; i < args.count(); ++i) {
        int paramType = foundMethod.parameterType(i);
        QVariant var = jsonToVariant(args[i], paramType);

        // Store variant to keep it alive
        variantArgs.append(var);

        genericArgs.append(QGenericArgument(
            foundMethod.parameterTypeName(i),
            variantArgs.last().constData()
        ));
    }

    // Prepare return value storage
    QVariant returnValue;
    QGenericReturnArgument returnArg;
    if (foundMethod.returnType() != QMetaType::Void) {
        returnValue = QVariant(QMetaType(foundMethod.returnType()));
        returnArg = QGenericReturnArgument(
            foundMethod.typeName(),
            returnValue.data()
        );
    }

    // Invoke (use Qt::AutoConnection for thread safety)
    bool ok = foundMethod.invoke(obj, Qt::AutoConnection, returnArg,
        genericArgs.value(0), genericArgs.value(1), genericArgs.value(2),
        genericArgs.value(3), genericArgs.value(4), genericArgs.value(5),
        genericArgs.value(6), genericArgs.value(7), genericArgs.value(8),
        genericArgs.value(9));

    if (!ok)
        throw std::runtime_error("Method invocation failed: " + methodName.toStdString());

    if (foundMethod.returnType() == QMetaType::Void)
        return QJsonValue::Null;

    return variantToJson(returnValue);
}
```

**Note:** Qt limits to 10 arguments. For MVP this is acceptable.

**Per CONTEXT.md:** Let Qt's meta-object system attempt type coercion - error only if conversion fails.
  </action>
  <verify>
Build succeeds
invokeMethod can call slots with arguments
invokeMethod returns correct return values
invokeMethod throws on method not found
  </verify>
  <done>
invokeMethod works with up to 10 arguments
Return values converted to JSON
Wrong arguments return clear error
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for property operations and method invocation</name>
  <files>
    tests/test_meta_inspector.cpp
  </files>
  <action>
Extend test suite for get/set/invoke:

**Add to TestMetaInspector:**
```cpp
private slots:
    // ... existing tests ...

    // Property operations
    void testGetPropertyString();
    void testGetPropertyInt();
    void testGetPropertyNotFound();
    void testSetPropertyString();
    void testSetPropertyInt();
    void testSetPropertyReadOnly();
    void testSetPropertyTypeCoercion();
    void testDynamicProperty();

    // Method invocation
    void testInvokeVoidMethod();
    void testInvokeMethodWithArgs();
    void testInvokeMethodWithReturnValue();
    void testInvokeMethodNotFound();
    void testInvokeMethodWrongArgCount();
```

**Test cases:**

*Property operations:*
1. Get "text" property from QPushButton -> returns string
2. Get "width" property from QWidget -> returns int
3. Get nonexistent property -> throws with "Property not found"
4. Set "text" on QPushButton -> changes text
5. Set "minimumWidth" on QWidget -> changes value
6. Set "objectName" (not normally read-only, but test pattern)
7. Set with type coercion: set int property with JSON string "42" -> works
8. Set/get dynamic property -> works

*Method invocation:*
9. Invoke "click()" on QPushButton -> succeeds (void return)
10. Invoke "text()" on QLineEdit -> returns current text
11. Invoke "setText(QString)" with arg -> changes text
12. Invoke nonexistent method -> throws "Method not found"
13. Invoke with wrong arg count -> throws error
  </action>
  <verify>
`ctest --test-dir build -R meta_inspector` passes
All new test cases pass
  </verify>
  <done>
Property get/set fully tested
Method invocation fully tested
Error cases properly handled
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build` succeeds
2. Tests: `ctest --test-dir build -R meta_inspector` shows all tests passing
3. Manual: Set a widget's text property, verify it changes visually
</verification>

<success_criteria>
- getProperty returns any readable property as JSON
- setProperty modifies writable properties with type coercion
- setProperty throws clear error on read-only properties
- invokeMethod calls any slot or Q_INVOKABLE with JSON args
- invokeMethod returns result as JSON (null for void)
- All error cases have clear error messages
- Unit tests prove all functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-introspection/02-04-SUMMARY.md`
</output>
