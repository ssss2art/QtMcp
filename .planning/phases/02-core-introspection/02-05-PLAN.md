---
phase: 02-core-introspection
plan: 05
type: execute
wave: 3
depends_on: ["02-01", "02-03"]
files_modified:
  - src/probe/introspection/signal_monitor.h
  - src/probe/introspection/signal_monitor.cpp
  - src/probe/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Clients can subscribe to signals on specific objects"
    - "Signal emissions push notifications to subscribed clients"
    - "Subscriptions auto-unsubscribe when object is destroyed"
    - "Object created/destroyed events can be subscribed to"
  artifacts:
    - path: "src/probe/introspection/signal_monitor.h"
      provides: "Signal subscription and notification system"
      exports: ["SignalMonitor", "subscribe", "unsubscribe"]
    - path: "src/probe/introspection/signal_monitor.cpp"
      provides: "Signal monitoring implementation"
      contains: "signalEmitted"
  key_links:
    - from: "src/probe/introspection/signal_monitor.cpp"
      to: "QMetaObject::connect"
      via: "dynamic signal connection"
      pattern: "QObject::connect"
    - from: "src/probe/introspection/signal_monitor.cpp"
      to: "ObjectRegistry"
      via: "object lifecycle events"
      pattern: "objectAdded|objectRemoved"
---

<objective>
Create the Signal Monitor that enables push notifications for signal emissions and object lifecycle events.

Purpose: Implement SIG-01 through SIG-05 - clients can subscribe to signals and receive real-time notifications when signals emit or objects are created/destroyed.

Output: SignalMonitor class that manages subscriptions and emits notifications for forwarding to clients.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-introspection/02-RESEARCH.md
@.planning/phases/02-core-introspection/02-CONTEXT.md
@src/probe/core/object_registry.h
@src/probe/introspection/meta_inspector.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SignalMonitor class with subscription management</name>
  <files>
    src/probe/introspection/signal_monitor.h
    src/probe/introspection/signal_monitor.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
Create SignalMonitor for signal subscription and notification:

**src/probe/introspection/signal_monitor.h:**
```cpp
#pragma once
#include <QObject>
#include <QPointer>
#include <QHash>
#include <QJsonArray>
#include <QJsonObject>

namespace qtmcp {

class QTMCP_EXPORT SignalMonitor : public QObject {
    Q_OBJECT
public:
    static SignalMonitor* instance();

    /// Subscribe to a signal on an object (SIG-01).
    /// @param objectId Object's hierarchical ID
    /// @param signalName Signal name (without arguments)
    /// @return Subscription ID for later unsubscribe
    /// @throws std::runtime_error if object/signal not found
    QString subscribe(const QString& objectId, const QString& signalName);

    /// Unsubscribe from a signal (SIG-02).
    /// @param subscriptionId ID returned from subscribe()
    void unsubscribe(const QString& subscriptionId);

    /// Unsubscribe all subscriptions for an object.
    void unsubscribeAll(const QString& objectId);

    /// Enable/disable object lifecycle notifications (SIG-04, SIG-05).
    void setLifecycleNotificationsEnabled(bool enabled);
    bool lifecycleNotificationsEnabled() const;

    /// Get active subscription count.
    int subscriptionCount() const;

signals:
    /// Emitted when a subscribed signal fires (SIG-03).
    /// @param notification JSON object with: subscriptionId, objectId, signal, arguments[]
    void signalEmitted(const QJsonObject& notification);

    /// Emitted when an object is created (SIG-04).
    /// @param notification JSON object with: event="created", objectId, className
    void objectCreated(const QJsonObject& notification);

    /// Emitted when an object is destroyed (SIG-05).
    /// @param notification JSON object with: event="destroyed", objectId
    void objectDestroyed(const QJsonObject& notification);

private slots:
    void onObjectAdded(QObject* obj);
    void onObjectRemoved(QObject* obj);
    void onSubscribedObjectDestroyed(QObject* obj);

private:
    SignalMonitor();
    ~SignalMonitor() override;

    struct Subscription {
        QPointer<QObject> object;
        QString objectId;
        QString signalName;
        QMetaObject::Connection connection;
    };

    QHash<QString, Subscription> m_subscriptions;
    int m_nextId = 1;
    bool m_lifecycleEnabled = false;
    mutable QMutex m_mutex;

public:
    // For Q_GLOBAL_STATIC
    friend class SignalMonitorGlobal;
};

}  // namespace qtmcp
```

**src/probe/introspection/signal_monitor.cpp:**

Key implementation details:

1. **Singleton pattern:** Use Q_GLOBAL_STATIC like Probe and ObjectRegistry

2. **subscribe() implementation:**
```cpp
QString SignalMonitor::subscribe(const QString& objectId, const QString& signalName) {
    QObject* obj = ObjectRegistry::instance()->findById(objectId);
    if (!obj)
        throw std::runtime_error("Object not found: " + objectId.toStdString());

    const QMetaObject* meta = obj->metaObject();

    // Find signal by name
    int signalIndex = -1;
    for (int i = 0; i < meta->methodCount(); ++i) {
        QMetaMethod method = meta->method(i);
        if (method.methodType() == QMetaMethod::Signal &&
            QString::fromLatin1(method.name()) == signalName) {
            signalIndex = i;
            break;
        }
    }

    if (signalIndex < 0)
        throw std::runtime_error("Signal not found: " + signalName.toStdString());

    QString subId = QStringLiteral("sub_%1").arg(m_nextId++);

    // Connect using lambda that captures subscription info
    QMetaMethod signal = meta->method(signalIndex);
    auto conn = connect(obj, signal, this, [this, subId, objectId, signalName]() {
        // Note: Cannot capture signal arguments with generic lambda
        // For MVP, emit without arguments
        QJsonObject notification;
        notification["subscriptionId"] = subId;
        notification["objectId"] = objectId;
        notification["signal"] = signalName;
        notification["arguments"] = QJsonArray();  // Empty for now
        emit signalEmitted(notification);
    });

    // Watch for object destruction
    connect(obj, &QObject::destroyed, this, &SignalMonitor::onSubscribedObjectDestroyed);

    QMutexLocker lock(&m_mutex);
    m_subscriptions.insert(subId, {obj, objectId, signalName, conn});

    return subId;
}
```

3. **Auto-unsubscribe on destruction:**
```cpp
void SignalMonitor::onSubscribedObjectDestroyed(QObject* obj) {
    QMutexLocker lock(&m_mutex);
    QStringList toRemove;

    for (auto it = m_subscriptions.begin(); it != m_subscriptions.end(); ++it) {
        if (it->object == obj) {
            toRemove.append(it.key());
        }
    }

    for (const QString& id : toRemove) {
        m_subscriptions.remove(id);
    }

    // Per CONTEXT.md: push notification to client about auto-unsubscribe
    // (handled via objectDestroyed signal)
}
```

4. **Lifecycle events:**
Connect to ObjectRegistry::objectAdded and objectRemoved in constructor.

**src/probe/CMakeLists.txt:**
- Add signal_monitor.h and signal_monitor.cpp to sources
  </action>
  <verify>
Build succeeds
SignalMonitor singleton accessible
subscribe() returns subscription ID
  </verify>
  <done>
SignalMonitor class created
Subscription management implemented
Lifecycle notification hooks in place
  </done>
</task>

<task type="auto">
  <name>Task 2: Connect SignalMonitor to ObjectRegistry lifecycle</name>
  <files>
    src/probe/introspection/signal_monitor.cpp
  </files>
  <action>
Wire SignalMonitor to ObjectRegistry for lifecycle events:

**In SignalMonitor constructor:**
```cpp
SignalMonitor::SignalMonitor() : QObject(nullptr) {
    // Connect to ObjectRegistry lifecycle events
    connect(ObjectRegistry::instance(), &ObjectRegistry::objectAdded,
            this, &SignalMonitor::onObjectAdded);
    connect(ObjectRegistry::instance(), &ObjectRegistry::objectRemoved,
            this, &SignalMonitor::onObjectRemoved);
}
```

**onObjectAdded() implementation (SIG-04):**
```cpp
void SignalMonitor::onObjectAdded(QObject* obj) {
    if (!m_lifecycleEnabled)
        return;

    QJsonObject notification;
    notification["event"] = QStringLiteral("created");
    notification["objectId"] = ObjectRegistry::instance()->objectId(obj);
    notification["className"] = QString::fromLatin1(obj->metaObject()->className());

    emit objectCreated(notification);
}
```

**onObjectRemoved() implementation (SIG-05):**
```cpp
void SignalMonitor::onObjectRemoved(QObject* obj) {
    // Always clean up subscriptions
    onSubscribedObjectDestroyed(obj);

    if (!m_lifecycleEnabled)
        return;

    QJsonObject notification;
    notification["event"] = QStringLiteral("destroyed");
    notification["objectId"] = ObjectRegistry::instance()->objectId(obj);

    emit objectDestroyed(notification);
}
```

**Note:** Lifecycle notifications are opt-in (disabled by default) because they can be very noisy in large applications.
  </action>
  <verify>
Build succeeds
onObjectAdded/onObjectRemoved called when objects created/destroyed
Notifications emitted when lifecycle enabled
  </verify>
  <done>
SignalMonitor connected to ObjectRegistry
Lifecycle events propagate correctly
Auto-unsubscribe works on object destruction
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for SignalMonitor</name>
  <files>
    tests/test_signal_monitor.cpp
    tests/CMakeLists.txt
  </files>
  <action>
Create comprehensive tests for SignalMonitor:

**tests/test_signal_monitor.cpp:**
```cpp
#include <QtTest>
#include <QSignalSpy>
#include <QPushButton>
#include "probe/introspection/signal_monitor.h"
#include "probe/core/object_registry.h"

class TestSignalMonitor : public QObject {
    Q_OBJECT
private slots:
    void initTestCase();
    void cleanupTestCase();
    void cleanup();

    void testSubscribe();
    void testUnsubscribe();
    void testSignalEmission();
    void testAutoUnsubscribeOnDestruction();
    void testLifecycleCreated();
    void testLifecycleDestroyed();
    void testSubscribeNonexistentObject();
    void testSubscribeNonexistentSignal();
};
```

**Test cases:**

1. `testSubscribe`: Subscribe to clicked() on QPushButton -> returns valid ID
2. `testUnsubscribe`: Subscribe then unsubscribe -> subscription removed
3. `testSignalEmission`: Subscribe to clicked(), emit clicked() -> signalEmitted fires
4. `testAutoUnsubscribeOnDestruction`: Subscribe, delete object -> subscription auto-removed
5. `testLifecycleCreated`: Enable lifecycle, create object -> objectCreated fires
6. `testLifecycleDestroyed`: Enable lifecycle, delete object -> objectDestroyed fires
7. `testSubscribeNonexistentObject`: Subscribe to bad ID -> throws
8. `testSubscribeNonexistentSignal`: Subscribe to bad signal name -> throws

**Use QSignalSpy to verify signal emissions:**
```cpp
void TestSignalMonitor::testSignalEmission() {
    QPushButton* btn = new QPushButton();
    btn->setObjectName("testBtn");

    QString objId = ObjectRegistry::instance()->objectId(btn);
    QString subId = SignalMonitor::instance()->subscribe(objId, "clicked");

    QSignalSpy spy(SignalMonitor::instance(), &SignalMonitor::signalEmitted);

    // Trigger the signal
    btn->click();

    QCOMPARE(spy.count(), 1);
    QJsonObject notification = spy.at(0).at(0).toJsonObject();
    QCOMPARE(notification["signal"].toString(), QString("clicked"));

    delete btn;
}
```

**tests/CMakeLists.txt:**
- Add test_signal_monitor executable
- Link Qt6::Widgets
  </action>
  <verify>
`ctest --test-dir build -R signal_monitor` passes
All 8 test cases pass
  </verify>
  <done>
Signal subscription/unsubscription tested
Signal emission notification tested
Lifecycle events tested
Error cases tested
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build` succeeds
2. Tests: `ctest --test-dir build -R signal_monitor` shows all tests passing
3. Manual: Subscribe to a button's clicked(), click it, verify notification
</verification>

<success_criteria>
- subscribe() creates subscription and returns ID
- unsubscribe() removes subscription
- Signal emission triggers signalEmitted notification
- Object destruction auto-unsubscribes and notifies client
- Lifecycle events (created/destroyed) can be enabled
- Unit tests prove all functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-introspection/02-05-SUMMARY.md`
</output>
