---
phase: 02-core-introspection
plan: 06
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/probe/interaction/input_simulator.h
  - src/probe/interaction/input_simulator.cpp
  - src/probe/interaction/screenshot.h
  - src/probe/interaction/screenshot.cpp
  - src/probe/interaction/hit_test.h
  - src/probe/interaction/hit_test.cpp
  - src/probe/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Mouse clicks can be simulated on any widget"
    - "Keyboard input can be sent to any widget"
    - "Screenshots can be captured of widgets or windows"
    - "Widget geometry available in local and global coordinates"
    - "Coordinate-to-widget mapping works for hit testing"
  artifacts:
    - path: "src/probe/interaction/input_simulator.h"
      provides: "Mouse and keyboard simulation"
      exports: ["mouseClick", "sendKeys", "sendText"]
    - path: "src/probe/interaction/screenshot.h"
      provides: "Screenshot capture"
      exports: ["captureWidget", "captureWindow"]
    - path: "src/probe/interaction/hit_test.h"
      provides: "Geometry and hit testing"
      exports: ["widgetGeometry", "widgetAt", "childAt"]
  key_links:
    - from: "src/probe/interaction/input_simulator.cpp"
      to: "QTest"
      via: "input simulation functions"
      pattern: "QTest::mouseClick|QTest::keyClick"
    - from: "src/probe/interaction/screenshot.cpp"
      to: "QWidget::grab"
      via: "widget capture"
      pattern: "widget->grab\\(\\)"
    - from: "src/probe/interaction/hit_test.cpp"
      to: "ObjectRegistry::objectId"
      via: "hierarchical ID lookup"
      pattern: "ObjectRegistry::instance\\(\\)->objectId"
---

<objective>
Create the UI Interaction layer for mouse/keyboard simulation, screenshots, and hit testing.

Purpose: Implement UI-01 through UI-05 - clients can simulate user input, capture screenshots, and perform coordinate-based element discovery.

Output: InputSimulator, Screenshot, and HitTest utility classes.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-introspection/02-RESEARCH.md
@.planning/phases/02-core-introspection/02-CONTEXT.md
@src/probe/core/object_registry.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InputSimulator for mouse and keyboard input</name>
  <files>
    src/probe/interaction/input_simulator.h
    src/probe/interaction/input_simulator.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
Create InputSimulator using QTest functions:

**Create src/probe/interaction/ directory**

**src/probe/interaction/input_simulator.h:**
```cpp
#pragma once
#include <QWidget>
#include <QPoint>
#include <QString>

namespace qtmcp {

/// Mouse and keyboard input simulation using QTest functions.
class InputSimulator {
public:
    /// Mouse button types
    enum class MouseButton { Left, Right, Middle };

    /// Simulate mouse click (UI-01).
    /// @param widget Target widget
    /// @param button Mouse button to click
    /// @param pos Position relative to widget (default: center)
    /// @param modifiers Keyboard modifiers (Ctrl, Shift, Alt)
    static void mouseClick(QWidget* widget, MouseButton button = MouseButton::Left,
                          const QPoint& pos = QPoint(),
                          Qt::KeyboardModifiers modifiers = Qt::NoModifier);

    /// Simulate mouse double-click.
    static void mouseDoubleClick(QWidget* widget, MouseButton button = MouseButton::Left,
                                 const QPoint& pos = QPoint(),
                                 Qt::KeyboardModifiers modifiers = Qt::NoModifier);

    /// Simulate text input (UI-02).
    /// @param widget Target widget (should be focusable)
    /// @param text Text to type
    static void sendText(QWidget* widget, const QString& text);

    /// Simulate key sequence (UI-02).
    /// @param widget Target widget
    /// @param sequence Key sequence string (e.g., "Ctrl+S", "Alt+F4")
    ///        Per CONTEXT.md: accepts both string format and will parse like QKeySequence
    static void sendKeySequence(QWidget* widget, const QString& sequence);

    /// Simulate individual key press.
    /// @param widget Target widget
    /// @param key Qt key code
    /// @param modifiers Keyboard modifiers
    static void sendKey(QWidget* widget, Qt::Key key,
                       Qt::KeyboardModifiers modifiers = Qt::NoModifier);

private:
    static Qt::MouseButton toQtButton(MouseButton button);
};

}  // namespace qtmcp
```

**src/probe/interaction/input_simulator.cpp:**

Use QTest functions from Qt Test module:

```cpp
#include "input_simulator.h"
#include <QTest>
#include <QKeySequence>
#include <QApplication>

namespace qtmcp {

void InputSimulator::mouseClick(QWidget* widget, MouseButton button,
                                const QPoint& pos, Qt::KeyboardModifiers modifiers) {
    // Per CONTEXT.md: coordinates are widget-local
    QPoint clickPos = pos.isNull() ? widget->rect().center() : pos;

    // Ensure widget is visible and ready
    widget->activateWindow();
    widget->raise();
    QApplication::processEvents();

    QTest::mouseClick(widget, toQtButton(button), modifiers, clickPos);
}

void InputSimulator::sendText(QWidget* widget, const QString& text) {
    // Ensure widget has focus
    widget->setFocus();
    QApplication::processEvents();

    // QTest::keyClicks sends each character
    QTest::keyClicks(widget, text);
}

void InputSimulator::sendKeySequence(QWidget* widget, const QString& sequence) {
    // Parse sequence like "Ctrl+Shift+A"
    QKeySequence keySeq(sequence, QKeySequence::PortableText);

    if (keySeq.isEmpty()) {
        throw std::runtime_error("Invalid key sequence: " + sequence.toStdString());
    }

    widget->setFocus();
    QApplication::processEvents();

    // Send the key combination
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    int key = keySeq[0].key();
    Qt::KeyboardModifiers mods = keySeq[0].keyboardModifiers();
#else
    int key = keySeq[0] & ~Qt::KeyboardModifierMask;
    Qt::KeyboardModifiers mods = Qt::KeyboardModifiers(keySeq[0] & Qt::KeyboardModifierMask);
#endif

    QTest::keyClick(widget, static_cast<Qt::Key>(key), mods);
}

Qt::MouseButton InputSimulator::toQtButton(MouseButton button) {
    switch (button) {
        case MouseButton::Left: return Qt::LeftButton;
        case MouseButton::Right: return Qt::RightButton;
        case MouseButton::Middle: return Qt::MiddleButton;
    }
    return Qt::LeftButton;
}

}  // namespace qtmcp
```

**src/probe/CMakeLists.txt:**
- Add interaction directory sources
- Ensure Qt6::Test is linked (should already be from Phase 1)
  </action>
  <verify>
Build succeeds
InputSimulator compiles with QTest functions
  </verify>
  <done>
InputSimulator created with mouse click and keyboard input
Uses QTest for reliable input simulation
Supports key sequences and text input
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Screenshot and HitTest utilities</name>
  <files>
    src/probe/interaction/screenshot.h
    src/probe/interaction/screenshot.cpp
    src/probe/interaction/hit_test.h
    src/probe/interaction/hit_test.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
Create Screenshot and HitTest utilities:

**src/probe/interaction/screenshot.h:**
```cpp
#pragma once
#include <QWidget>
#include <QByteArray>
#include <QRect>

namespace qtmcp {

/// Screenshot capture utility (UI-03).
class Screenshot {
public:
    /// Capture a widget and its children.
    /// @param widget Widget to capture
    /// @return Base64-encoded PNG image
    static QByteArray captureWidget(QWidget* widget);

    /// Capture an entire window including frame/decorations.
    /// @param window Window to capture (should be top-level)
    /// @return Base64-encoded PNG image
    static QByteArray captureWindow(QWidget* window);

    /// Capture a rectangular region of a widget.
    /// @param widget Widget to capture from
    /// @param region Rectangle in widget coordinates
    /// @return Base64-encoded PNG image
    static QByteArray captureRegion(QWidget* widget, const QRect& region);
};

}  // namespace qtmcp
```

**src/probe/interaction/screenshot.cpp:**
```cpp
#include "screenshot.h"
#include <QPixmap>
#include <QBuffer>
#include <QScreen>
#include <QGuiApplication>

namespace qtmcp {

QByteArray Screenshot::captureWidget(QWidget* widget) {
    // QWidget::grab() captures the widget and all children
    QPixmap pixmap = widget->grab();

    QByteArray bytes;
    QBuffer buffer(&bytes);
    buffer.open(QIODevice::WriteOnly);
    pixmap.save(&buffer, "PNG");

    return bytes.toBase64();
}

QByteArray Screenshot::captureWindow(QWidget* window) {
    // Use screen grab for window including frame
    QScreen* screen = window->screen();
    if (!screen)
        screen = QGuiApplication::primaryScreen();

    if (!screen)
        throw std::runtime_error("Cannot determine screen for screenshot");

    QPixmap pixmap = screen->grabWindow(window->winId());

    QByteArray bytes;
    QBuffer buffer(&bytes);
    buffer.open(QIODevice::WriteOnly);
    pixmap.save(&buffer, "PNG");

    return bytes.toBase64();
}

QByteArray Screenshot::captureRegion(QWidget* widget, const QRect& region) {
    QPixmap pixmap = widget->grab(region);

    QByteArray bytes;
    QBuffer buffer(&bytes);
    buffer.open(QIODevice::WriteOnly);
    pixmap.save(&buffer, "PNG");

    return bytes.toBase64();
}

}  // namespace qtmcp
```

**src/probe/interaction/hit_test.h:**
```cpp
#pragma once
#include <QWidget>
#include <QPoint>
#include <QJsonObject>

namespace qtmcp {

/// Widget geometry and hit testing utilities (UI-04, UI-05).
class HitTest {
public:
    /// Get widget geometry in local and global coordinates (UI-04).
    /// @param widget Widget to query
    /// @return JSON with local and global geometry
    static QJsonObject widgetGeometry(QWidget* widget);

    /// Find widget at global screen coordinates.
    /// @param globalPos Screen coordinates
    /// @return Widget at position, or nullptr
    static QWidget* widgetAt(const QPoint& globalPos);

    /// Find deepest child widget at local coordinates (UI-05).
    /// @param parent Parent widget
    /// @param localPos Position relative to parent
    /// @return Deepest visible child at position, or parent if none
    static QWidget* childAt(QWidget* parent, const QPoint& localPos);

    /// Find widget and return its ID at global coordinates.
    /// @param globalPos Screen coordinates
    /// @return Object ID of widget at position, or empty string
    static QString widgetIdAt(const QPoint& globalPos);
};

}  // namespace qtmcp
```

**src/probe/interaction/hit_test.cpp:**
```cpp
#include "hit_test.h"
#include "probe/core/object_registry.h"
#include <QApplication>

namespace qtmcp {

QJsonObject HitTest::widgetGeometry(QWidget* widget) {
    QJsonObject result;

    // Local geometry (relative to parent)
    QRect local = widget->geometry();
    result["local"] = QJsonObject{
        {"x", local.x()},
        {"y", local.y()},
        {"width", local.width()},
        {"height", local.height()}
    };

    // Global geometry (screen coordinates)
    QPoint globalTopLeft = widget->mapToGlobal(QPoint(0, 0));
    result["global"] = QJsonObject{
        {"x", globalTopLeft.x()},
        {"y", globalTopLeft.y()},
        {"width", widget->width()},
        {"height", widget->height()}
    };

    // Device pixel ratio for high-DPI awareness
    result["devicePixelRatio"] = widget->devicePixelRatioF();

    return result;
}

QWidget* HitTest::widgetAt(const QPoint& globalPos) {
    return QApplication::widgetAt(globalPos);
}

QWidget* HitTest::childAt(QWidget* parent, const QPoint& localPos) {
    QWidget* child = parent->childAt(localPos);
    return child ? child : parent;
}

QString HitTest::widgetIdAt(const QPoint& globalPos) {
    QWidget* widget = widgetAt(globalPos);
    if (!widget)
        return QString();

    // Requires ObjectRegistry::objectId() from Plan 02-02
    return ObjectRegistry::instance()->objectId(widget);
}

}  // namespace qtmcp
```

**src/probe/CMakeLists.txt:**
- Add all interaction/*.cpp and interaction/*.h files
  </action>
  <verify>
Build succeeds
Screenshot::captureWidget returns base64 PNG
HitTest::widgetGeometry returns valid JSON
  </verify>
  <done>
Screenshot capture works for widget, window, and region
HitTest provides geometry and coordinate mapping
devicePixelRatio included for high-DPI support
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for UI interaction</name>
  <files>
    tests/test_ui_interaction.cpp
    tests/CMakeLists.txt
  </files>
  <action>
Create tests for InputSimulator, Screenshot, and HitTest:

**tests/test_ui_interaction.cpp:**
```cpp
#include <QtTest>
#include <QSignalSpy>
#include <QPushButton>
#include <QLineEdit>
#include <QMainWindow>
#include "probe/interaction/input_simulator.h"
#include "probe/interaction/screenshot.h"
#include "probe/interaction/hit_test.h"
#include "probe/core/object_registry.h"

class TestUIInteraction : public QObject {
    Q_OBJECT
private slots:
    void initTestCase();
    void cleanupTestCase();

    // InputSimulator tests
    void testMouseClick();
    void testMouseClickPosition();
    void testSendText();
    void testSendKeySequence();

    // Screenshot tests
    void testCaptureWidget();
    void testCaptureWindow();
    void testCaptureRegion();

    // HitTest tests
    void testWidgetGeometry();
    void testWidgetAt();
    void testChildAt();
};
```

**Test cases:**

*InputSimulator:*
1. `testMouseClick`: Click QPushButton -> clicked() signal emits
2. `testMouseClickPosition`: Click at specific position -> works correctly
3. `testSendText`: Type into QLineEdit -> text appears
4. `testSendKeySequence`: Send "Ctrl+A" to QLineEdit -> selects all

*Screenshot:*
5. `testCaptureWidget`: Capture QPushButton -> returns non-empty base64 starting with PNG header
6. `testCaptureWindow`: Capture QMainWindow -> returns non-empty base64
7. `testCaptureRegion`: Capture 50x50 region -> returns base64 of smaller image

*HitTest:*
8. `testWidgetGeometry`: Get geometry -> has local, global, devicePixelRatio
9. `testWidgetAt`: Show widget, call widgetAt at its position -> returns widget
10. `testChildAt`: Layout with button, call childAt -> returns button

**Implementation tips:**
- For screenshot tests, check base64 decodes to valid PNG (starts with PNG magic bytes after decode)
- For hit test, need to show() and processEvents() before coordinate tests work

**tests/CMakeLists.txt:**
- Add test_ui_interaction executable
- Link Qt6::Widgets and Qt6::Test
  </action>
  <verify>
`ctest --test-dir build -R ui_interaction` passes
All 10 test cases pass
  </verify>
  <done>
InputSimulator tests prove mouse and keyboard work
Screenshot tests prove capture works
HitTest tests prove geometry and hit testing work
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build` succeeds
2. Tests: `ctest --test-dir build -R ui_interaction` shows all tests passing
3. Manual: Click a button via InputSimulator, verify visual feedback
</verification>

<success_criteria>
- Mouse clicks work with left/right/middle buttons
- Keyboard input works for text and key sequences
- Screenshots capture widgets as base64 PNG
- Widget geometry includes local and global coordinates
- Hit testing finds widget at coordinates
- Unit tests prove all functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-introspection/02-06-SUMMARY.md`
</output>
