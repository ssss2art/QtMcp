---
phase: 02-core-introspection
plan: 07
type: execute
wave: 4
depends_on: ["02-02", "02-04", "02-05", "02-06"]
files_modified:
  - src/probe/transport/jsonrpc_handler.cpp
  - src/probe/core/probe.h
  - src/probe/core/probe.cpp
autonomous: true

must_haves:
  truths:
    - "All introspection methods accessible via JSON-RPC"
    - "Object discovery methods (findByObjectName, findByClassName, getObjectTree) work"
    - "Property methods (getProperty, setProperty, listProperties) work"
    - "Method invocation (listMethods, invokeMethod) works"
    - "Signal monitoring (subscribe, unsubscribe) with push notifications works"
    - "UI interaction (click, sendKeys, screenshot, getGeometry) works"
  artifacts:
    - path: "src/probe/transport/jsonrpc_handler.cpp"
      provides: "All introspection JSON-RPC method registrations"
      contains: "RegisterMethod"
  key_links:
    - from: "src/probe/transport/jsonrpc_handler.cpp"
      to: "ObjectRegistry"
      via: "object lookup"
      pattern: "ObjectRegistry::instance\\(\\)"
    - from: "src/probe/transport/jsonrpc_handler.cpp"
      to: "MetaInspector"
      via: "introspection"
      pattern: "MetaInspector::"
    - from: "src/probe/transport/jsonrpc_handler.cpp"
      to: "SignalMonitor"
      via: "signal subscription"
      pattern: "SignalMonitor::instance\\(\\)"
    - from: "src/probe/core/probe.cpp"
      to: "SignalMonitor::signalEmitted"
      via: "notification forwarding"
      pattern: "connect.*signalEmitted"
---

<objective>
Wire all introspection functionality to the JSON-RPC handler, completing the Core Introspection phase.

Purpose: Make all Phase 2 capabilities accessible to clients via the existing WebSocket JSON-RPC transport. This is the integration layer that ties everything together.

Output: Complete JSON-RPC API for object discovery, introspection, signal monitoring, and UI interaction.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-introspection/02-RESEARCH.md
@.planning/phases/02-core-introspection/02-CONTEXT.md
@src/probe/transport/jsonrpc_handler.h
@src/probe/transport/websocket_server.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register object discovery and introspection methods</name>
  <files>
    src/probe/transport/jsonrpc_handler.cpp
  </files>
  <action>
Add JSON-RPC methods for object discovery and introspection:

**Object Discovery Methods (OBJ-01, OBJ-02, OBJ-03, OBJ-11):**

```cpp
// In RegisterBuiltinMethods() or new RegisterIntrospectionMethods():

// OBJ-01: findByObjectName
RegisterMethod("qtmcp.findByObjectName", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString name = doc.object()["name"].toString();
    QString root = doc.object()["root"].toString();  // Optional

    QObject* rootObj = root.isEmpty() ? nullptr
        : ObjectRegistry::instance()->findById(root);
    QObject* found = ObjectRegistry::instance()->findByObjectName(name, rootObj);

    if (!found) {
        throw std::runtime_error("Object not found: " + name.toStdString());
    }

    QString id = ObjectRegistry::instance()->objectId(found);
    return QJsonDocument(QJsonObject{{"id", id}}).toJson(QJsonDocument::Compact);
});

// OBJ-02: findByClassName
RegisterMethod("qtmcp.findByClassName", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString className = doc.object()["className"].toString();
    QString root = doc.object()["root"].toString();

    QObject* rootObj = root.isEmpty() ? nullptr
        : ObjectRegistry::instance()->findById(root);
    QList<QObject*> found = ObjectRegistry::instance()->findAllByClassName(className, rootObj);

    QJsonArray ids;
    for (QObject* obj : found) {
        ids.append(ObjectRegistry::instance()->objectId(obj));
    }

    return QJsonDocument(QJsonObject{{"ids", ids}}).toJson(QJsonDocument::Compact);
});

// OBJ-03: getObjectTree
RegisterMethod("qtmcp.getObjectTree", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString root = doc.object()["root"].toString();
    int maxDepth = doc.object()["maxDepth"].toInt(-1);

    QObject* rootObj = root.isEmpty() ? nullptr
        : ObjectRegistry::instance()->findById(root);

    QJsonObject tree = serializeObjectTree(rootObj, maxDepth);
    return QJsonDocument(tree).toJson(QJsonDocument::Compact);
});

// OBJ-04: getObjectInfo
RegisterMethod("qtmcp.getObjectInfo", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QJsonObject info = MetaInspector::objectInfo(obj);
    return QJsonDocument(info).toJson(QJsonDocument::Compact);
});
```

**Property Methods (OBJ-05, OBJ-06, OBJ-07):**

```cpp
// OBJ-05: listProperties
RegisterMethod("qtmcp.listProperties", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QJsonArray props = MetaInspector::listProperties(obj);
    return QJsonDocument(props).toJson(QJsonDocument::Compact);
});

// OBJ-06: getProperty
RegisterMethod("qtmcp.getProperty", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();
    QString name = doc.object()["name"].toString();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QJsonValue value = MetaInspector::getProperty(obj, name);
    return QJsonDocument(QJsonObject{{"value", value}}).toJson(QJsonDocument::Compact);
});

// OBJ-07: setProperty
RegisterMethod("qtmcp.setProperty", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();
    QString name = doc.object()["name"].toString();
    QJsonValue value = doc.object()["value"];

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    bool ok = MetaInspector::setProperty(obj, name, value);
    return QJsonDocument(QJsonObject{{"success", ok}}).toJson(QJsonDocument::Compact);
});
```

**Method Invocation (OBJ-08, OBJ-09, OBJ-10):**

```cpp
// OBJ-08: listMethods
RegisterMethod("qtmcp.listMethods", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QJsonArray methods = MetaInspector::listMethods(obj);
    return QJsonDocument(methods).toJson(QJsonDocument::Compact);
});

// OBJ-09: invokeMethod
RegisterMethod("qtmcp.invokeMethod", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();
    QString method = doc.object()["method"].toString();
    QJsonArray args = doc.object()["args"].toArray();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QJsonValue result = MetaInspector::invokeMethod(obj, method, args);
    return QJsonDocument(QJsonObject{{"result", result}}).toJson(QJsonDocument::Compact);
});

// OBJ-10: listSignals
RegisterMethod("qtmcp.listSignals", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QJsonArray signals = MetaInspector::listSignals(obj);
    return QJsonDocument(signals).toJson(QJsonDocument::Compact);
});
```

**Include necessary headers at top of file:**
```cpp
#include "probe/core/object_registry.h"
#include "probe/introspection/meta_inspector.h"
#include "probe/introspection/object_id.h"
```
  </action>
  <verify>
Build succeeds
Methods registered without errors
  </verify>
  <done>
Object discovery methods registered (findByObjectName, findByClassName, getObjectTree)
Object info method registered (getObjectInfo)
Property methods registered (listProperties, getProperty, setProperty)
Method methods registered (listMethods, invokeMethod, listSignals)
  </done>
</task>

<task type="auto">
  <name>Task 2: Register signal monitoring and UI interaction methods</name>
  <files>
    src/probe/transport/jsonrpc_handler.cpp
    src/probe/core/probe.h
    src/probe/core/probe.cpp
  </files>
  <action>
Add signal monitoring and UI interaction JSON-RPC methods:

**Signal Monitoring (SIG-01, SIG-02):**

```cpp
// SIG-01: subscribeSignal
RegisterMethod("qtmcp.subscribeSignal", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString objectId = doc.object()["objectId"].toString();
    QString signalName = doc.object()["signal"].toString();

    QString subId = SignalMonitor::instance()->subscribe(objectId, signalName);
    return QJsonDocument(QJsonObject{{"subscriptionId", subId}}).toJson(QJsonDocument::Compact);
});

// SIG-02: unsubscribeSignal
RegisterMethod("qtmcp.unsubscribeSignal", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString subId = doc.object()["subscriptionId"].toString();

    SignalMonitor::instance()->unsubscribe(subId);
    return QJsonDocument(QJsonObject{{"success", true}}).toJson(QJsonDocument::Compact);
});

// Lifecycle notifications toggle
RegisterMethod("qtmcp.setLifecycleNotifications", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    bool enabled = doc.object()["enabled"].toBool();

    SignalMonitor::instance()->setLifecycleNotificationsEnabled(enabled);
    return QJsonDocument(QJsonObject{{"enabled", enabled}}).toJson(QJsonDocument::Compact);
});
```

**UI Interaction (UI-01, UI-02, UI-03, UI-04, UI-05):**

```cpp
// UI-01: click
RegisterMethod("qtmcp.click", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();
    QString button = doc.object()["button"].toString("left");
    QJsonObject pos = doc.object()["position"].toObject();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QWidget* widget = qobject_cast<QWidget*>(obj);
    if (!widget)
        throw std::runtime_error("Object is not a widget: " + id.toStdString());

    InputSimulator::MouseButton btn = InputSimulator::MouseButton::Left;
    if (button == "right") btn = InputSimulator::MouseButton::Right;
    else if (button == "middle") btn = InputSimulator::MouseButton::Middle;

    QPoint clickPos;
    if (!pos.isEmpty()) {
        clickPos = QPoint(pos["x"].toInt(), pos["y"].toInt());
    }

    InputSimulator::mouseClick(widget, btn, clickPos);
    return QJsonDocument(QJsonObject{{"success", true}}).toJson(QJsonDocument::Compact);
});

// UI-02: sendKeys
RegisterMethod("qtmcp.sendKeys", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();
    QString text = doc.object()["text"].toString();
    QString sequence = doc.object()["sequence"].toString();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QWidget* widget = qobject_cast<QWidget*>(obj);
    if (!widget)
        throw std::runtime_error("Object is not a widget: " + id.toStdString());

    if (!text.isEmpty()) {
        InputSimulator::sendText(widget, text);
    }
    if (!sequence.isEmpty()) {
        InputSimulator::sendKeySequence(widget, sequence);
    }

    return QJsonDocument(QJsonObject{{"success", true}}).toJson(QJsonDocument::Compact);
});

// UI-03: screenshot
RegisterMethod("qtmcp.screenshot", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();
    bool fullWindow = doc.object()["fullWindow"].toBool(false);
    QJsonObject region = doc.object()["region"].toObject();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QWidget* widget = qobject_cast<QWidget*>(obj);
    if (!widget)
        throw std::runtime_error("Object is not a widget: " + id.toStdString());

    QByteArray base64;
    if (fullWindow) {
        base64 = Screenshot::captureWindow(widget);
    } else if (!region.isEmpty()) {
        QRect rect(region["x"].toInt(), region["y"].toInt(),
                   region["width"].toInt(), region["height"].toInt());
        base64 = Screenshot::captureRegion(widget, rect);
    } else {
        base64 = Screenshot::captureWidget(widget);
    }

    return QJsonDocument(QJsonObject{{"image", QString::fromLatin1(base64)}}).toJson(QJsonDocument::Compact);
});

// UI-04: getGeometry
RegisterMethod("qtmcp.getGeometry", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    QString id = doc.object()["id"].toString();

    QObject* obj = ObjectRegistry::instance()->findById(id);
    if (!obj)
        throw std::runtime_error("Object not found: " + id.toStdString());

    QWidget* widget = qobject_cast<QWidget*>(obj);
    if (!widget)
        throw std::runtime_error("Object is not a widget: " + id.toStdString());

    QJsonObject geo = HitTest::widgetGeometry(widget);
    return QJsonDocument(geo).toJson(QJsonDocument::Compact);
});

// UI-05: hitTest
RegisterMethod("qtmcp.hitTest", [](const QString& params) {
    QJsonDocument doc = QJsonDocument::fromJson(params.toUtf8());
    int x = doc.object()["x"].toInt();
    int y = doc.object()["y"].toInt();
    QString parentId = doc.object()["parentId"].toString();

    QString foundId;
    if (!parentId.isEmpty()) {
        QObject* parentObj = ObjectRegistry::instance()->findById(parentId);
        if (!parentObj)
            throw std::runtime_error("Parent object not found: " + parentId.toStdString());

        QWidget* parent = qobject_cast<QWidget*>(parentObj);
        if (!parent)
            throw std::runtime_error("Parent is not a widget");

        QWidget* child = HitTest::childAt(parent, QPoint(x, y));
        foundId = ObjectRegistry::instance()->objectId(child);
    } else {
        foundId = HitTest::widgetIdAt(QPoint(x, y));
    }

    if (foundId.isEmpty())
        return QJsonDocument(QJsonObject{{"id", QJsonValue::Null}}).toJson(QJsonDocument::Compact);

    return QJsonDocument(QJsonObject{{"id", foundId}}).toJson(QJsonDocument::Compact);
});
```

**Include additional headers:**
```cpp
#include "probe/introspection/signal_monitor.h"
#include "probe/interaction/input_simulator.h"
#include "probe/interaction/screenshot.h"
#include "probe/interaction/hit_test.h"
```

**Wire signal notifications to WebSocket (in Probe::initialize()):**
```cpp
// Connect SignalMonitor notifications to WebSocket client
connect(SignalMonitor::instance(), &SignalMonitor::signalEmitted,
        this, [this](const QJsonObject& notification) {
    if (m_server) {
        QJsonObject rpcNotification;
        rpcNotification["jsonrpc"] = "2.0";
        rpcNotification["method"] = "qtmcp.signalEmitted";
        rpcNotification["params"] = notification;
        m_server->sendMessage(QJsonDocument(rpcNotification).toJson(QJsonDocument::Compact));
    }
});

connect(SignalMonitor::instance(), &SignalMonitor::objectCreated,
        this, [this](const QJsonObject& notification) {
    if (m_server) {
        QJsonObject rpcNotification;
        rpcNotification["jsonrpc"] = "2.0";
        rpcNotification["method"] = "qtmcp.objectCreated";
        rpcNotification["params"] = notification;
        m_server->sendMessage(QJsonDocument(rpcNotification).toJson(QJsonDocument::Compact));
    }
});

connect(SignalMonitor::instance(), &SignalMonitor::objectDestroyed,
        this, [this](const QJsonObject& notification) {
    if (m_server) {
        QJsonObject rpcNotification;
        rpcNotification["jsonrpc"] = "2.0";
        rpcNotification["method"] = "qtmcp.objectDestroyed";
        rpcNotification["params"] = notification;
        m_server->sendMessage(QJsonDocument(rpcNotification).toJson(QJsonDocument::Compact));
    }
});
```
  </action>
  <verify>
Build succeeds
Signal methods registered
UI interaction methods registered
Notifications wired to WebSocket
  </verify>
  <done>
Signal monitoring methods registered (subscribe, unsubscribe, setLifecycleNotifications)
UI interaction methods registered (click, sendKeys, screenshot, getGeometry, hitTest)
Push notifications wired to WebSocket client
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration test for complete API</name>
  <files>
    tests/test_jsonrpc_introspection.cpp
    tests/CMakeLists.txt
  </files>
  <action>
Create integration tests that verify the JSON-RPC API end-to-end:

**tests/test_jsonrpc_introspection.cpp:**
```cpp
#include <QtTest>
#include <QPushButton>
#include <QLineEdit>
#include <QMainWindow>
#include "probe/transport/jsonrpc_handler.h"
#include "probe/core/object_registry.h"
#include "probe/introspection/signal_monitor.h"

class TestJsonRpcIntrospection : public QObject {
    Q_OBJECT
private slots:
    void initTestCase();
    void cleanupTestCase();
    void init();

    // Object discovery
    void testFindByObjectName();
    void testFindByClassName();
    void testGetObjectTree();
    void testGetObjectInfo();

    // Properties
    void testListProperties();
    void testGetProperty();
    void testSetProperty();

    // Methods
    void testListMethods();
    void testInvokeMethod();
    void testListSignals();

    // Signals
    void testSubscribeSignal();
    void testUnsubscribeSignal();

    // UI Interaction
    void testClick();
    void testSendKeys();
    void testScreenshot();
    void testGetGeometry();
    void testHitTest();

private:
    QString callMethod(const QString& method, const QJsonObject& params);
    JsonRpcHandler* m_handler = nullptr;
    QWidget* m_testWidget = nullptr;
};
```

**Test approach:**
1. Create test widgets with known objectNames
2. Send JSON-RPC requests via HandleMessage()
3. Verify responses contain expected data

**Key test cases:**

```cpp
void TestJsonRpcIntrospection::testFindByObjectName() {
    QString response = callMethod("qtmcp.findByObjectName",
        QJsonObject{{"name", "testButton"}});

    QJsonDocument doc = QJsonDocument::fromJson(response.toUtf8());
    QVERIFY(!doc.object()["result"].toObject()["id"].toString().isEmpty());
}

void TestJsonRpcIntrospection::testClick() {
    QSignalSpy spy(m_testWidget, SIGNAL(clicked()));

    callMethod("qtmcp.click", QJsonObject{
        {"id", ObjectRegistry::instance()->objectId(m_testWidget)}
    });

    QCOMPARE(spy.count(), 1);
}

void TestJsonRpcIntrospection::testScreenshot() {
    QString response = callMethod("qtmcp.screenshot", QJsonObject{
        {"id", ObjectRegistry::instance()->objectId(m_testWidget)}
    });

    QJsonDocument doc = QJsonDocument::fromJson(response.toUtf8());
    QString base64 = doc.object()["result"].toObject()["image"].toString();
    QVERIFY(!base64.isEmpty());

    // Verify it's valid base64 PNG
    QByteArray decoded = QByteArray::fromBase64(base64.toLatin1());
    QVERIFY(decoded.startsWith("\x89PNG"));
}
```

**tests/CMakeLists.txt:**
- Add test_jsonrpc_introspection executable
- Link all probe libraries
  </action>
  <verify>
`ctest --test-dir build -R jsonrpc_introspection` passes
All 15+ test cases pass
  </verify>
  <done>
Integration tests prove JSON-RPC API works end-to-end
All object discovery methods tested
All property methods tested
All method invocation tested
All signal methods tested
All UI interaction methods tested
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build` succeeds
2. Tests: `ctest --test-dir build -R jsonrpc_introspection` shows all tests passing
3. Manual: Connect WebSocket client, call qtmcp.getObjectTree, verify JSON response
</verification>

<success_criteria>
- All 21 requirements (OBJ-*, SIG-*, UI-*) accessible via JSON-RPC
- Object discovery works (findByObjectName, findByClassName, getObjectTree)
- Introspection works (getObjectInfo, listProperties, listMethods, listSignals)
- Mutation works (setProperty, invokeMethod)
- Signal subscription works with push notifications
- UI interaction works (click, sendKeys, screenshot, getGeometry, hitTest)
- Integration tests prove end-to-end functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-introspection/02-07-SUMMARY.md`
</output>
