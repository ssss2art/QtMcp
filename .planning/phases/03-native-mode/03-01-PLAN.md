---
phase: 03-native-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/probe/api/error_codes.h
  - src/probe/api/response_envelope.h
  - src/probe/api/response_envelope.cpp
  - src/probe/api/symbolic_name_map.h
  - src/probe/api/symbolic_name_map.cpp
  - src/probe/core/object_resolver.h
  - src/probe/core/object_resolver.cpp
  - src/probe/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "ObjectResolver::resolve() accepts hierarchical path IDs and resolves to QObject*"
    - "ObjectResolver::resolve() accepts numeric shorthand IDs (#N or plain digits) and resolves to QObject*"
    - "ObjectResolver::resolve() accepts symbolic names and resolves via SymbolicNameMap to QObject*"
    - "ResponseEnvelope::wrap() produces {result, meta} JSON with timestamp"
    - "SymbolicNameMap loads name->path mappings from a JSON file"
    - "SymbolicNameMap supports runtime register/unregister of names"
    - "ErrorCodes defines all application-specific error codes in -32000 to -32099 range"
  artifacts:
    - path: "src/probe/api/error_codes.h"
      provides: "Application-specific JSON-RPC error code constants"
      contains: "kObjectNotFound"
    - path: "src/probe/api/response_envelope.h"
      provides: "Uniform response envelope wrapper"
      contains: "ResponseEnvelope"
    - path: "src/probe/api/symbolic_name_map.h"
      provides: "Squish-style symbolic name aliases"
      contains: "SymbolicNameMap"
    - path: "src/probe/core/object_resolver.h"
      provides: "Multi-style object ID resolution"
      contains: "ObjectResolver"
  key_links:
    - from: "src/probe/core/object_resolver.cpp"
      to: "src/probe/api/symbolic_name_map.h"
      via: "SymbolicNameMap::instance()->resolve()"
      pattern: "SymbolicNameMap::instance"
    - from: "src/probe/core/object_resolver.cpp"
      to: "src/probe/core/object_registry.h"
      via: "ObjectRegistry::instance()->findById()"
      pattern: "ObjectRegistry::instance"
---

<objective>
Build the four foundational infrastructure classes required by the Native Mode API: ErrorCodes (error code constants), ResponseEnvelope (uniform response wrapper), SymbolicNameMap (Squish-style name aliases), and ObjectResolver (multi-style ID resolution).

Purpose: These classes eliminate boilerplate in the NativeModeApi plan by providing shared helpers for error handling, response formatting, and object lookup. All qt.* methods in Plan 02 will depend on these.
Output: 4 new classes (7 new files) in src/probe/api/ and src/probe/core/, CMakeLists.txt updated.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-native-mode/03-CONTEXT.md
@.planning/phases/03-native-mode/03-RESEARCH.md
@.planning/phases/02-core-introspection/02-07-SUMMARY.md

Key existing files to reference:
@src/probe/core/object_registry.h - findById(), objectId(), findByObjectName(), findAllByClassName()
@src/probe/transport/jsonrpc_handler.h - QTMCP_EXPORT macro, JsonRpcError namespace
@src/probe/CMakeLists.txt - Must add new source files here
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorCodes and ResponseEnvelope</name>
  <files>
    src/probe/api/error_codes.h
    src/probe/api/response_envelope.h
    src/probe/api/response_envelope.cpp
  </files>
  <action>
Create the `src/probe/api/` directory and two components:

**error_codes.h** - Header-only constants in `qtmcp::ErrorCode` namespace:
- Object errors (-32001 to -32009): kObjectNotFound, kObjectStale, kObjectNotWidget
- Property errors (-32010 to -32019): kPropertyNotFound, kPropertyReadOnly, kPropertyTypeMismatch
- Method errors (-32020 to -32029): kMethodNotFound, kMethodInvocationFailed, kMethodArgumentMismatch
- Signal errors (-32030 to -32039): kSignalNotFound, kSubscriptionNotFound
- UI errors (-32040 to -32049): kWidgetNotVisible, kWidgetNotEnabled, kScreenCaptureError
- Name map errors (-32050 to -32059): kNameNotFound, kNameAlreadyExists, kNameMapLoadError
All as `constexpr int`. Use `#pragma once`. Namespace `qtmcp::ErrorCode`.

**response_envelope.h/.cpp** - Class `ResponseEnvelope` in namespace `qtmcp`:
- Static method `QJsonObject wrap(const QJsonValue& result, const QString& objectId = QString())` - Returns `{"result": ..., "meta": {"timestamp": epoch_ms, "objectId": ...}}`. Use `QDateTime::currentMSecsSinceEpoch()` for timestamp. Only include objectId in meta if non-empty.
- Static method `QJsonObject wrap(const QJsonValue& result, const QJsonObject& extraMeta)` - Same but merges extraMeta fields into the meta object.
- Static helper `QString createError(int code, const QString& message, const QJsonObject& data = QJsonObject())` - Creates a JSON-RPC error object string `{"code":N,"message":"...","data":{...}}` for use in exception throwing. Include `data` field only if non-empty.
- Static helper `QString createValidationError(const QString& method, const QString& missingParam, const QJsonObject& expectedSchema)` - Convenience for -32602 validation errors with schema hint.

Note: The `wrap()` method returns QJsonObject (not QString). The caller (NativeModeApi in Plan 02) will serialize it. This avoids double serialization.

Use QTMCP_EXPORT macro (defined in jsonrpc_handler.h, or re-use the same pattern). Include `<QJsonObject>`, `<QJsonValue>`, `<QDateTime>`, `<QString>`.
  </action>
  <verify>
Files exist: `src/probe/api/error_codes.h`, `src/probe/api/response_envelope.h`, `src/probe/api/response_envelope.cpp`.
Build succeeds with `cmake --build build/`.
  </verify>
  <done>
ErrorCodes defines all application error codes. ResponseEnvelope provides wrap() and error helper methods. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SymbolicNameMap and ObjectResolver</name>
  <files>
    src/probe/api/symbolic_name_map.h
    src/probe/api/symbolic_name_map.cpp
    src/probe/core/object_resolver.h
    src/probe/core/object_resolver.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
**symbolic_name_map.h/.cpp** - Singleton `SymbolicNameMap` in namespace `qtmcp`:
- Use `Q_GLOBAL_STATIC` for the singleton instance (same pattern as ObjectRegistry, SignalMonitor).
- Static `SymbolicNameMap* instance()` returning the global static.
- `QString resolve(const QString& symbolicName) const` - Returns hierarchical path for name, or empty string if not found.
- `void registerName(const QString& name, const QString& path)` - Adds mapping. Overwrites if exists.
- `void unregisterName(const QString& name)` - Removes mapping.
- `QJsonObject allNames() const` - Returns all name->path entries as JSON object.
- `bool loadFromFile(const QString& filePath)` - Loads JSON file `{"name":"path",...}`. Uses QFile + QJsonDocument. Returns false on failure. Clears existing map first.
- `bool saveToFile(const QString& filePath) const` - Saves current map to JSON file.
- `bool validateAll() const` - Checks if all symbolic names still resolve to existing objects via ObjectRegistry::instance()->findById(). Returns false if any are stale.
- `QJsonArray validateNames() const` - Returns array of `{"name": ..., "path": ..., "valid": true/false}` for each entry.
- Internal: `QHash<QString, QString> m_nameMap` + `mutable QMutex m_mutex` for thread safety. All public methods lock the mutex.
- At probe initialization, auto-load from `QTMCP_NAME_MAP` env var if set, else look for `qtmcp-names.json` in current working directory. If neither exists, start empty (no error).

**object_resolver.h/.cpp** - Static utility class `ObjectResolver` in namespace `qtmcp`:
- `static QObject* resolve(const QString& id)` - Tries resolution in order:
  1. If id starts with '#' or is all digits: parse as numeric ID, look up in internal `QHash<int, QPointer<QObject>> s_numericIds`. Return if found and alive.
  2. Try `SymbolicNameMap::instance()->resolve(id)`. If non-empty, use result as hierarchical path.
  3. Fall through to `ObjectRegistry::instance()->findById(id)`.
  Returns nullptr if no resolution succeeds.
- `static int assignNumericId(QObject* obj)` - Assigns next monotonic integer (starting from 1). Stores in `s_numericIds`. Returns the assigned ID.
- `static QObject* findByNumericId(int numericId)` - Direct numeric lookup.
- `static void clearNumericIds()` - Clears all numeric IDs (call on client disconnect for session scoping).
- `static int numericIdFor(QObject* obj)` - Returns existing numeric ID for object, or -1 if not assigned.
- Internal state: `static QHash<int, QPointer<QObject>> s_numericIds`, `static QHash<QObject*, int> s_objectToNumericId`, `static std::atomic<int> s_nextId{1}`.

**CMakeLists.txt** - Add the 4 new source files to PROBE_SOURCES and PROBE_HEADERS:
- `api/error_codes.h` to PROBE_HEADERS
- `api/response_envelope.h` and `api/response_envelope.cpp` to PROBE_HEADERS and PROBE_SOURCES respectively
- `api/symbolic_name_map.h` and `api/symbolic_name_map.cpp` to PROBE_HEADERS and PROBE_SOURCES
- `core/object_resolver.h` and `core/object_resolver.cpp` to PROBE_HEADERS and PROBE_SOURCES
  </action>
  <verify>
Build succeeds: `cmake --build build/`.
All new files listed in CMakeLists.txt.
ObjectResolver::resolve() compiles and links against ObjectRegistry and SymbolicNameMap.
  </verify>
  <done>
SymbolicNameMap manages symbolic name aliases with thread-safe singleton. ObjectResolver resolves any of three ID styles (numeric, symbolic, hierarchical) to QObject*. Both compile and link correctly. CMakeLists.txt updated.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build/` succeeds with no errors
2. New files exist: error_codes.h, response_envelope.h/.cpp, symbolic_name_map.h/.cpp, object_resolver.h/.cpp
3. All new classes are in the `qtmcp` namespace
4. CMakeLists.txt includes all new source files
5. No existing tests broken (run ctest)
</verification>

<success_criteria>
- ErrorCodes provides all application-specific error codes as constexpr int values
- ResponseEnvelope::wrap() returns QJsonObject with {result, meta{timestamp}} structure
- SymbolicNameMap loads/saves JSON files and provides thread-safe name resolution
- ObjectResolver::resolve() handles all three ID styles (numeric #N, symbolic, hierarchical path)
- Project builds cleanly with all new files integrated
</success_criteria>

<output>
After completion, create `.planning/phases/03-native-mode/03-01-SUMMARY.md`
</output>
