---
phase: 03-native-mode
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/probe/api/native_mode_api.h
  - src/probe/api/native_mode_api.cpp
  - src/probe/core/probe.cpp
  - src/probe/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "All qt.objects.* methods (find, findByClass, tree, info, inspect, query) are callable via JSON-RPC"
    - "All qt.properties.* methods (list, get, set) are callable via JSON-RPC"
    - "All qt.methods.* methods (list, invoke) are callable via JSON-RPC"
    - "All qt.signals.* methods (list, subscribe, unsubscribe, setLifecycle) are callable via JSON-RPC"
    - "All qt.ui.* methods (click, sendKeys, screenshot, geometry, hitTest) are callable via JSON-RPC"
    - "All qt.names.* methods (register, unregister, list, validate, load, save) are callable via JSON-RPC"
    - "qt.ping returns event loop latency and timestamp"
    - "qt.version returns version info with deprecation notice for qtmcp.* methods"
    - "All responses are wrapped in {result, meta} envelope via ResponseEnvelope"
    - "All errors use ErrorCode constants with structured error data"
    - "Old qtmcp.* methods remain registered for backward compatibility"
  artifacts:
    - path: "src/probe/api/native_mode_api.h"
      provides: "NativeModeApi class registering all qt.* methods"
      contains: "NativeModeApi"
    - path: "src/probe/api/native_mode_api.cpp"
      provides: "Implementation of all qt.* method registrations"
      min_lines: 200
  key_links:
    - from: "src/probe/api/native_mode_api.cpp"
      to: "src/probe/transport/jsonrpc_handler.h"
      via: "RegisterMethod calls"
      pattern: "RegisterMethod.*qt\\."
    - from: "src/probe/api/native_mode_api.cpp"
      to: "src/probe/core/object_resolver.h"
      via: "ObjectResolver::resolve() in every method taking objectId"
      pattern: "ObjectResolver::resolve"
    - from: "src/probe/api/native_mode_api.cpp"
      to: "src/probe/api/response_envelope.h"
      via: "ResponseEnvelope::wrap() for all responses"
      pattern: "ResponseEnvelope::wrap"
    - from: "src/probe/core/probe.cpp"
      to: "src/probe/api/native_mode_api.h"
      via: "NativeModeApi instantiation during probe init"
      pattern: "NativeModeApi"
---

<objective>
Create the NativeModeApi class that registers all `qt.*` namespaced JSON-RPC methods, providing the complete Native Mode API surface. This includes reorganizing existing Phase 2 introspection into dotted namespaces, adding convenience methods (inspect, query), name map management, and enhanced system methods.

Purpose: This is the core deliverable of Phase 3 - the polished, agent-friendly API surface that agents will use for all Qt introspection in Native Mode.
Output: NativeModeApi class with ~30 method registrations, wired into Probe initialization.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-native-mode/03-CONTEXT.md
@.planning/phases/03-native-mode/03-RESEARCH.md
@.planning/phases/03-native-mode/03-01-SUMMARY.md

Key existing files:
@src/probe/transport/jsonrpc_handler.h - RegisterMethod(), MethodHandler type
@src/probe/transport/jsonrpc_handler.cpp - Existing qtmcp.* method registrations (keep these!)
@src/probe/core/object_registry.h - findById, findByObjectName, findAllByClassName, objectId
@src/probe/introspection/meta_inspector.h - listProperties, getProperty, setProperty, listMethods, invokeMethod, listSignals, objectInfo
@src/probe/introspection/signal_monitor.h - subscribe, unsubscribe, setLifecycleNotificationsEnabled
@src/probe/interaction/input_simulator.h - mouseClick, sendText, sendKeySequence
@src/probe/interaction/screenshot.h - captureWidget, captureWindow, captureRegion
@src/probe/interaction/hit_test.h - widgetAt, childAt, widgetIdAt, widgetGeometry
@src/probe/core/probe.cpp - Where NativeModeApi must be instantiated
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NativeModeApi class with all qt.* method registrations</name>
  <files>
    src/probe/api/native_mode_api.h
    src/probe/api/native_mode_api.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
**native_mode_api.h** - Class declaration:
```cpp
namespace qtmcp {
class QTMCP_EXPORT NativeModeApi : public QObject {
    Q_OBJECT
public:
    explicit NativeModeApi(JsonRpcHandler* handler, QObject* parent = nullptr);
private:
    void registerObjectMethods();    // qt.objects.*
    void registerPropertyMethods();  // qt.properties.*
    void registerMethodMethods();    // qt.methods.*
    void registerSignalMethods();    // qt.signals.*
    void registerUiMethods();        // qt.ui.*
    void registerNameMapMethods();   // qt.names.*
    void registerSystemMethods();    // qt.ping, qt.version, qt.modes
    JsonRpcHandler* m_handler;
};
}
```

**native_mode_api.cpp** - Register ALL methods below. Every method that takes `objectId` must use `ObjectResolver::resolve()` (not ObjectRegistry directly). Every response must use `ResponseEnvelope::wrap()`. Every error must use ErrorCode constants.

Create shared helpers at the top of the file (not in the header - internal helpers):
- `QObject* resolveObjectParam(const QJsonObject& params, const QString& methodName)` - Extracts `objectId`, calls `ObjectResolver::resolve()`, throws with kObjectNotFound error if null.
- `QWidget* resolveWidgetParam(const QJsonObject& params, const QString& methodName)` - Calls resolveObjectParam, then `qobject_cast<QWidget*>`, throws kObjectNotWidget if null.
- `QJsonObject parseParams(const QString& params)` - QJsonDocument::fromJson -> .object()

**Method Registrations:**

**System (registerSystemMethods):**
- `qt.ping` - Post a `QTimer::singleShot(0, ...)` to measure event loop latency. Since MethodHandler is synchronous and returns immediately, use a simpler approach: record `QDateTime::currentMSecsSinceEpoch()` before and after `QCoreApplication::processEvents()` call. Return `{"pong": true, "timestamp": epoch_ms, "eventLoopLatency": delta_ms}` wrapped in envelope.
- `qt.version` - Return `{"version": "0.1.0", "protocol": "jsonrpc-2.0", "name": "QtMCP", "mode": "native", "deprecated": ["qtmcp.*"]}` wrapped in envelope. Note the deprecated field listing old namespace.
- `qt.modes` - Return `["native", "computer_use", "chrome"]` wrapped in envelope.

**Object Discovery (registerObjectMethods) - NAT-01:**
- `qt.objects.find` - Params: `{name, root?}`. Uses ObjectResolver to resolve optional root. Calls `ObjectRegistry::instance()->findByObjectName(name, rootObj)`. Returns `{objectId, className}`. Assigns numeric ID via ObjectResolver::assignNumericId and includes `numericId` in response. Error kObjectNotFound with hint.
- `qt.objects.findByClass` - Params: `{className, root?}`. Returns `{objects: [{objectId, className, numericId},...]}`.
- `qt.objects.tree` - Params: `{root?, maxDepth?}`. Uses existing `serializeObjectTree()`. Returns the tree wrapped.
- `qt.objects.info` - Params: `{objectId}`. Uses `MetaInspector::objectInfo()`. Returns info wrapped.
- `qt.objects.inspect` - Params: `{objectId}`. NEW convenience method. Calls MetaInspector::objectInfo, listProperties, listMethods, listSignals. Returns `{info, properties, methods, signals}` all in one response wrapped in envelope.
- `qt.objects.query` - Params: `{className?, properties?: {name: value, ...}, root?, maxDepth?}`. NEW rich query. Find all objects matching className (if given), then filter by property values (if given). Return array of matching `{objectId, className, numericId}`. Implementation: use ObjectRegistry::findAllByClassName (or iterate all if no className), then for each check MetaInspector::getProperty matches. Limit to maxDepth in tree if given.

**Properties (registerPropertyMethods) - NAT-02:**
- `qt.properties.list` - Params: `{objectId}`. Returns property list wrapped.
- `qt.properties.get` - Params: `{objectId, name}`. Returns `{value}` wrapped.
- `qt.properties.set` - Params: `{objectId, name, value}`. Returns `{success}` wrapped. Use kPropertyReadOnly/kPropertyTypeMismatch for failures.

**Methods (registerMethodMethods) - NAT-03:**
- `qt.methods.list` - Params: `{objectId}`. Returns method list wrapped.
- `qt.methods.invoke` - Params: `{objectId, method, args?}`. Returns `{result}` wrapped. Use kMethodNotFound/kMethodInvocationFailed for failures.

**Signals (registerSignalMethods) - NAT-05:**
- `qt.signals.list` - Params: `{objectId}`. Returns signal list wrapped.
- `qt.signals.subscribe` - Params: `{objectId, signal}`. Returns `{subscriptionId}` wrapped.
- `qt.signals.unsubscribe` - Params: `{subscriptionId}`. Returns `{success}` wrapped.
- `qt.signals.setLifecycle` - Params: `{enabled}`. Returns `{enabled}` wrapped.

**UI Interaction (registerUiMethods) - NAT-04:**
- `qt.ui.click` - Params: `{objectId, button?, position?}`. Uses resolveWidgetParam. Returns `{success}` wrapped.
- `qt.ui.sendKeys` - Params: `{objectId, text?, sequence?}`. Returns `{success}` wrapped.
- `qt.ui.screenshot` - Params: `{objectId, fullWindow?, region?}`. Returns `{image}` wrapped.
- `qt.ui.geometry` - Params: `{objectId}`. Returns geometry JSON wrapped.
- `qt.ui.hitTest` - Params: `{x, y}`. Uses `HitTest::widgetIdAt()`. Returns `{objectId, className}` wrapped. If no widget at point, return error kObjectNotFound.

**Name Map (registerNameMapMethods):**
- `qt.names.register` - Params: `{name, path}`. Calls SymbolicNameMap::registerName. Returns `{success}`.
- `qt.names.unregister` - Params: `{name}`. Calls SymbolicNameMap::unregisterName. Returns `{success}`.
- `qt.names.list` - No params. Returns SymbolicNameMap::allNames() wrapped.
- `qt.names.validate` - No params. Returns SymbolicNameMap::validateNames() wrapped.
- `qt.names.load` - Params: `{filePath}`. Returns `{success, count}` wrapped. Use kNameMapLoadError on failure.
- `qt.names.save` - Params: `{filePath}`. Returns `{success}` wrapped.

**Important patterns:**
- Every lambda: `[](const QString& params) -> QString { ... }`
- Parse params: `auto p = parseParams(params);`
- Resolve object: `QObject* obj = resolveObjectParam(p, "qt.method.name");`
- Wrap response: `return QString::fromUtf8(QJsonDocument(ResponseEnvelope::wrap(result, objectId)).toJson(QJsonDocument::Compact));`
- Throw structured errors using `std::runtime_error` with the error JSON from `ResponseEnvelope::createError()`. The JsonRpcHandler::HandleMessage catches `std::exception` and returns kInternalError. For STRUCTURED errors, modify the throw pattern: since HandleMessage currently wraps all exceptions as kInternalError, throw with the error code baked into the message, OR better yet, directly return the error JSON from the lambda instead of throwing. The approach: return error JSON strings directly from the lambda (not throwing). The JsonRpcHandler wraps whatever the lambda returns as `result`. But wait -- we need JSON-RPC error format for errors. The simplest approach: create a custom exception class `JsonRpcException` that carries code + message + data, and update HandleMessage to catch it specially and produce structured error responses. Add `JsonRpcException` to `jsonrpc_handler.h`.

Actually, to keep Plan 02 focused and avoid modifying the existing exception handling in jsonrpc_handler.cpp, use a simpler pattern: have each lambda return either success JSON or throw std::runtime_error. In Plan 02, keep the existing error pattern (throw std::runtime_error for hard errors). The structured error responses with ErrorCode integration can use the existing CreateErrorResponse pattern in the handler. For NOW, use throw for errors (the handler catches and returns -32603), but include the specific error info in the exception message string. This is pragmatic -- full structured errors are a refinement.

REVISED approach for errors: Return the error directly as JSON-RPC error format from the lambda. But the handler wraps lambda return values in `{"result": ...}`. So we CANNOT return errors from inside lambdas. We MUST throw.

FINAL approach: Add a `JsonRpcException` class to `jsonrpc_handler.h`:
```cpp
class JsonRpcException : public std::runtime_error {
public:
    JsonRpcException(int code, const QString& message, const QJsonObject& data = {})
        : std::runtime_error(message.toStdString()), m_code(code), m_message(message), m_data(data) {}
    int code() const { return m_code; }
    QString errorMessage() const { return m_message; }
    QJsonObject data() const { return m_data; }
private:
    int m_code;
    QString m_message;
    QJsonObject m_data;
};
```

And update `HandleMessage` in jsonrpc_handler.cpp to catch `JsonRpcException` before `std::exception`:
```cpp
} catch (const JsonRpcException& e) {
    // Structured error with code and data
    QJsonObject errorObj;
    errorObj["code"] = e.code();
    errorObj["message"] = e.errorMessage();
    if (!e.data().isEmpty()) errorObj["data"] = e.data();
    // Build full response manually
    QJsonObject response;
    response["jsonrpc"] = "2.0";
    response["id"] = /* parse id */;
    response["error"] = errorObj;
    return QString::fromUtf8(QJsonDocument(response).toJson(QJsonDocument::Compact));
} catch (const std::exception& e) { ... }
```

This is a small addition to jsonrpc_handler.h/.cpp (add to files_modified).

**CMakeLists.txt** - Add native_mode_api.h/.cpp to PROBE_SOURCES/PROBE_HEADERS.
  </action>
  <verify>
Build succeeds: `cmake --build build/`.
Grep for "qt.objects.find" in native_mode_api.cpp confirms method registered.
Grep for "qt.ping" in native_mode_api.cpp confirms system methods registered.
Grep for "qt.names.register" in native_mode_api.cpp confirms name map methods registered.
Count RegisterMethod calls in native_mode_api.cpp should be ~28-30.
  </verify>
  <done>
All qt.* namespaced methods are registered via NativeModeApi. Every method uses ObjectResolver for ID resolution, ResponseEnvelope for response wrapping, and ErrorCode constants for errors. Old qtmcp.* methods remain untouched for backward compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire NativeModeApi into Probe initialization</name>
  <files>
    src/probe/core/probe.cpp
    src/probe/transport/jsonrpc_handler.h
    src/probe/transport/jsonrpc_handler.cpp
  </files>
  <action>
**probe.cpp** - In the Probe::initialize() method (or wherever the JsonRpcHandler is created):
1. `#include "api/native_mode_api.h"`
2. After the JsonRpcHandler is created and the WebSocketServer is set up, instantiate NativeModeApi:
   ```cpp
   auto* nativeApi = new NativeModeApi(handler, this);
   Q_UNUSED(nativeApi);
   ```
   NativeModeApi registers its methods in its constructor, so no further calls needed.
3. Also wire the SymbolicNameMap auto-load: `#include "api/symbolic_name_map.h"` and after NativeModeApi creation:
   ```cpp
   // Auto-load symbolic name map
   QString nameMapPath = qEnvironmentVariable("QTMCP_NAME_MAP");
   if (nameMapPath.isEmpty()) {
       nameMapPath = QDir::currentPath() + "/qtmcp-names.json";
   }
   if (QFile::exists(nameMapPath)) {
       SymbolicNameMap::instance()->loadFromFile(nameMapPath);
   }
   ```
4. Wire ObjectResolver::clearNumericIds() to client disconnect: connect WebSocketServer's clientDisconnected signal (if it exists) to a lambda that calls `ObjectResolver::clearNumericIds()`. If no such signal exists, add a note that numeric IDs persist across reconnections (acceptable for MVP).

**jsonrpc_handler.h** - Add `JsonRpcException` class (as described in Task 1 action). Place it in the `qtmcp` namespace, after the JsonRpcHandler class definition.

**jsonrpc_handler.cpp** - Update the HandleMessage method's try/catch block to catch `JsonRpcException` before `std::exception`. The JsonRpcException catch block should produce a structured error response with the error code, message, and optional data field. Use the existing CreateErrorResponse method signature or build the response inline if data field is needed (CreateErrorResponse doesn't currently support data).

To support the data field, add a new overload:
```cpp
QString CreateErrorResponse(const QString& id, int code, const QString& message, const QJsonObject& data);
```
This creates: `{"jsonrpc":"2.0","id":N,"error":{"code":N,"message":"...","data":{...}}}`.
  </action>
  <verify>
Build succeeds: `cmake --build build/`.
Existing tests still pass: `ctest --test-dir build/`.
In probe.cpp, NativeModeApi is instantiated.
In jsonrpc_handler.cpp, JsonRpcException is caught before std::exception.
  </verify>
  <done>
NativeModeApi is instantiated during Probe initialization, registering all qt.* methods. JsonRpcException enables structured error responses with codes and data. SymbolicNameMap auto-loads from env var or default file. Numeric IDs cleared on disconnect if signal available.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build/` succeeds with no errors or warnings
2. All qt.* methods are registered (grep for RegisterMethod.*"qt\. in native_mode_api.cpp)
3. Old qtmcp.* methods still present in jsonrpc_handler.cpp (backward compatibility)
4. Existing tests pass: `ctest --test-dir build/`
5. NativeModeApi is instantiated in probe.cpp
6. JsonRpcException class exists in jsonrpc_handler.h
</verification>

<success_criteria>
- NativeModeApi registers ~28-30 methods across 7 domains (objects, properties, methods, signals, ui, names, system)
- All methods use ObjectResolver for ID resolution, ResponseEnvelope for wrapping, ErrorCode for errors
- JsonRpcException enables structured error responses with code + message + data
- Probe initialization creates NativeModeApi and auto-loads name map
- Old qtmcp.* methods untouched for backward compatibility
- Project builds and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-native-mode/03-02-SUMMARY.md`
</output>
