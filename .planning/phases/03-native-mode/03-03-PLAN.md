---
phase: 03-native-mode
plan: 03
type: tdd
wave: 3
depends_on: ["03-02"]
files_modified:
  - tests/test_native_mode_api.cpp
  - tests/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "qt.objects.find resolves an object by objectName and returns objectId + className + numericId"
    - "qt.objects.findByClass returns all objects of a given class"
    - "qt.objects.tree returns the object tree with depth limiting"
    - "qt.objects.inspect returns properties + methods + signals in one call"
    - "qt.objects.query filters by className and property values"
    - "qt.properties.get/set read and write properties through the new API"
    - "qt.methods.invoke calls a method through the new API"
    - "qt.signals.subscribe/unsubscribe work through the new API"
    - "qt.ui.click/sendKeys/screenshot/geometry work through the new API"
    - "qt.names.register/list/validate manage symbolic names"
    - "qt.ping returns pong with timestamp and latency"
    - "qt.version returns version info including deprecated notice"
    - "ObjectResolver resolves all three ID styles (numeric, symbolic, hierarchical)"
    - "ResponseEnvelope wraps all responses in {result, meta} structure"
    - "Structured errors include error code and data with schema hints"
  artifacts:
    - path: "tests/test_native_mode_api.cpp"
      provides: "Integration tests for complete Native Mode API"
      min_lines: 200
  key_links:
    - from: "tests/test_native_mode_api.cpp"
      to: "src/probe/api/native_mode_api.h"
      via: "NativeModeApi instantiation in test setup"
      pattern: "NativeModeApi"
    - from: "tests/test_native_mode_api.cpp"
      to: "src/probe/transport/jsonrpc_handler.h"
      via: "HandleMessage calls for each test"
      pattern: "HandleMessage"
---

<objective>
Create comprehensive integration tests for the complete Native Mode API, verifying all qt.* methods work end-to-end through the JSON-RPC handler. Tests cover object discovery, inspection, mutation, interaction, signal monitoring, name map management, and system methods.

Purpose: Prove that the entire Native Mode API surface works correctly, catching any wiring issues between NativeModeApi, ObjectResolver, ResponseEnvelope, and the underlying Phase 2 introspection classes.
Output: test_native_mode_api.cpp with 20+ test cases covering all API domains.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-native-mode/03-CONTEXT.md
@.planning/phases/03-native-mode/03-RESEARCH.md
@.planning/phases/03-native-mode/03-01-SUMMARY.md
@.planning/phases/03-native-mode/03-02-SUMMARY.md

Key existing test patterns:
@tests/test_jsonrpc_introspection.cpp - Integration test pattern for JSON-RPC methods
@tests/CMakeLists.txt - Test target registration pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Native Mode API integration tests</name>
  <files>
    tests/test_native_mode_api.cpp
    tests/CMakeLists.txt
  </files>
  <action>
Create `tests/test_native_mode_api.cpp` using the QTest framework. Follow the same pattern as `test_jsonrpc_introspection.cpp`:
- Create a QTest class `TestNativeModeApi`
- In `initTestCase()`: create a JsonRpcHandler, instantiate NativeModeApi on it, create test QObjects (a QWidget tree with named objects for testing)
- Helper: `QJsonObject call(const QString& method, const QJsonObject& params)` - builds JSON-RPC request, calls HandleMessage, parses response, returns the result field. Also helper `QJsonObject callExpectError(...)` that returns the error field.

**Test cases by domain:**

**Response Envelope Tests:**
- `testResponseEnvelope` - Call qt.ping, verify response has `result` and `meta` fields. Verify `meta` contains `timestamp` as integer.

**System Tests:**
- `testPing` - Call `qt.ping`. Verify result contains `pong: true`, `timestamp` > 0, and `eventLoopLatency` >= 0.
- `testVersion` - Call `qt.version`. Verify result contains `version`, `protocol`, `name`, `mode: "native"`, and `deprecated` array containing `"qtmcp.*"`.
- `testModes` - Call `qt.modes`. Verify result is array containing "native", "computer_use", "chrome".

**Object Discovery Tests (NAT-01):**
- `testObjectsFind` - Create a QPushButton with objectName "testBtn". Call `qt.objects.find` with `{name: "testBtn"}`. Verify response contains `objectId` (non-empty string), `className` containing "QPushButton", and `numericId` (positive integer).
- `testObjectsFindNotFound` - Call `qt.objects.find` with `{name: "nonexistent"}`. Verify error response with code kObjectNotFound.
- `testObjectsFindByClass` - Call `qt.objects.findByClass` with `{className: "QPushButton"}`. Verify `objects` array is non-empty and each entry has `objectId` and `className`.
- `testObjectsTree` - Call `qt.objects.tree` with `{maxDepth: 2}`. Verify result is a JSON object with tree structure (has `children` or similar).
- `testObjectsInfo` - Get an objectId from find, then call `qt.objects.info` with it. Verify result contains `className`.
- `testObjectsInspect` - Get objectId, call `qt.objects.inspect`. Verify result contains `info`, `properties`, `methods`, `signals` fields.
- `testObjectsQuery` - Create test widgets. Call `qt.objects.query` with `{className: "QPushButton"}`. Verify results match. Also test with property filter: `{className: "QPushButton", properties: {enabled: true}}`.

**Property Tests (NAT-02):**
- `testPropertiesList` - Get objectId, call `qt.properties.list`. Verify array of property descriptors.
- `testPropertiesGetSet` - Create QPushButton, get objectId. Call `qt.properties.get` for "text". Call `qt.properties.set` to change "text". Call get again to verify change.

**Method Tests (NAT-03):**
- `testMethodsList` - Get objectId, call `qt.methods.list`. Verify array contains methods.
- `testMethodsInvoke` - Create a QPushButton, call `qt.methods.invoke` with method "setEnabled" and args [false]. Verify the widget is now disabled.

**Signal Tests (NAT-05):**
- `testSignalsList` - Get objectId, call `qt.signals.list`. Verify array contains signal entries.
- `testSignalsSubscribeUnsubscribe` - Call `qt.signals.subscribe`. Verify `subscriptionId` returned. Call `qt.signals.unsubscribe` with that ID. Verify success.

**UI Tests (NAT-04):**
- `testUiGeometry` - Get objectId of visible widget, call `qt.ui.geometry`. Verify result contains x, y, width, height fields.
- `testUiScreenshot` - Get objectId of visible widget, call `qt.ui.screenshot`. Verify result contains `image` field (non-empty base64 string).

**Name Map Tests:**
- `testNamesRegisterAndList` - Call `qt.names.register` with `{name: "myBtn", path: "some/path"}`. Call `qt.names.list`. Verify "myBtn" appears in the list.
- `testNamesUnregister` - Register a name, then call `qt.names.unregister`. Call `qt.names.list` and verify it's gone.
- `testNamesValidate` - Register a name pointing to a valid objectId. Call `qt.names.validate`. Verify the entry shows valid: true or false depending on whether the path resolves.

**ObjectResolver Tests:**
- `testNumericIdResolution` - Find an object (gets assigned numericId N). Call `qt.objects.info` with objectId `"#N"`. Verify it resolves to the same object.
- `testSymbolicNameResolution` - Register symbolic name "btn" -> the hierarchical path of a test button. Call `qt.objects.info` with objectId `"btn"`. Verify it resolves correctly.

**Error Handling Tests:**
- `testStructuredError` - Call `qt.properties.get` with missing objectId. Verify error has code -32602 (or appropriate code) and includes schema hint in data field.

**CMakeLists.txt** - Add test_native_mode_api target following the pattern of test_jsonrpc_introspection:
```cmake
add_executable(test_native_mode_api test_native_mode_api.cpp)
target_link_libraries(test_native_mode_api PRIVATE qtmcp_probe Qt${QT_VERSION_MAJOR}::Test)
add_test(NAME test_native_mode_api COMMAND test_native_mode_api)
set_tests_properties(test_native_mode_api PROPERTIES ENVIRONMENT "QTMCP_ENABLED=0")
```

Total: ~25 test cases. Set QTMCP_ENABLED=0 to prevent auto-initialization (tests create their own NativeModeApi).
  </action>
  <verify>
Build succeeds: `cmake --build build/`.
Tests pass: run `ctest --test-dir build/ -R test_native_mode_api -V` (verbose to see individual test results).
Verify test count >= 20 test functions.
All existing tests still pass: `ctest --test-dir build/`.
  </verify>
  <done>
Integration test suite with 20+ test cases verifies the complete Native Mode API surface. All domains tested: system, objects, properties, methods, signals, ui, names. ObjectResolver multi-style resolution tested. ResponseEnvelope format verified. Structured errors verified. All tests pass.
  </done>
</task>

</tasks>

<feature>
  <name>Native Mode API Integration Tests</name>
  <files>tests/test_native_mode_api.cpp, tests/CMakeLists.txt</files>
  <behavior>
    All qt.* JSON-RPC methods produce correct responses when called through the handler:
    - qt.ping -> {pong: true, timestamp: N, eventLoopLatency: N}
    - qt.objects.find({name: "X"}) -> {objectId: "...", className: "...", numericId: N}
    - qt.objects.inspect({objectId: "X"}) -> {info: ..., properties: [...], methods: [...], signals: [...]}
    - qt.properties.get({objectId: "X", name: "text"}) -> {value: "..."}
    - qt.names.register({name: "X", path: "Y"}) -> {success: true}
    - All responses wrapped in {result: ..., meta: {timestamp: N}}
    - Errors include structured code + message + data
  </behavior>
  <implementation>QTest framework with JsonRpcHandler + NativeModeApi instantiated in test setup</implementation>
</feature>

<verification>
1. `cmake --build build/` succeeds
2. `ctest --test-dir build/ -R test_native_mode_api` passes all tests
3. All existing tests still pass: `ctest --test-dir build/`
4. Test file contains >= 20 test functions
5. Tests cover all 7 API domains (system, objects, properties, methods, signals, ui, names)
</verification>

<success_criteria>
- 20+ integration tests covering the complete Native Mode API
- All tests pass on first run (after Plan 02 is implemented correctly)
- Tests verify ResponseEnvelope format ({result, meta}) on all responses
- Tests verify ObjectResolver handles numeric (#N), symbolic, and hierarchical IDs
- Tests verify structured error responses with error codes and data
- Existing test suites (test_jsonrpc, test_object_registry, etc.) still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-native-mode/03-03-SUMMARY.md`
</output>
