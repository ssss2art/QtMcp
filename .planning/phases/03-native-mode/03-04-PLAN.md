---
phase: 03-native-mode
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/probe/introspection/object_id.cpp
  - tests/test_object_id.cpp
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Symbolic names resolve when used as objectId in any qt.* method"
    - "Hierarchical path IDs generated by qt.objects.tree can be passed to qt.objects.info and resolved"
    - "findByObjectId with no explicit root resolves IDs that start with the QApplication segment"
  artifacts:
    - path: "src/probe/introspection/object_id.cpp"
      provides: "Fixed getTopLevelObjects includes QCoreApplication::instance()"
      contains: "result.append(app)"
    - path: "tests/test_object_id.cpp"
      provides: "Test proving global findByObjectId resolves full hierarchical paths"
      contains: "testFindByIdGlobal"
  key_links:
    - from: "generateObjectId"
      to: "findByObjectId"
      via: "getTopLevelObjects must include the root that generateObjectId walks up to"
      pattern: "result\\.append\\(app\\)"
---

<objective>
Fix getTopLevelObjects() so that findByObjectId() can resolve IDs generated by generateObjectId().

Purpose: generateObjectId() walks the parent chain all the way up to QCoreApplication, producing IDs like "QApplication/mainWindow/centralWidget/button". But findByObjectId() calls getTopLevelObjects() which only returns app->children() (e.g., mainWindow), NOT the app itself. The first segment "QApplication" never matches any candidate, so ALL global lookups by hierarchical path fail. This breaks symbolic name resolution and any qt.* method that uses ObjectResolver's tree-walk fallback.

Output: Patched object_id.cpp and a regression test proving global ID resolution works.
</objective>

<execution_context>
@E:\AI-files\QtMcp\.claude\get-shit-done\workflows\execute-plan.md
@E:\AI-files\QtMcp\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@E:\AI-files\QtMcp\.planning\PROJECT.md
@E:\AI-files\QtMcp\.planning\ROADMAP.md
@E:\AI-files\QtMcp\.planning\STATE.md
@E:\AI-files\QtMcp\src\probe\introspection\object_id.cpp
@E:\AI-files\QtMcp\src\probe\introspection\object_id.h
@E:\AI-files\QtMcp\tests\test_object_id.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix getTopLevelObjects to include QCoreApplication</name>
  <files>src/probe/introspection/object_id.cpp</files>
  <action>
In the anonymous namespace function `getTopLevelObjects()` (around line 106), change it to include `QCoreApplication::instance()` itself as a search root, not just its children.

Current code (BROKEN):
```cpp
QList<QObject*> getTopLevelObjects() {
    QList<QObject*> result;
    QCoreApplication* app = QCoreApplication::instance();
    if (app) {
        result.append(app->children());
    }
    return result;
}
```

Fixed code:
```cpp
QList<QObject*> getTopLevelObjects() {
    QList<QObject*> result;
    QCoreApplication* app = QCoreApplication::instance();
    if (app) {
        // Include the application object itself as a search root.
        // generateObjectId() walks up to QCoreApplication, so IDs start
        // with the app's segment (e.g., "QApplication/..."). The search
        // must begin from the app to match that first segment.
        result.append(app);
    }
    return result;
}
```

ALSO fix `serializeObjectTree()` (around line 316) which calls `getTopLevelObjects()` when root is nullptr. After the fix, the tree will now show QApplication as the root with its children nested inside, which is the correct representation matching the IDs generated by `generateObjectId()`. No change needed to serializeObjectTree itself - it already iterates `getTopLevelObjects()` correctly. The tree output will just be more accurate now.

This is a ONE-LINE change: `result.append(app->children())` becomes `result.append(app)`.
  </action>
  <verify>
Build the project:
```
cmake --build E:/AI-files/QtMcp/build --config Debug 2>&1
```
Build must succeed with no errors.
  </verify>
  <done>getTopLevelObjects() returns QCoreApplication::instance() as a search root, enabling findByObjectId to match the first segment of any hierarchical ID.</done>
</task>

<task type="auto">
  <name>Task 2: Add regression test for global findByObjectId</name>
  <files>tests/test_object_id.cpp</files>
  <action>
Add a new test `testFindByIdGlobal` to the TestObjectId class that proves findByObjectId works WITHOUT an explicit root parameter (i.e., uses getTopLevelObjects).

The existing `testFindById` always passes an explicit root, which bypasses getTopLevelObjects entirely. The new test must:

1. Create a widget hierarchy with named objects (parent with objectName, child QPushButton with objectName)
2. Set the parent widget as a child of QCoreApplication (parent it to nullptr so it becomes a top-level widget - QWidget without parent becomes a top-level window, and its QObject parent is still null, but it will be a child of the app in the Qt object tree... actually, top-level QWidgets are NOT children of QApplication. So instead: create a QObject child of QCoreApplication::instance() explicitly, then create children under that.)

Actually, the simplest approach: Create a QObject parented to `QCoreApplication::instance()`. This makes it a child of the app, so getTopLevelObjects() (after fix) will include the app, and findBySegments will find the app, then search its children.

```cpp
void TestObjectId::testFindByIdGlobal() {
    // Create an object parented to the application (makes it a top-level object)
    QObject* topLevel = new QObject(QCoreApplication::instance());
    topLevel->setObjectName(QStringLiteral("globalTestRoot"));

    QObject* child = new QObject(topLevel);
    child->setObjectName(QStringLiteral("globalTestChild"));

    QCoreApplication::processEvents();

    // Generate the full hierarchical ID
    QString childId = generateObjectId(child);
    qDebug() << "Global child ID:" << childId;

    // The ID should contain the application class name as the first segment
    QStringList segments = childId.split(QLatin1Char('/'));
    QVERIFY(segments.size() >= 3);  // App/globalTestRoot/globalTestChild

    // Critical test: findByObjectId with NO root must resolve the full path
    QObject* found = findByObjectId(childId);
    QVERIFY2(found != nullptr, qPrintable(QStringLiteral("findByObjectId failed for global ID: ") + childId));
    QCOMPARE(found, child);

    // Also verify finding the top-level object itself
    QString topLevelId = generateObjectId(topLevel);
    QObject* foundTopLevel = findByObjectId(topLevelId);
    QVERIFY2(foundTopLevel != nullptr, qPrintable(QStringLiteral("findByObjectId failed for top-level ID: ") + topLevelId));
    QCOMPARE(foundTopLevel, topLevel);

    // Clean up
    delete topLevel;
}
```

Add `testFindByIdGlobal` to the private slots declaration in the TestObjectId class (after `testFindById`).
  </action>
  <verify>
Build and run the test:
```
cmake --build E:/AI-files/QtMcp/build --config Debug --target test_object_id 2>&1
```
Then run:
```
cd E:/AI-files/QtMcp/build && ctest -C Debug -R test_object_id --output-on-failure 2>&1
```
All tests must pass, including the new testFindByIdGlobal.
  </verify>
  <done>New test testFindByIdGlobal passes, proving that findByObjectId resolves full hierarchical IDs without an explicit root. All existing tests also pass (no regressions).</done>
</task>

</tasks>

<verification>
1. `cmake --build E:/AI-files/QtMcp/build --config Debug` succeeds
2. `ctest -C Debug --test-dir E:/AI-files/QtMcp/build -R test_object_id --output-on-failure` passes all tests including the new one
3. `ctest -C Debug --test-dir E:/AI-files/QtMcp/build --output-on-failure` passes ALL test suites (no regressions across 8 suites)
</verification>

<success_criteria>
- getTopLevelObjects() includes QCoreApplication::instance() as a search root
- findByObjectId("QApplication/someChild/deepChild") resolves correctly without explicit root
- All 8 existing test suites still pass
- New testFindByIdGlobal test passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-native-mode/03-04-SUMMARY.md`
</output>
