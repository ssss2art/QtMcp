---
phase: 04-computer-use-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/probe/interaction/key_name_mapper.h
  - src/probe/interaction/key_name_mapper.cpp
  - src/probe/interaction/input_simulator.h
  - src/probe/interaction/input_simulator.cpp
  - src/probe/interaction/screenshot.h
  - src/probe/interaction/screenshot.cpp
autonomous: true

must_haves:
  truths:
    - "Chrome/xdotool key names resolve to correct Qt::Key enums"
    - "Modifier combo strings like 'ctrl+shift+s' parse into Qt::Key + Qt::KeyboardModifiers"
    - "Mouse press, release, move operations can be performed independently"
    - "Scroll simulation sends QWheelEvent with correct angleDelta"
    - "Drag simulation sends press-move-release QMouseEvent sequence"
    - "Full-screen screenshot capture returns base64 PNG"
  artifacts:
    - path: "src/probe/interaction/key_name_mapper.h"
      provides: "Chrome key name to Qt::Key translation"
      exports: ["KeyNameMapper"]
    - path: "src/probe/interaction/key_name_mapper.cpp"
      provides: "Key mapping table and combo parser"
      min_lines: 80
    - path: "src/probe/interaction/input_simulator.h"
      provides: "Extended mouse primitives"
      contains: "mousePress"
    - path: "src/probe/interaction/input_simulator.cpp"
      provides: "scroll, mouseDrag, mousePress, mouseRelease, mouseMove implementations"
    - path: "src/probe/interaction/screenshot.h"
      provides: "Full-screen capture method"
      contains: "captureScreen"
  key_links:
    - from: "key_name_mapper.cpp"
      to: "Qt::Key enum"
      via: "static lookup table"
      pattern: "KEY_MAP.*Qt::Key"
    - from: "input_simulator.cpp"
      to: "QWheelEvent"
      via: "manual event construction"
      pattern: "QWheelEvent"
    - from: "input_simulator.cpp"
      to: "QMouseEvent"
      via: "manual event construction for drag"
      pattern: "QMouseEvent"
---

<objective>
Create the interaction-layer primitives needed by Computer Use Mode: a key name mapper for Chrome-to-Qt key translation, extended mouse operations (press/release/move/scroll/drag) on InputSimulator, and full-screen screenshot on Screenshot.

Purpose: These are the low-level building blocks that ComputerUseModeApi (Plan 02) will call. Separating them keeps Plan 02 focused on API registration only.
Output: Three files created (key_name_mapper.h/.cpp), two files extended (input_simulator.h/.cpp, screenshot.h/.cpp).
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-computer-use-mode/04-RESEARCH.md
@.planning/phases/04-computer-use-mode/04-CONTEXT.md
@src/probe/interaction/input_simulator.h
@src/probe/interaction/input_simulator.cpp
@src/probe/interaction/screenshot.h
@src/probe/interaction/screenshot.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KeyNameMapper utility class</name>
  <files>src/probe/interaction/key_name_mapper.h, src/probe/interaction/key_name_mapper.cpp</files>
  <action>
Create `KeyNameMapper` in the `qtmcp` namespace with these capabilities:

1. **Static lookup table** mapping Chrome/xdotool key names to Qt::Key. Use the full table from 04-RESEARCH.md (navigation, arrows, page nav, function keys, modifiers, misc). Include both Chrome and xdotool aliases (e.g., "Enter" AND "Return" both map to Qt::Key_Return, "ArrowUp" AND "Up" both map to Qt::Key_Up). Case-insensitive lookup.

2. **Modifier name mapping** - map "ctrl"/"control"/"Control_L" to Qt::ControlModifier, "shift"/"Shift_L" to Qt::ShiftModifier, "alt"/"Alt_L" to Qt::AltModifier, "super"/"meta"/"Super_L" to Qt::MetaModifier. Case-insensitive.

3. **`parseKeyCombo(const QString& combo)` method** - Parse strings like "ctrl+shift+s", "ctrl+c", "Return", "F5" into a struct `KeyCombo { Qt::Key key; Qt::KeyboardModifiers modifiers; }`. Split on "+", last token is the key, preceding tokens are modifiers. Single-character keys (a-z, 0-9) map directly to their Qt::Key equivalent. For single chars, use `QKeySequence(combo)[0]` only as fallback, NOT as primary - the explicit table should be checked first.

4. **`resolve(const QString& name)` method** - Look up a single key name and return Qt::Key. Return Qt::Key_unknown if not found. Case-insensitive using a QHash with toLower() keys.

Use `QHash<QString, Qt::Key>` for O(1) lookup. Initialize the hash once (static local or similar pattern). Follow existing code style (MIT header, `#pragma once`, namespace qtmcp, QTMCP_EXPORT not needed since these are internal static methods).
  </action>
  <verify>
Build succeeds: `cmake --build build/ --target qtmcp_probe` (after CMake update in Plan 02 - for now verify header compiles by checking includes are correct).
Manually verify the key map covers: Return/Enter, Tab, Escape/Esc, BackSpace/Backspace, Delete, Space/space, all 4 arrow keys with Arrow prefix, PageUp/Page_Up, PageDown/Page_Down, Home, End, Insert, F1-F12, Shift/Control/Alt/Super/Meta and their _L variants, Print, Scroll_Lock, Pause, Caps_Lock, Num_Lock, Menu.
  </verify>
  <done>
KeyNameMapper::resolve("Enter") returns Qt::Key_Return.
KeyNameMapper::resolve("ArrowUp") returns Qt::Key_Up.
KeyNameMapper::parseKeyCombo("ctrl+shift+s") returns {Qt::Key_S, Qt::ControlModifier | Qt::ShiftModifier}.
KeyNameMapper::parseKeyCombo("F5") returns {Qt::Key_F5, Qt::NoModifier}.
Single char "a" resolves to Qt::Key_A.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend InputSimulator with mouse press/release/move, scroll, and drag</name>
  <files>src/probe/interaction/input_simulator.h, src/probe/interaction/input_simulator.cpp</files>
  <action>
Add the following static methods to InputSimulator (keep all existing methods untouched):

1. **`mousePress(QWidget* widget, MouseButton button, const QPoint& pos, Qt::KeyboardModifiers modifiers)`**
   - Construct QMouseEvent(QEvent::MouseButtonPress, ...) and send via QCoreApplication::sendEvent().
   - `pos` is widget-local. If pos is null/default QPoint(), use widget center.
   - Call QApplication::processEvents() after sending.

2. **`mouseRelease(QWidget* widget, MouseButton button, const QPoint& pos, Qt::KeyboardModifiers modifiers)`**
   - Same pattern as mousePress but QEvent::MouseButtonRelease.
   - The `buttons` parameter in QMouseEvent should be Qt::NoButton (no buttons held after release).

3. **`mouseMove(QWidget* widget, const QPoint& pos, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers)`**
   - Construct QMouseEvent(QEvent::MouseMove, ...) and send.
   - `buttons` indicates which buttons are held during move (for drag).
   - Call processEvents() after.

4. **`scroll(QWidget* widget, const QPoint& pos, int dx, int dy, Qt::KeyboardModifiers modifiers)`**
   - Construct QWheelEvent manually (QTest has NO wheel simulation - QTBUG-71449).
   - angleDelta: QPoint(dx * 120, dy * 120) where 120 = one standard tick.
   - pixelDelta: QPoint(0, 0).
   - phase: Qt::NoScrollPhase, not inverted.
   - globalPos from widget->mapToGlobal(localPos).
   - Send via QCoreApplication::sendEvent(), then processEvents().

5. **`mouseDrag(QWidget* window, const QPoint& startPos, const QPoint& endPos, MouseButton button, Qt::KeyboardModifiers modifiers)`**
   - Do NOT use QTest for drag (unreliable per research).
   - Manually construct QMouseEvent sequence: Press at start -> Move to end -> Release at end.
   - For start: find child widget via window->childAt(startPos), convert to local coords via mapFrom.
   - For end: find child widget via window->childAt(endPos), convert to local coords.
   - Call QApplication::processEvents() between each event.

For all QMouseEvent constructors, use the overload: `QMouseEvent(type, localPos, globalPos, button, buttons, modifiers)`. Include `<QApplication>` for processEvents and `<QMouseEvent>` / `<QWheelEvent>` headers.

Do NOT use `QPointF` constructor overload - use the one that takes `QPointF localPos, QPointF globalPos` (the 6-arg version for Qt6).
  </action>
  <verify>
Build succeeds after CMake update (Plan 02). All existing tests still pass (no changes to existing methods). New methods are declared in header and implemented in cpp.
  </verify>
  <done>
InputSimulator has 5 new static methods: mousePress, mouseRelease, mouseMove, scroll, mouseDrag. Existing mouseClick, mouseDoubleClick, sendText, sendKeySequence, sendKey methods unchanged. Implementation uses manual QMouseEvent/QWheelEvent construction (not QTest) for the new methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend Screenshot with full-screen capture and logical-pixel scaling</name>
  <files>src/probe/interaction/screenshot.h, src/probe/interaction/screenshot.cpp</files>
  <action>
Add two new static methods to Screenshot (keep all existing methods untouched):

1. **`captureScreen(QWidget* windowOnTargetScreen)`**
   - Get the QScreen from the widget: `widget->screen()`.
   - Capture entire screen: `screen->grabWindow(0)` (0 = entire screen/desktop).
   - Encode to base64 PNG and return QByteArray.
   - If widget is null or screen is null, throw std::invalid_argument.

2. **`captureWindowLogical(QWidget* window)`**
   - Capture the window using existing captureWindow() logic.
   - Check devicePixelRatio: if > 1.0, scale the QPixmap down to logical size using `pixmap.scaled(pixmap.width() / dpr, pixmap.height() / dpr, Qt::IgnoreAspectRatio, Qt::SmoothTransformation)`.
   - This ensures coordinates in the screenshot match logical pixel coordinates 1:1 (per CONTEXT.md decision).
   - Encode scaled pixmap to base64 PNG.

Include `<QScreen>` header. The existing captureWidget/captureWindow/captureRegion methods must remain unchanged.
  </action>
  <verify>
Build succeeds after CMake update. Existing screenshot tests still pass. New methods declared in header and implemented in cpp.
  </verify>
  <done>
Screenshot::captureScreen() captures entire screen as base64 PNG. Screenshot::captureWindowLogical() returns a logical-pixel-scaled screenshot where coordinates match 1:1 regardless of HiDPI. Both methods properly handle null inputs.
  </done>
</task>

</tasks>

<verification>
- All three source files compile without errors (verified after Plan 02 CMake update)
- No changes to existing method signatures (backward compatible)
- KeyNameMapper covers all Chrome/xdotool key names from research
- InputSimulator::scroll uses QWheelEvent (not QTest)
- InputSimulator::mouseDrag uses QMouseEvent sequence (not QTest)
- Screenshot::captureWindowLogical scales by devicePixelRatio
</verification>

<success_criteria>
- key_name_mapper.h/.cpp exist with resolve() and parseKeyCombo() methods
- InputSimulator has mousePress, mouseRelease, mouseMove, scroll, mouseDrag
- Screenshot has captureScreen and captureWindowLogical
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/04-computer-use-mode/04-01-SUMMARY.md`
</output>
