---
phase: 04-computer-use-mode
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/probe/api/computer_use_mode_api.h
  - src/probe/api/computer_use_mode_api.cpp
  - src/probe/api/error_codes.h
  - src/probe/core/probe.cpp
  - src/probe/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Agent can call cu.screenshot and receive base64 PNG with width/height"
    - "Agent can call cu.click with x,y coordinates and the click lands on correct widget"
    - "Agent can call cu.rightClick, cu.middleClick, cu.doubleClick at coordinates"
    - "Agent can call cu.mouseMove to reposition cursor"
    - "Agent can call cu.drag with start and end coordinates"
    - "Agent can call cu.mouseDown and cu.mouseUp for fine-grained control"
    - "Agent can call cu.type to enter text at focused widget"
    - "Agent can call cu.key with Chrome key combo strings"
    - "Agent can call cu.scroll with direction and ticks"
    - "Agent can call cu.cursorPosition and get x,y plus widget info"
    - "Out-of-bounds coordinates return structured error"
    - "No active window returns clear error"
  artifacts:
    - path: "src/probe/api/computer_use_mode_api.h"
      provides: "ComputerUseModeApi class declaration"
      exports: ["ComputerUseModeApi"]
    - path: "src/probe/api/computer_use_mode_api.cpp"
      provides: "All 13 cu.* method handlers"
      min_lines: 300
    - path: "src/probe/api/error_codes.h"
      provides: "CU-specific error codes"
      contains: "kCoordinateOutOfBounds"
    - path: "src/probe/core/probe.cpp"
      provides: "ComputerUseModeApi wiring"
      contains: "ComputerUseModeApi"
  key_links:
    - from: "computer_use_mode_api.cpp"
      to: "InputSimulator"
      via: "static method calls"
      pattern: "InputSimulator::(mouseClick|mousePress|mouseRelease|mouseMove|scroll|mouseDrag)"
    - from: "computer_use_mode_api.cpp"
      to: "Screenshot"
      via: "static method calls"
      pattern: "Screenshot::(captureWindowLogical|captureScreen|captureRegion)"
    - from: "computer_use_mode_api.cpp"
      to: "KeyNameMapper"
      via: "key combo parsing"
      pattern: "KeyNameMapper::parseKeyCombo"
    - from: "computer_use_mode_api.cpp"
      to: "JsonRpcHandler"
      via: "RegisterMethod"
      pattern: "m_handler->RegisterMethod.*cu\\."
    - from: "probe.cpp"
      to: "ComputerUseModeApi"
      via: "constructor in initialize()"
      pattern: "new ComputerUseModeApi"
---

<objective>
Create ComputerUseModeApi class registering all 13 cu.* JSON-RPC methods, add CU error codes, update CMake to include new files, and wire the API into Probe::initialize().

Purpose: This is the core deliverable of Phase 4 - the Chrome-compatible computer use API surface.
Output: ComputerUseModeApi registered on JsonRpcHandler, accessible to agents via cu.* methods.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-computer-use-mode/04-RESEARCH.md
@.planning/phases/04-computer-use-mode/04-CONTEXT.md
@.planning/phases/04-computer-use-mode/04-01-SUMMARY.md
@src/probe/api/native_mode_api.h
@src/probe/api/native_mode_api.cpp
@src/probe/core/probe.cpp
@src/probe/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ComputerUseModeApi with all 13 cu.* methods</name>
  <files>src/probe/api/computer_use_mode_api.h, src/probe/api/computer_use_mode_api.cpp, src/probe/api/error_codes.h</files>
  <action>
**Follow NativeModeApi pattern exactly** (same structure, same helper functions, same envelope wrapping).

**Header (computer_use_mode_api.h):**
```
class QTMCP_EXPORT ComputerUseModeApi : public QObject {
    Q_OBJECT
public:
    explicit ComputerUseModeApi(JsonRpcHandler* handler, QObject* parent = nullptr);
private:
    void registerScreenshotMethods();
    void registerMouseMethods();
    void registerKeyboardMethods();
    void registerScrollMethod();
    void registerQueryMethods();
    JsonRpcHandler* m_handler;
};
```

**Implementation (computer_use_mode_api.cpp):**

Add internal helpers (anonymous namespace, same pattern as native_mode_api.cpp):
- `parseParams()` and `envelopeToString()` (same as NativeModeApi)
- `getActiveWindow()` - returns QApplication::activeWindow(), falls back to first visible widget in QApplication::topLevelWidgets(). Throws JsonRpcException(ErrorCode::kNoActiveWindow, "No active Qt window found") if none.
- `resolveWindowCoordinate(QWidget* window, int x, int y, bool screenAbsolute)` - if screenAbsolute, use QApplication::widgetAt(QPoint(x,y)) to find target widget and convert to local coords. If window-relative (default), bounds-check against window size (strict: throw kCoordinateOutOfBounds if OOB), then window->childAt(QPoint(x,y)) to find deepest child, mapFrom to get local coords. Returns struct `ResolvedTarget { QWidget* widget; QPoint localPos; }`.

**Register these 13 methods:**

1. **cu.screenshot** - params: {region?: {x,y,width,height}, fullScreen?: bool, physicalPixels?: bool, includeScreenshot?: bool (ignored, always returns image)}
   - No region, no fullScreen: Screenshot::captureWindowLogical(window) (default logical pixels), or Screenshot::captureWindow(window) if physicalPixels=true
   - fullScreen=true: Screenshot::captureScreen(window)
   - region specified: Screenshot::captureRegion(window, QRect(...))
   - Response: {image: base64, width: int, height: int}

2. **cu.click** - params: {x: int, y: int, button?: "left"|"right"|"middle" (default "left"), screenAbsolute?: bool, delay_ms?: int, include_screenshot?: bool}
   - Resolve coordinate, call InputSimulator::mouseClick on resolved widget/pos.
   - If delay_ms specified and > 0, use QThread::msleep(delay_ms) BEFORE the click (to wait for UI to settle).
   - If include_screenshot=true, append "screenshot" key with base64 PNG to response.
   - Response: {success: true} or {success: true, screenshot: base64}

3. **cu.rightClick** - params: {x, y, screenAbsolute?, delay_ms?, include_screenshot?}
   - Same as cu.click but hardcoded button=Right.

4. **cu.middleClick** - params: {x, y, screenAbsolute?, delay_ms?, include_screenshot?}
   - Same as cu.click but hardcoded button=Middle.

5. **cu.doubleClick** - params: {x, y, screenAbsolute?, delay_ms?, include_screenshot?}
   - Resolve coordinate, call InputSimulator::mouseDoubleClick.

6. **cu.mouseMove** - params: {x, y, screenAbsolute?, include_screenshot?}
   - If screenAbsolute: QCursor::setPos(QPoint(x, y)).
   - If window-relative: resolve coordinate, call InputSimulator::mouseMove on target widget.
   - Response: {success: true}

7. **cu.drag** - params: {startX, startY, endX, endY, screenAbsolute?, include_screenshot?}
   - Get active window, call InputSimulator::mouseDrag(window, QPoint(startX,startY), QPoint(endX,endY), MouseButton::Left).
   - Bounds-check both start and end coordinates.

8. **cu.mouseDown** - params: {x, y, button?: "left" (default), screenAbsolute?, include_screenshot?}
   - Resolve coordinate, call InputSimulator::mousePress.

9. **cu.mouseUp** - params: {x, y, button?: "left" (default), screenAbsolute?, include_screenshot?}
   - Resolve coordinate, call InputSimulator::mouseRelease.

10. **cu.type** - params: {text: string, include_screenshot?}
    - Get focused widget: QApplication::focusWidget(). If null, throw error.
    - Call InputSimulator::sendText(focusWidget, text).

11. **cu.key** - params: {key: string, include_screenshot?}
    - Get focused widget. If null, throw error.
    - Use KeyNameMapper::parseKeyCombo(key) to get Qt::Key + modifiers.
    - Call InputSimulator::sendKey(focusWidget, combo.key, combo.modifiers).

12. **cu.scroll** - params: {x, y, direction: "up"|"down"|"left"|"right", amount?: int (default 3), screenAbsolute?, include_screenshot?}
    - Resolve coordinate, then call InputSimulator::scroll.
    - Map direction to dx/dy: up=(0, amount), down=(0, -amount), left=(-amount, 0), right=(amount, 0).
    - Note: positive dy = scroll up (content moves down) in Qt's angleDelta convention.

13. **cu.cursorPosition** - params: {} (none required)
    - Get QCursor::pos() for global position.
    - Get active window, convert to window-relative: window->mapFromGlobal(globalPos).
    - Use HitTest::widgetIdAt(globalPos) for widget info.
    - Use QApplication::widgetAt(globalPos) for className.
    - Response: {x, y, screenX, screenY, widgetId, className}

**Error codes to add to error_codes.h:**
```cpp
// Computer Use errors (-32060 to -32069)
constexpr int kNoActiveWindow = -32060;
constexpr int kCoordinateOutOfBounds = -32061;
constexpr int kNoFocusedWidget = -32062;
constexpr int kKeyParseError = -32063;
```

All responses wrapped with ResponseEnvelope::wrap(). All errors thrown as JsonRpcException.
  </action>
  <verify>
`cmake --build build/` succeeds.
Count registered methods: grep for `RegisterMethod.*"cu\."` in computer_use_mode_api.cpp - should find 13 registrations.
  </verify>
  <done>
ComputerUseModeApi registers 13 cu.* methods. Each method validates params, resolves coordinates, delegates to InputSimulator/Screenshot/KeyNameMapper, returns ResponseEnvelope-wrapped responses. Error codes kNoActiveWindow, kCoordinateOutOfBounds, kNoFocusedWidget, kKeyParseError added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ComputerUseModeApi into Probe and update CMake</name>
  <files>src/probe/core/probe.cpp, src/probe/CMakeLists.txt</files>
  <action>
**CMakeLists.txt changes:**
Add to PROBE_SOURCES:
- `api/computer_use_mode_api.cpp`
- `interaction/key_name_mapper.cpp`

Add to PROBE_HEADERS:
- `api/computer_use_mode_api.h`
- `interaction/key_name_mapper.h`

**probe.cpp changes:**
1. Add `#include "api/computer_use_mode_api.h"` at top with other includes.
2. In `Probe::initialize()`, after the NativeModeApi creation block (line ~157-158), add:
```cpp
// Register Computer Use Mode API (cu.* namespaced methods)
auto* cuApi = new ComputerUseModeApi(m_server->rpcHandler(), this);
Q_UNUSED(cuApi);
```

This follows the exact same pattern as NativeModeApi wiring. The ComputerUseModeApi registers its methods on the same JsonRpcHandler, so both qt.* and cu.* methods are available simultaneously.

Do NOT gate this behind mode check yet - when mode="all" (default), both APIs should be active. Mode gating can be added later if needed.
  </action>
  <verify>
`cmake --build build/` succeeds with all new files compiled.
`cmake --build build/ --target qtmcp_probe` links without undefined symbols.
Run existing tests: `ctest --test-dir build/ --output-on-failure` - all pass (no regressions).
  </verify>
  <done>
CMakeLists.txt includes all 4 new files (2 sources, 2 headers). Probe::initialize() creates ComputerUseModeApi alongside NativeModeApi. Build succeeds. Existing tests pass.
  </done>
</task>

</tasks>

<verification>
- Build succeeds with no warnings on new files
- 13 cu.* methods registered (verified by grep)
- Existing qt.* methods still work (no regressions)
- Error codes in -32060 to -32063 range
- probe.cpp creates both NativeModeApi and ComputerUseModeApi
</verification>

<success_criteria>
- ComputerUseModeApi.h/.cpp exist with 13 cu.* method registrations
- error_codes.h has 4 new CU error codes
- CMakeLists.txt includes key_name_mapper and computer_use_mode_api files
- probe.cpp wires ComputerUseModeApi in initialize()
- Full build succeeds, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-computer-use-mode/04-02-SUMMARY.md`
</output>
