---
phase: 04-computer-use-mode
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/probe/core/probe.cpp
  - src/probe/transport/jsonrpc_handler.cpp
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "NativeModeApi instantiation failure in DLL context is caught, logged to stderr, and does not crash the probe"
    - "ComputerUseModeApi still registers successfully even if NativeModeApi fails"
    - "Legacy qtmcp.getObjectInfo and qtmcp.getGeometry accept both 'id' and 'objectId' parameter names"
  artifacts:
    - path: "src/probe/core/probe.cpp"
      provides: "try/catch around NativeModeApi and ComputerUseModeApi instantiation"
      contains: "try.*NativeModeApi"
    - path: "src/probe/transport/jsonrpc_handler.cpp"
      provides: "Backward compat param reading for legacy methods"
      contains: "objectId"
  key_links:
    - from: "src/probe/core/probe.cpp"
      to: "NativeModeApi constructor"
      via: "try/catch with stderr logging"
      pattern: "catch.*std::exception"
---

<objective>
Fix two UAT gaps: (1) NativeModeApi instantiation silently fails during DLL injection with no error handling, making all qt.* methods unavailable; (2) Legacy qtmcp.getObjectInfo and qtmcp.getGeometry only accept 'id' param, not 'objectId', causing confusion when clients use the modern convention.

Purpose: Make the probe resilient to API registration failures and friendlier to clients using either parameter naming convention.
Output: Hardened probe.cpp and backward-compat legacy methods.
</objective>

<execution_context>
@E:\AI-files\QtMcp\.claude\get-shit-done\workflows\execute-plan.md
@E:\AI-files\QtMcp\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-computer-use-mode/04-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add exception handling around API instantiation in probe.cpp</name>
  <files>src/probe/core/probe.cpp</files>
  <action>
  In Probe::initialize() (around lines 157-163), wrap NativeModeApi and ComputerUseModeApi instantiation in separate try/catch blocks so that failure of one does not prevent the other from registering.

  Current code (lines 157-163):
  ```cpp
  auto* nativeApi = new NativeModeApi(m_server->rpcHandler(), this);
  Q_UNUSED(nativeApi);
  auto* cuApi = new ComputerUseModeApi(m_server->rpcHandler(), this);
  Q_UNUSED(cuApi);
  ```

  Replace with:
  ```cpp
  // Register Native Mode API (qt.* namespaced methods)
  try {
      auto* nativeApi = new NativeModeApi(m_server->rpcHandler(), this);
      Q_UNUSED(nativeApi);
      fprintf(stderr, "[QtMCP] Native Mode API (qt.*) registered\n");
  } catch (const std::exception& e) {
      fprintf(stderr, "[QtMCP] WARNING: Failed to register Native Mode API: %s\n", e.what());
  } catch (...) {
      fprintf(stderr, "[QtMCP] WARNING: Failed to register Native Mode API (unknown exception)\n");
  }

  // Register Computer Use Mode API (cu.* namespaced methods)
  try {
      auto* cuApi = new ComputerUseModeApi(m_server->rpcHandler(), this);
      Q_UNUSED(cuApi);
      fprintf(stderr, "[QtMCP] Computer Use Mode API (cu.*) registered\n");
  } catch (const std::exception& e) {
      fprintf(stderr, "[QtMCP] WARNING: Failed to register Computer Use Mode API: %s\n", e.what());
  } catch (...) {
      fprintf(stderr, "[QtMCP] WARNING: Failed to register Computer Use Mode API (unknown exception)\n");
  }
  ```

  Also add `#include <stdexcept>` at the top if not already present.

  WHY separate try/catch: If NativeModeApi throws (as observed in live DLL injection), ComputerUseModeApi should still register. The probe should be usable in degraded mode.
  </action>
  <verify>Build with `cmake --build build` - no compile errors. Existing tests still pass: `ctest --test-dir build --output-on-failure`.</verify>
  <done>NativeModeApi and ComputerUseModeApi each have independent exception handling. A failure in one does not prevent the other from registering. Failure is logged to stderr.</done>
</task>

<task type="auto">
  <name>Task 2: Add backward-compat 'objectId' param support to legacy qtmcp.* methods</name>
  <files>src/probe/transport/jsonrpc_handler.cpp</files>
  <action>
  In jsonrpc_handler.cpp, find the legacy qtmcp.getObjectInfo method (line ~316-327) and qtmcp.getGeometry method (line ~551-563). Both read the object ID with:
  ```cpp
  QString id = doc.object()["id"].toString();
  ```

  Change both to try "id" first, fall back to "objectId":
  ```cpp
  QJsonObject obj = doc.object();
  QString id = obj["id"].toString();
  if (id.isEmpty()) {
      id = obj["objectId"].toString();
  }
  ```

  Search the file for ALL other legacy qtmcp.* methods that read an "id" parameter and apply the same pattern. Known candidates:
  - qtmcp.getObjectInfo (line ~318)
  - qtmcp.getGeometry (line ~553)
  - Any other method using `doc.object()["id"]`

  Do NOT change the qt.* methods in native_mode_api.cpp - those already use ObjectResolver which has its own parameter conventions.

  WHY: Clients naturally use "objectId" (the qt.* convention) when calling legacy methods. Accepting both prevents confusion without breaking existing clients that use "id".
  </action>
  <verify>Build with `cmake --build build`. Run `ctest --test-dir build --output-on-failure` - all tests pass. Grep for `doc.object()["id"]` in jsonrpc_handler.cpp to confirm all instances have the fallback.</verify>
  <done>All legacy qtmcp.* methods that accept an object ID now accept both "id" and "objectId" parameter names. Existing behavior unchanged for clients already using "id".</done>
</task>

</tasks>

<verification>
1. `cmake --build build` succeeds with no new warnings
2. `ctest --test-dir build --output-on-failure` - all 10 test suites pass
3. stderr output during probe startup now shows registration success/failure messages
4. Legacy methods accept both "id" and "objectId" params
</verification>

<success_criteria>
- Probe initialization is resilient: NativeModeApi failure does not prevent ComputerUseModeApi registration
- Failure is observable via stderr logging (not silently swallowed)
- Legacy qtmcp.getObjectInfo and qtmcp.getGeometry work with both "id" and "objectId" params
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-computer-use-mode/04-04-SUMMARY.md`
</output>
