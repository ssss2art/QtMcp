---
phase: 04-computer-use-mode
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/probe/api/computer_use_mode_api.h
  - src/probe/api/computer_use_mode_api.cpp
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "cu.cursorPosition returns the last simulated position after cu.mouseMove, cu.click, etc."
    - "cu.cursorPosition falls back to physical cursor when no simulated position exists"
    - "All coordinate-based cu.* methods update the tracked virtual position"
  artifacts:
    - path: "src/probe/api/computer_use_mode_api.h"
      provides: "Static m_lastSimulatedPosition member"
      contains: "m_lastSimulatedPosition"
    - path: "src/probe/api/computer_use_mode_api.cpp"
      provides: "Virtual position tracking in all coordinate methods + cursorPosition query"
      contains: "s_lastSimulatedPosition"
  key_links:
    - from: "cu.click/cu.mouseMove/cu.drag etc"
      to: "s_lastSimulatedPosition"
      via: "static QPoint update after each action"
      pattern: "s_lastSimulatedPosition"
    - from: "cu.cursorPosition"
      to: "s_lastSimulatedPosition"
      via: "read virtual position if set, else physical cursor"
      pattern: "s_lastSimulatedPosition"
---

<objective>
Fix UAT gap: cu.cursorPosition reads QCursor::pos() (physical OS cursor) instead of the last simulated position from cu.mouseMove/cu.click/etc. This makes cursorPosition useless for computer use agents that send QMouseEvents without moving the physical cursor.

Purpose: Make cu.cursorPosition consistent with the virtual cursor that CU actions operate on.
Output: Virtual position tracking across all CU coordinate methods.
</objective>

<execution_context>
@E:\AI-files\QtMcp\.claude\get-shit-done\workflows\execute-plan.md
@E:\AI-files\QtMcp\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-computer-use-mode/04-UAT.md
@.planning/phases/04-computer-use-mode/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add virtual cursor position tracking to ComputerUseModeApi</name>
  <files>src/probe/api/computer_use_mode_api.h, src/probe/api/computer_use_mode_api.cpp</files>
  <action>
  **In computer_use_mode_api.h:** No class member changes needed. We will use a file-scope static in the .cpp since all lambdas are stateless (they do not capture `this`).

  **In computer_use_mode_api.cpp:**

  1. Add a file-scope static variable in the anonymous namespace (or at file scope near the existing helpers):
  ```cpp
  namespace {
  // ... existing helpers ...

  // Virtual cursor position tracking for CU mode
  // Set by coordinate-based actions, read by cu.cursorPosition
  static QPoint s_lastSimulatedPosition(-1, -1);
  static bool s_hasSimulatedPosition = false;
  }
  ```

  2. Add a helper function to update the tracked position:
  ```cpp
  static void trackPosition(QWidget* window, int x, int y, bool screenAbsolute) {
      if (screenAbsolute) {
          s_lastSimulatedPosition = QPoint(x, y);
      } else if (window) {
          s_lastSimulatedPosition = window->mapToGlobal(QPoint(x, y));
      } else {
          s_lastSimulatedPosition = QPoint(x, y);
      }
      s_hasSimulatedPosition = true;
  }
  ```

  3. Call `trackPosition(window, x, y, screenAbsolute)` at the END of each coordinate-based method's lambda, AFTER the action succeeds but BEFORE maybeAddScreenshot. Methods to update:
     - cu.click (x, y)
     - cu.rightClick (x, y)
     - cu.middleClick (x, y)
     - cu.doubleClick (x, y)
     - cu.mouseMove (x, y)
     - cu.mouseDown (x, y)
     - cu.mouseUp (x, y)
     - cu.drag (endX, endY - track the END position)
     - cu.scroll (x, y)

  4. Update cu.cursorPosition in registerQueryMethods() to use virtual position when available:
  ```cpp
  m_handler->RegisterMethod(QStringLiteral("cu.cursorPosition"),
      [](const QString& /*params*/) -> QString {
          QPoint globalPos;
          bool isVirtual = false;

          if (s_hasSimulatedPosition) {
              globalPos = s_lastSimulatedPosition;
              isVirtual = true;
          } else {
              globalPos = QCursor::pos();
          }

          QWidget* window = getActiveWindow();
          QPoint windowPos = window->mapFromGlobal(globalPos);

          QString widgetId = HitTest::widgetIdAt(globalPos);

          QWidget* widgetAtPos = QApplication::widgetAt(globalPos);
          QString className;
          if (widgetAtPos) {
              className = QString::fromUtf8(widgetAtPos->metaObject()->className());
          }

          QJsonObject result;
          result[QStringLiteral("x")] = windowPos.x();
          result[QStringLiteral("y")] = windowPos.y();
          result[QStringLiteral("screenX")] = globalPos.x();
          result[QStringLiteral("screenY")] = globalPos.y();
          result[QStringLiteral("widgetId")] = widgetId;
          result[QStringLiteral("className")] = className;
          result[QStringLiteral("virtual")] = isVirtual;

          return envelopeToString(ResponseEnvelope::wrap(result));
      });
  ```

  The "virtual" boolean in the response tells the caller whether the position is from simulated actions or from the physical cursor. This is informational and does not change behavior.

  WHY static instead of member: All cu.* lambdas are stateless (no `this` capture). Using a file-scope static is consistent with the existing pattern and avoids changing lambda capture semantics.

  WHY track at global coordinates: All CU methods resolve to window-local coordinates internally, but cursorPosition needs to map back. Storing the global position (after mapToGlobal) keeps the representation consistent with QCursor::pos().
  </action>
  <verify>
  Build: `cmake --build build`
  Tests: `ctest --test-dir build --output-on-failure` - all 10 suites pass.
  The existing test_computer_use_api::testCursorPosition test should still pass since it only checks response structure (x, y, className keys exist). The new "virtual" key is additive.
  </verify>
  <done>
  - cu.cursorPosition returns virtual position after any cu.* coordinate action
  - cu.cursorPosition falls back to physical cursor when no actions have been performed
  - Response includes "virtual": true/false to indicate source
  - All coordinate-based cu.* methods update the tracked position
  - Zero test regressions
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build` succeeds
2. `ctest --test-dir build --output-on-failure` - all 10 test suites pass
3. After cu.click(100, 200), cu.cursorPosition returns x~100, y~200 with virtual:true
4. Without prior CU action, cu.cursorPosition returns physical cursor with virtual:false
</verification>

<success_criteria>
- cu.cursorPosition reflects simulated position after CU actions, not physical OS cursor
- All 9 coordinate-based cu.* methods track their position
- Backward compatible: "virtual" field is additive, existing response fields unchanged
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-computer-use-mode/04-05-SUMMARY.md`
</output>
