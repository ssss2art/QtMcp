---
phase: 05-chrome-mode
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/probe/api/chrome_mode_api.h
  - src/probe/api/chrome_mode_api.cpp
  - src/probe/CMakeLists.txt
  - src/probe/core/probe.cpp
autonomous: true

must_haves:
  truths:
    - "chr.readPage returns accessibility tree with numbered refs for interactive elements"
    - "chr.click triggers action on element identified by ref"
    - "chr.formInput sets value on text/numeric/checkbox/combobox widgets by ref"
    - "chr.getPageText returns all visible text content from the active window"
    - "chr.find matches elements by natural language query against names, roles, labels, tooltips"
    - "chr.navigate activates tabs and menu items by ref"
    - "chr.tabsContext lists all top-level windows with active window indicator"
    - "chr.readConsoleMessages returns captured qDebug/qWarning messages with optional pattern filter"
  artifacts:
    - path: "src/probe/api/chrome_mode_api.h"
      provides: "ChromeModeApi class with 8 method registration functions"
      contains: "class ChromeModeApi"
    - path: "src/probe/api/chrome_mode_api.cpp"
      provides: "All 8 chr.* method implementations"
      contains: "chr.readPage"
    - path: "src/probe/CMakeLists.txt"
      provides: "Build integration for accessibility/ files and chrome_mode_api"
      contains: "chrome_mode_api.cpp"
    - path: "src/probe/core/probe.cpp"
      provides: "ChromeModeApi registration in Probe::initialize()"
      contains: "ChromeModeApi"
  key_links:
    - from: "chrome_mode_api.cpp"
      to: "accessibility/accessibility_tree_walker.h"
      via: "AccessibilityTreeWalker::walk() for read_page and find"
      pattern: "AccessibilityTreeWalker::walk"
    - from: "chrome_mode_api.cpp"
      to: "accessibility/role_mapper.h"
      via: "RoleMapper::toChromeName() for find matching"
      pattern: "RoleMapper"
    - from: "chrome_mode_api.cpp"
      to: "accessibility/console_message_capture.h"
      via: "ConsoleMessageCapture::instance()->messages() for readConsoleMessages"
      pattern: "ConsoleMessageCapture"
    - from: "probe.cpp"
      to: "api/chrome_mode_api.h"
      via: "new ChromeModeApi(m_server->rpcHandler(), this)"
      pattern: "ChromeModeApi"
---

<objective>
Create ChromeModeApi class registering all 8 chr.* JSON-RPC methods, update CMakeLists.txt to build the new accessibility/ files, and wire ChromeModeApi + ConsoleMessageCapture into Probe::initialize().

Purpose: This is the core Chrome Mode API surface that agents will use. All methods follow the established NativeModeApi/ComputerUseModeApi registration pattern.
Output: chrome_mode_api.h/cpp, updated CMakeLists.txt, updated probe.cpp
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-chrome-mode/05-RESEARCH.md
@.planning/phases/05-chrome-mode/05-CONTEXT.md
@.planning/phases/05-chrome-mode/05-01-SUMMARY.md
@src/probe/api/computer_use_mode_api.h
@src/probe/api/computer_use_mode_api.cpp
@src/probe/api/native_mode_api.cpp
@src/probe/core/probe.cpp
@src/probe/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChromeModeApi class with all 8 chr.* methods</name>
  <files>
    src/probe/api/chrome_mode_api.h
    src/probe/api/chrome_mode_api.cpp
  </files>
  <action>
**chrome_mode_api.h:**
Follow exact ComputerUseModeApi pattern:
```cpp
class QTMCP_EXPORT ChromeModeApi : public QObject {
    Q_OBJECT
public:
    explicit ChromeModeApi(JsonRpcHandler* handler, QObject* parent = nullptr);
private:
    void registerReadPageMethod();
    void registerClickMethod();
    void registerFormInputMethod();
    void registerGetPageTextMethod();
    void registerFindMethod();
    void registerNavigateMethod();
    void registerTabsContextMethod();
    void registerReadConsoleMessagesMethod();
    JsonRpcHandler* m_handler;
};
```

**chrome_mode_api.cpp:**
Use anonymous namespace for file-scope statics and helpers (project pattern):

```cpp
namespace {
    // Ephemeral ref map - rebuilt on each readPage call
    static QHash<QString, QAccessibleInterface*> s_refToAccessible;
    static QHash<QString, QPointer<QObject>> s_refToObject;  // validity check

    void clearRefs() { s_refToAccessible.clear(); s_refToObject.clear(); }

    QAccessibleInterface* resolveRef(const QString& ref) {
        auto it = s_refToAccessible.find(ref);
        if (it == s_refToAccessible.end()) {
            throw JsonRpcException(ErrorCode::kRefNotFound,
                "Element ref not found: " + ref + ". Call chr.readPage to get fresh refs.",
                QJsonObject{{"ref", ref}});
        }
        // Check if underlying QObject is still alive
        auto objIt = s_refToObject.find(ref);
        if (objIt != s_refToObject.end() && objIt.value().isNull()) {
            throw JsonRpcException(ErrorCode::kRefStale,
                "Element was destroyed since last read_page: " + ref,
                QJsonObject{{"ref", ref}});
        }
        if (!it.value()->isValid()) {
            throw JsonRpcException(ErrorCode::kRefStale,
                "Element ref is stale: " + ref,
                QJsonObject{{"ref", ref}});
        }
        return it.value();
    }

    // Helper to get active window as QWidget*
    QWidget* getActiveWindowWidget() { ... same pattern as CU mode ... }
}
```

**Method implementations:**

1. **chr.readPage** (params: filter?, depth?, ref_id?, max_chars?):
   - clearRefs()
   - Get active window via getActiveWindowWidget()
   - Build WalkOptions from params (filter default "all", maxDepth default 15, maxChars default 50000)
   - If ref_id provided, resolve from previous refs BEFORE clearing (or walk from root then scope)
   - Call AccessibilityTreeWalker::walk(window, opts)
   - Store result.refMap in s_refToAccessible, also store QPointer<QObject> for each interface's object() in s_refToObject
   - Return ResponseEnvelope::wrap() with tree JSON + totalNodes + truncated flag

2. **chr.click** (params: ref):
   - resolveRef(ref) to get QAccessibleInterface*
   - Try QAccessibleActionInterface::doAction(pressAction()) first
   - Fall back to InputSimulator::mouseClick() at widget center if no action interface
   - Return ResponseEnvelope::wrap() with {clicked: true, ref, role}

3. **chr.formInput** (params: ref, value):
   - resolveRef(ref) to get QAccessibleInterface*
   - Implement form input strategy from research:
     a. QAccessibleValueInterface::setCurrentValue() for numeric widgets (value is number)
     b. QAccessibleEditableTextInterface::replaceText(0, len, text) for text widgets (value is string)
     c. qobject_cast<QComboBox*> special case for combo boxes
     d. QAccessibleActionInterface::doAction(toggleAction()) for checkboxes/radios (value is bool)
   - If none work, throw kFormInputUnsupported error
   - Return ResponseEnvelope::wrap() with {success: true, ref}

4. **chr.getPageText** (params: none):
   - Get active window
   - Walk accessibility tree extracting visible text from text-bearing roles
   - Use recursive helper that collects text from QAccessible::Name and QAccessible::Value for StaticText, EditableText, Heading, Paragraph, Button, Link, Label, ListItem, TreeItem, Cell, MenuItem
   - Skip invisible/offscreen nodes
   - Return ResponseEnvelope::wrap() with {text: joinedText}

5. **chr.find** (params: query):
   - Get active window
   - Walk full tree, for each node check case-insensitive substring match against: accessible name, role name (Chrome name), tooltip text (QAccessible::Description), objectName, className
   - Collect matches with refs (assign refs to matches during this walk; store in s_refToAccessible/s_refToObject)
   - If >20 matches, return error kFindTooManyResults asking for more specific query
   - Return ResponseEnvelope::wrap() with array of matching elements (same JSON format as tree nodes)

6. **chr.navigate** (params: action, ref?):
   - action "activateTab": resolve ref, get QAccessibleActionInterface, doAction(pressAction()) on tab
   - action "activateMenuItem": resolve ref, get QAccessibleActionInterface, doAction(pressAction()) on menu item
   - action "back"/"forward": find QAction with "undo"/"redo" shortcuts in active window, trigger them. If not found, throw kNavigateInvalid.
   - Return ResponseEnvelope::wrap() with {navigated: true, action}

7. **chr.tabsContext** (params: none):
   - Get all top-level widgets via QApplication::topLevelWidgets()
   - Filter to visible QWidgets
   - For each: include windowTitle, className, objectName, isActive (== QApplication::activeWindow())
   - Return ResponseEnvelope::wrap() with array of window info

8. **chr.readConsoleMessages** (params: pattern?, onlyErrors?, clear?, limit?):
   - Call ConsoleMessageCapture::instance()->messages(pattern, onlyErrors, limit)
   - If clear param is true, call ConsoleMessageCapture::instance()->clear()
   - Map each ConsoleMessage to JSON: {type: "debug"|"warning"|"error"|"info"|"fatal", message, file, line, function, timestamp}
   - Return ResponseEnvelope::wrap() with array of messages

All responses use ResponseEnvelope::wrap(). All errors use throw JsonRpcException with appropriate ErrorCode from error_codes.h.
  </action>
  <verify>
Files exist: `ls src/probe/api/chrome_mode_api.h src/probe/api/chrome_mode_api.cpp`
8 methods registered: `grep -c "chr\." src/probe/api/chrome_mode_api.cpp` returns at least 8
ResponseEnvelope used: `grep -c "ResponseEnvelope::wrap" src/probe/api/chrome_mode_api.cpp` returns 8
  </verify>
  <done>
ChromeModeApi registers 8 chr.* methods on JsonRpcHandler.
All methods use ephemeral refs, ResponseEnvelope wrapping, and structured error codes.
Form input works through accessibility sub-interfaces (value, editable text, action) with ComboBox special case.
Find uses case-insensitive substring matching across name, role, tooltip, objectName, className.
  </done>
</task>

<task type="auto">
  <name>Task 2: CMakeLists.txt update and Probe wiring</name>
  <files>
    src/probe/CMakeLists.txt
    src/probe/core/probe.cpp
  </files>
  <action>
**CMakeLists.txt** - Add new source and header files to PROBE_SOURCES and PROBE_HEADERS:

Sources to add:
```
accessibility/role_mapper.cpp
accessibility/console_message_capture.cpp
accessibility/accessibility_tree_walker.cpp
api/chrome_mode_api.cpp
```

Headers to add:
```
accessibility/role_mapper.h
accessibility/console_message_capture.h
accessibility/accessibility_tree_walker.h
api/chrome_mode_api.h
```

Also add `Qt6::Gui` to PUBLIC link libraries if not already present (QAccessible is in QtGui). Check - it may already be linked transitively through Qt6::Widgets. If Qt6::Gui is not in the list, add it.

**probe.cpp** - Add ChromeModeApi registration following the existing pattern (independent try/catch block):

Add include:
```cpp
#include "api/chrome_mode_api.h"
#include "accessibility/console_message_capture.h"
```

In Probe::initialize(), BEFORE the API registrations, add ConsoleMessageCapture installation:
```cpp
// Install console message capture (before API registration so early messages are caught)
try {
    ConsoleMessageCapture::instance()->install();
    fprintf(stderr, "[QtMCP] Console message capture installed\n");
} catch (...) {
    fprintf(stderr, "[QtMCP] WARNING: Failed to install console message capture\n");
}
```

After the Computer Use Mode API registration block, add Chrome Mode API registration:
```cpp
// Register Chrome Mode API (chr.* namespaced methods)
try {
    auto* chrApi = new ChromeModeApi(m_server->rpcHandler(), this);
    Q_UNUSED(chrApi);
    fprintf(stderr, "[QtMCP] Chrome Mode API (chr.*) registered\n");
} catch (const std::exception& e) {
    fprintf(stderr, "[QtMCP] WARNING: Failed to register Chrome Mode API: %s\n", e.what());
} catch (...) {
    fprintf(stderr, "[QtMCP] WARNING: Failed to register Chrome Mode API (unknown exception)\n");
}
```

Also add to the clientDisconnected handler: clear Chrome Mode refs on disconnect (call the clearRefs helper or add a static method on ChromeModeApi).
  </action>
  <verify>
Build: `cmake --build build/windows-debug --config Debug 2>&1 | tail -5` compiles without errors.
Probe wiring: `grep "ChromeModeApi" src/probe/core/probe.cpp` shows registration code.
CMake: `grep "chrome_mode_api" src/probe/CMakeLists.txt` shows source added.
  </verify>
  <done>
All 4 new .cpp files and 4 new .h files included in CMakeLists.txt build.
ConsoleMessageCapture installed early in Probe::initialize().
ChromeModeApi registered with independent try/catch (probe survives if Chrome Mode fails).
Chrome Mode refs cleared on client disconnect.
Project builds successfully with all 3 API modes active simultaneously.
  </done>
</task>

</tasks>

<verification>
- Project builds with `cmake --build build/windows-debug --config Debug`
- 8 chr.* methods registered on JsonRpcHandler
- ConsoleMessageCapture installed on probe init
- Chrome Mode refs cleared on disconnect
- All existing tests still pass (no regressions)
</verification>

<success_criteria>
- ChromeModeApi registers chr.readPage, chr.click, chr.formInput, chr.getPageText, chr.find, chr.navigate, chr.tabsContext, chr.readConsoleMessages
- All 3 API modes (qt.*, cu.*, chr.*) active simultaneously
- Build succeeds with zero errors
- Existing 10 test suites still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-chrome-mode/05-02-SUMMARY.md`
</output>
