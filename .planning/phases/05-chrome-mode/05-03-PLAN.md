---
phase: 05-chrome-mode
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - tests/test_chrome_mode_api.cpp
  - tests/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "chr.readPage returns tree with refs for standard Qt widgets (buttons, inputs, labels)"
    - "chr.readPage with filter=interactive only assigns refs to interactive elements"
    - "chr.readPage respects maxDepth limit"
    - "chr.click invokes press action on a button identified by ref"
    - "chr.formInput sets text on a QLineEdit identified by ref"
    - "chr.formInput sets value on a QSpinBox identified by ref"
    - "chr.formInput toggles a QCheckBox identified by ref"
    - "chr.getPageText extracts visible text from all text-bearing widgets"
    - "chr.find matches elements by name substring"
    - "chr.tabsContext lists visible top-level windows"
    - "chr.readConsoleMessages returns captured messages"
    - "Stale ref produces clear error message"
    - "All existing 10 test suites still pass (zero regressions)"
  artifacts:
    - path: "tests/test_chrome_mode_api.cpp"
      provides: "Integration tests for all 8 chr.* methods"
      contains: "TestChromeModeApi"
    - path: "tests/CMakeLists.txt"
      provides: "Build configuration for test_chrome_mode_api executable"
      contains: "test_chrome_mode_api"
  key_links:
    - from: "tests/test_chrome_mode_api.cpp"
      to: "src/probe/api/chrome_mode_api.h"
      via: "ChromeModeApi constructor with JsonRpcHandler"
      pattern: "ChromeModeApi"
    - from: "tests/test_chrome_mode_api.cpp"
      to: "src/probe/transport/jsonrpc_handler.h"
      via: "JsonRpcHandler::handleMessage() for method invocation"
      pattern: "handleMessage"
---

<objective>
Create comprehensive integration tests for the Chrome Mode API, verifying all 8 chr.* methods work correctly with real Qt widgets. Update tests/CMakeLists.txt to build and register the new test executable.

Purpose: Verify Chrome Mode API surface works end-to-end with accessibility tree traversal, ref-based interaction, form input, text extraction, element finding, and console message capture.
Output: test_chrome_mode_api.cpp with ~20+ test functions, updated tests/CMakeLists.txt
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-chrome-mode/05-RESEARCH.md
@.planning/phases/05-chrome-mode/05-01-SUMMARY.md
@.planning/phases/05-chrome-mode/05-02-SUMMARY.md
@tests/test_computer_use_api.cpp
@tests/test_native_mode_api.cpp
@tests/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chrome Mode API integration tests</name>
  <files>
    tests/test_chrome_mode_api.cpp
  </files>
  <action>
Create test_chrome_mode_api.cpp following the exact pattern from test_computer_use_api.cpp and test_native_mode_api.cpp:

**Test class setup:**
```cpp
class TestChromeModeApi : public QObject {
    Q_OBJECT
private slots:
    void init();     // Per-test: create fresh handler, API, test widgets
    void cleanup();  // Per-test: destroy everything
    // ... test methods ...
};
```

**init():** Create JsonRpcHandler, ChromeModeApi (registered on handler), and a test widget hierarchy:
- QWidget (main window) with setWindowTitle("Test Window")
- QPushButton "Click Me" (objectName: "btnTest")
- QLineEdit (objectName: "editName")
- QSpinBox (objectName: "spinAge", range 0-120, value 25)
- QCheckBox "Accept Terms" (objectName: "chkTerms")
- QLabel "Hello World" (objectName: "lblGreeting")
- QComboBox with items ["Red", "Green", "Blue"] (objectName: "comboColor")
- Show the main window

**cleanup():** Delete widgets, delete API, delete handler. Also call QAccessible cleanup if needed.

**Test methods (~20 tests):**

*chr.readPage tests:*
- `testReadPage_ReturnsTree`: Call chr.readPage with no params, verify result has "tree" with nested children and refs
- `testReadPage_AllFilter`: Call with filter="all", verify all elements have refs
- `testReadPage_InteractiveFilter`: Call with filter="interactive", verify only buttons/inputs/combos get refs, not labels
- `testReadPage_MaxDepth`: Call with depth=1, verify tree is shallow (no deep children)
- `testReadPage_RefFormat`: Verify refs follow "ref_1", "ref_2" pattern
- `testReadPage_IncludesQtExtras`: Verify nodes include objectName, className fields
- `testReadPage_RoleMapping`: Verify QPushButton gets role "button", QLineEdit gets "textbox", QLabel gets "text"

*chr.click tests:*
- `testClick_Button`: Read page to get ref for button, call chr.click with that ref, verify button click signal was emitted (use QSignalSpy)
- `testClick_InvalidRef`: Call chr.click with "ref_999", verify kRefNotFound error

*chr.formInput tests:*
- `testFormInput_LineEdit`: Set QLineEdit value via chr.formInput, verify text changed
- `testFormInput_SpinBox`: Set QSpinBox value via chr.formInput with numeric value, verify value changed
- `testFormInput_CheckBox`: Toggle QCheckBox via chr.formInput with boolean value, verify checked state
- `testFormInput_ComboBox`: Set QComboBox via chr.formInput with string value, verify selection changed
- `testFormInput_UnsupportedWidget`: Try form_input on a QLabel, verify kFormInputUnsupported error

*chr.getPageText tests:*
- `testGetPageText_ExtractsText`: Verify "Hello World", "Click Me", "Accept Terms" appear in extracted text
- `testGetPageText_SkipsInvisible`: Hide a label, verify its text is NOT in output

*chr.find tests:*
- `testFind_ByName`: Find "Click Me", verify button returned with ref
- `testFind_CaseInsensitive`: Find "click me" (lowercase), verify button still found
- `testFind_ByRole`: Find "button", verify button found
- `testFind_NoResults`: Find "nonexistent_xyz", verify empty array returned

*chr.tabsContext tests:*
- `testTabsContext_ListsWindows`: Verify at least one window with title "Test Window"

*chr.readConsoleMessages tests:*
- `testReadConsoleMessages_CapturesDebug`: Emit qDebug("test message"), call chr.readConsoleMessages, verify message appears
- `testReadConsoleMessages_PatternFilter`: Emit multiple messages, filter by pattern, verify only matching messages returned
- `testReadConsoleMessages_OnlyErrors`: Emit qDebug + qWarning, filter onlyErrors=true, verify only warning returned
- `testReadConsoleMessages_Clear`: Read messages with clear=true, read again, verify empty

**Each test method:**
1. Build JSON-RPC request: `{"jsonrpc":"2.0","id":1,"method":"chr.X","params":{...}}`
2. Call `handler->handleMessage(request)`
3. Parse response, verify result or error fields
4. Use QVERIFY/QCOMPARE for assertions

**Important notes:**
- Use QT_QPA_PLATFORM=minimal (set in CMakeLists.txt env)
- Use QTMCP_ENABLED=0 to disable auto-init
- Call QAccessible::setActive(true) in init() to ensure accessibility works on minimal platform
- Some accessibility features may return empty on minimal platform - use QVERIFY with reasonable checks (verify structure exists, not pixel-perfect content)
- Install ConsoleMessageCapture in init() for console message tests
  </action>
  <verify>
Build and run: `cmake --build build/windows-debug --config Debug --target test_chrome_mode_api && ctest --test-dir build/windows-debug -R test_chrome_mode_api -C Debug --output-on-failure`
All tests pass.
  </verify>
  <done>
~20+ integration tests verify all 8 chr.* methods.
Tests cover happy paths, error cases, and filter behavior.
All tests pass on minimal platform.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tests/CMakeLists.txt and run full test suite</name>
  <files>
    tests/CMakeLists.txt
  </files>
  <action>
Add test_chrome_mode_api executable to tests/CMakeLists.txt following the exact pattern of test_computer_use_api:

```cmake
# Chrome Mode API Integration tests
add_executable(test_chrome_mode_api
    test_chrome_mode_api.cpp
)

if(QT_VERSION_MAJOR EQUAL 6)
    target_link_libraries(test_chrome_mode_api
        PRIVATE
            qtmcp_probe
            Qt6::Core
            Qt6::Gui
            Qt6::Widgets
            Qt6::Test
    )
else()
    target_link_libraries(test_chrome_mode_api
        PRIVATE
            qtmcp_probe
            Qt5::Core
            Qt5::Gui
            Qt5::Widgets
            Qt5::Test
    )
endif()

target_include_directories(test_chrome_mode_api
    PRIVATE
        ${CMAKE_SOURCE_DIR}/src/probe
)

add_test(NAME test_chrome_mode_api COMMAND test_chrome_mode_api
    WORKING_DIRECTORY "$<TARGET_FILE_DIR:test_chrome_mode_api>"
)

set_tests_properties(test_chrome_mode_api PROPERTIES
    ENVIRONMENT "QTMCP_ENABLED=0;QT_QPA_PLATFORM=minimal"
)

if(WIN32)
    add_custom_command(TARGET test_chrome_mode_api POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
            "$<TARGET_FILE:Qt${QT_VERSION_MAJOR}::Test>"
            "$<TARGET_FILE_DIR:test_chrome_mode_api>"
        COMMENT "Copying Qt Test DLL for test_chrome_mode_api..."
    )
endif()
```

After adding, run the FULL test suite to verify zero regressions:
```bash
cmake --build build/windows-debug --config Debug
ctest --test-dir build/windows-debug -C Debug --output-on-failure
```

Verify all 11 test suites pass (10 existing + 1 new).
  </action>
  <verify>
`ctest --test-dir build/windows-debug -C Debug --output-on-failure` shows 11/11 tests passed.
`grep "test_chrome_mode_api" tests/CMakeLists.txt` confirms test is registered.
  </verify>
  <done>
test_chrome_mode_api builds and all tests pass.
All 11 test suites pass with zero regressions.
Chrome Mode API fully verified via integration tests.
  </done>
</task>

</tasks>

<verification>
- All 11 test suites pass (10 existing + test_chrome_mode_api)
- test_chrome_mode_api covers all 8 chr.* methods
- Tests verify: tree structure, ref format, role mapping, click action, form input (4 widget types), text extraction, element finding, window listing, console messages
- Error cases verified: stale ref, invalid ref, unsupported form input
- Zero regressions on existing tests
</verification>

<success_criteria>
- 20+ test functions in test_chrome_mode_api.cpp all pass
- All 11 test suites pass with `ctest`
- Chrome Mode API surface fully verified end-to-end
- Phase 5 success criteria met:
  1. User can request accessibility tree and receive numbered refs for interactive elements
  2. User can click elements and input to form fields using ref numbers
  3. User can get all visible text content from the application
  4. User can find elements using natural language queries
  5. User can navigate tabs/menus and read console messages
</success_criteria>

<output>
After completion, create `.planning/phases/05-chrome-mode/05-03-SUMMARY.md`
</output>
