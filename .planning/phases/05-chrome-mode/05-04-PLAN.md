---
phase: 05-chrome-mode
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/probe/api/chrome_mode_api.cpp
  - tests/test_chrome_mode_api.cpp
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Calling chr.find twice preserves refs from both calls — ref_1 from the first find still resolves after the second find"
    - "chr.find ref numbers do not collide with each other or with chr.readPage refs"
    - "chr.find result nodes include a 'name' field using the same fallback chain as chr.readPage (accessible name → objectName → className)"
  artifacts:
    - path: "src/probe/api/chrome_mode_api.cpp"
      provides: "Fixed chr.find with append-mode refs and name fallback"
      contains: "s_refToAccessible.size"
    - path: "tests/test_chrome_mode_api.cpp"
      provides: "Regression tests for both bugs"
      contains: "testFind_MultipleCallsPreserveRefs"
  key_links:
    - from: "src/probe/api/chrome_mode_api.cpp"
      to: "s_refToAccessible"
      via: "findMatchingNodes appends to existing ref map instead of clearing"
      pattern: "refCounter.*s_refToAccessible\\.size"
    - from: "src/probe/api/chrome_mode_api.cpp"
      to: "buildFindMatchNode"
      via: "name fallback chain matching walkNode"
      pattern: "objectName.*className"
---

<objective>
Fix two bugs in chr.find discovered during Chrome Mode live demo:

1. **Ref map wipe:** chr.find clears the global ref map before searching, so calling chr.find twice destroys refs from the first call. Fix: append to the existing ref map with incrementing counter starting from current map size.

2. **Missing name fallback:** buildFindMatchNode uses only QAccessible::Name with no fallback, while readPage's walkNode falls back to objectName then className. Fix: apply the same 3-step fallback chain.

Purpose: Enable multi-step AI agent workflows that call chr.find multiple times before acting on refs.
Output: Patched chrome_mode_api.cpp + regression tests for both bugs.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/probe/api/chrome_mode_api.cpp
@src/probe/accessibility/accessibility_tree_walker.cpp
@tests/test_chrome_mode_api.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix chr.find ref map wipe and name fallback</name>
  <files>src/probe/api/chrome_mode_api.cpp</files>
  <action>
Two changes in chrome_mode_api.cpp:

**Bug 1 — Ref map wipe (registerFindMethod, line ~602):**
Remove `clearRefsInternal()` call at line 602 in registerFindMethod(). Instead, seed `refCounter` from the current ref map size so new refs append without collision:

```cpp
// Replace:
clearRefsInternal();

QJsonArray matches;
int refCounter = 0;

// With:
QJsonArray matches;
int refCounter = s_refToAccessible.size();
```

This means:
- First chr.find call (empty map) starts at ref_1, ref_2, etc.
- Second chr.find call (map has 3 entries) starts at ref_4, ref_5, etc.
- chr.readPage still calls clearRefsInternal() (line 315), which is correct — readPage rebuilds the entire tree.
- Refs from chr.find and chr.readPage share the same namespace, so readPage clears find refs too (expected — readPage provides authoritative tree).

**Bug 2 — Missing name fallback (buildFindMatchNode, line ~178):**
Apply the same 3-step name fallback chain used in AccessibilityTreeWalker::walkNode() (lines 89-95):

```cpp
// Replace:
QString name = iface->text(QAccessible::Name);
if (!name.isEmpty())
    node[QStringLiteral("name")] = name;

// With:
QString name = iface->text(QAccessible::Name);
QObject* obj = iface->object();  // NOTE: obj already declared below — move declaration up
if (name.isEmpty() && obj) {
    name = obj->objectName();
    if (name.isEmpty())
        name = QString::fromUtf8(obj->metaObject()->className());
}
if (!name.isEmpty())
    node[QStringLiteral("name")] = name;
```

Important: The `QObject* obj` declaration already exists at line 182. Restructure buildFindMatchNode to declare obj first, then use it in both the name fallback and the objectName/className sections. Avoid duplicate obj declarations.
  </action>
  <verify>
Build succeeds: `cmake --build build/ --config Debug 2>&1 | tail -5` shows no errors.
All existing tests pass: `cd build && ctest --output-on-failure -C Debug` shows 11/11 test suites pass with zero regressions.
  </verify>
  <done>
- clearRefsInternal() no longer called in registerFindMethod()
- refCounter seeded from s_refToAccessible.size() in registerFindMethod()
- buildFindMatchNode() has 3-step name fallback (accessible name → objectName → className)
- All 26 existing Chrome Mode tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add regression tests for both bugs</name>
  <files>tests/test_chrome_mode_api.cpp</files>
  <action>
Add 3 new test functions to TestChromeModeApi:

**Test 1: testFind_MultipleCallsPreserveRefs**
- Create a window with two QLineEdits: objectName "nameEdit" and "emailEdit"
- Call chr.find with query "nameEdit" → get ref (e.g., ref_1)
- Call chr.find with query "emailEdit" → get ref (e.g., ref_2)
- Call chr.formInput with the FIRST ref (ref_1) and value "John"
- Verify the nameEdit widget's text is "John" (not the emailEdit)
- This proves the first find's ref survived the second find call

**Test 2: testFind_RefsDoNotCollideWithReadPage**
- Create window with button and line edit
- Call chr.readPage → note ref numbers (e.g., ref_1 through ref_N)
- Call chr.find with query matching the line edit → get ref (e.g., ref_N+1)
- Verify the find ref is DIFFERENT from all readPage refs (higher number)
- Actually: readPage clears refs, so this test verifies that find after readPage starts from scratch correctly. Better test: call chr.find first, then chr.readPage (which clears), then verify old find refs are gone (throw kRefNotFound).

Revised test 2: testFind_ReadPageClearsAllRefs
- Call chr.find → get ref_1
- Call chr.readPage → clears all refs, rebuilds tree
- Call chr.formInput with ref_1 → expect kRefNotFound error (readPage cleared find refs)
- This documents the expected behavior: readPage is authoritative and clears find refs

**Test 3: testFind_NameFallbackToObjectName**
- Create a QLineEdit with objectName "myInput" but NO accessible name (default for QLineEdit)
- Call chr.find with query "myInput"
- Verify the result node contains "name": "myInput" (fallback from objectName)
- This was previously missing — find returned no "name" field for this case

Register all 3 test slots in the class declaration's `private slots:` section.
  </action>
  <verify>
Build succeeds and ALL tests pass: `cd build && cmake --build . --config Debug && ctest --output-on-failure -C Debug`
New tests specifically pass: look for testFind_MultipleCallsPreserveRefs, testFind_ReadPageClearsAllRefs, testFind_NameFallbackToObjectName in output.
  </verify>
  <done>
- testFind_MultipleCallsPreserveRefs proves multi-find workflow works end-to-end
- testFind_ReadPageClearsAllRefs documents readPage clearing behavior
- testFind_NameFallbackToObjectName proves name fallback consistency with readPage
- All 29 Chrome Mode tests pass (26 existing + 3 new)
- All 11 test suites pass with zero regressions
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build/ --config Debug` compiles without errors or warnings
2. `cd build && ctest --output-on-failure -C Debug` shows all 11 test suites pass
3. New test count: 29 tests in test_chrome_mode_api (26 + 3 new)
4. Grep confirms clearRefsInternal not called in registerFindMethod: `grep -n "clearRefsInternal" src/probe/api/chrome_mode_api.cpp` shows it only in clearRefs() and registerReadPageMethod()
5. Grep confirms name fallback in buildFindMatchNode: `grep -A5 "buildFindMatchNode" src/probe/api/chrome_mode_api.cpp` shows objectName/className fallback
</verification>

<success_criteria>
1. Calling chr.find("X") then chr.find("Y") preserves refs from first call — formInput with first ref still works
2. buildFindMatchNode output includes "name" field for widgets with objectName but no accessible name
3. All 11 test suites pass with zero regressions
4. 3 new regression tests prevent both bugs from recurring
</success_criteria>

<output>
After completion, create `.planning/phases/05-chrome-mode/05-04-SUMMARY.md`
</output>
