---
phase: 06-extended-introspection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CMakeLists.txt
  - src/probe/CMakeLists.txt
  - src/probe/introspection/qml_inspector.h
  - src/probe/introspection/qml_inspector.cpp
  - src/probe/introspection/object_id.cpp
  - src/probe/api/error_codes.h
autonomous: true

must_haves:
  truths:
    - "QML items detected via qobject_cast<QQuickItem*> with QTMCP_HAS_QML compile guard"
    - "QML id retrieved via QQmlContext::nameForObject() public API"
    - "QML type names stripped of QQuick prefix for anonymous items"
    - "QML id replaces className in hierarchical object paths when available"
    - "Object tree serialization includes qmlId, qmlFile, isQmlItem metadata for QQuickItems"
    - "All QML code guarded by #ifdef QTMCP_HAS_QML — builds without Qt Quick installed"
  artifacts:
    - path: "src/probe/introspection/qml_inspector.h"
      provides: "QmlItemInfo struct, inspectQmlItem(), stripQmlPrefix() functions"
    - path: "src/probe/introspection/qml_inspector.cpp"
      provides: "QML metadata extraction implementation"
    - path: "src/probe/introspection/object_id.cpp"
      provides: "QML-aware generateIdSegment() — QML id or short type name for QQuickItems"
    - path: "src/probe/api/error_codes.h"
      provides: "QML error codes (-32080 to -32089) and Model error codes (-32090 to -32099)"
  key_links:
    - from: "src/probe/introspection/object_id.cpp"
      to: "src/probe/introspection/qml_inspector.h"
      via: "#ifdef QTMCP_HAS_QML include and call inspectQmlItem()"
      pattern: "inspectQmlItem|QTMCP_HAS_QML"
    - from: "CMakeLists.txt"
      to: "src/probe/CMakeLists.txt"
      via: "find_package(Qt6 COMPONENTS Qml Quick QUIET) propagated to probe target"
      pattern: "QTMCP_HAS_QML"
---

<objective>
Add QML introspection infrastructure: QmlInspector utility class for QML metadata extraction, QML-aware object ID generation, and CMake optional dependency on Qt6::Qml/Qt6::Quick.

Purpose: QML items must appear naturally in the object tree with human-readable paths (QML id or short type names instead of QQuickRectangle). This plan builds the foundation that Plan 02 will wire into the API.

Output: qml_inspector.h/.cpp, modified object_id.cpp with QML-aware ID generation, CMake changes for optional Qt Quick dependency, new error codes for QML and Model domains.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-extended-introspection/06-CONTEXT.md
@.planning/phases/06-extended-introspection/06-RESEARCH.md
@src/probe/introspection/object_id.h
@src/probe/introspection/object_id.cpp
@src/probe/api/error_codes.h
@src/probe/CMakeLists.txt
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: CMake optional Qt Quick dependency + QML Inspector + Error Codes</name>
  <files>
    CMakeLists.txt
    src/probe/CMakeLists.txt
    src/probe/introspection/qml_inspector.h
    src/probe/introspection/qml_inspector.cpp
    src/probe/api/error_codes.h
  </files>
  <action>
    **CMakeLists.txt (root):** Add `find_package(Qt6 COMPONENTS Qml Quick QUIET)` after the existing Qt6 find_package. If found, set `QTMCP_HAS_QML ON`. Same pattern for Qt5 fallback block. Add status message.

    **src/probe/CMakeLists.txt:**
    - Add qml_inspector.cpp to PROBE_SOURCES and qml_inspector.h to PROBE_HEADERS.
    - In the Qt6 link block, add conditional linking:
      ```cmake
      if(QTMCP_HAS_QML)
          target_link_libraries(qtmcp_probe PUBLIC Qt6::Qml Qt6::Quick)
          target_compile_definitions(qtmcp_probe PUBLIC QTMCP_HAS_QML)
      endif()
      ```
    - Same for Qt5 block.

    **src/probe/introspection/qml_inspector.h:** Create with:
    - `namespace qtmcp`
    - `struct QmlItemInfo { bool isQmlItem; QString qmlId; QString qmlFile; QString shortTypeName; }` with `isQmlItem` defaulting to false
    - `QmlItemInfo inspectQmlItem(QObject* obj)` — extracts QML metadata
    - `QString stripQmlPrefix(const QString& className)` — strips "QQuick" prefix
    - `bool isQmlItem(QObject* obj)` — quick check via qobject_cast
    - All declarations guarded by `#ifdef QTMCP_HAS_QML` (entire file content except header guard and namespace)
    - If QTMCP_HAS_QML is not defined, provide stub implementations that return defaults (isQmlItem always false, inspectQmlItem returns empty struct)

    **src/probe/introspection/qml_inspector.cpp:** Implement:
    - `#ifdef QTMCP_HAS_QML` guard wrapping the real implementations
    - `#include <QQmlContext>`, `#include <QQmlEngine>`, `#include <QQuickItem>`
    - `stripQmlPrefix()`: if className starts with "QQuick", return className.mid(6), else return className
    - `isQmlItem()`: return qobject_cast<QQuickItem*>(obj) != nullptr
    - `inspectQmlItem()`: check qobject_cast<QQuickItem*>, if not QQuickItem return default struct. Otherwise set isQmlItem=true, compute shortTypeName via stripQmlPrefix(), get qmlContext(obj), call nameForObject(obj) for qmlId, get baseUrl() for qmlFile. Return struct.
    - `#else` block with stub implementations

    **src/probe/api/error_codes.h:** Add two new error code ranges:
    ```cpp
    // QML errors (-32080 to -32089)
    constexpr int kQmlNotAvailable = -32080;
    constexpr int kQmlContextNotFound = -32081;
    constexpr int kNotQmlItem = -32082;

    // Model/View errors (-32090 to -32099)
    constexpr int kModelNotFound = -32090;
    constexpr int kModelIndexOutOfBounds = -32091;
    constexpr int kModelRoleNotFound = -32092;
    constexpr int kNotAModel = -32093;
    ```
  </action>
  <verify>
    Build with `cmake --build build/ --config Debug 2>&1`. Must compile with zero errors. Grep for "QTMCP_HAS_QML" in build output to confirm detection (or not, depending on Qt installation).
  </verify>
  <done>
    qml_inspector.h/.cpp exist and compile. Error codes added. CMake correctly detects Qt Quick as optional dependency and sets QTMCP_HAS_QML compile definition when available.
  </done>
</task>

<task type="auto">
  <name>Task 2: QML-aware Object ID Generation and Tree Serialization</name>
  <files>
    src/probe/introspection/object_id.cpp
  </files>
  <action>
    Modify `generateIdSegment()` in object_id.cpp to detect QML items and use QML-appropriate naming:

    1. Add `#include "qml_inspector.h"` at the top.

    2. In `generateIdSegment()`, add QML detection BEFORE the existing objectName/text/className logic:
       ```cpp
       #ifdef QTMCP_HAS_QML
       // QML items: use QML id or short type name
       QmlItemInfo qmlInfo = inspectQmlItem(obj);
       if (qmlInfo.isQmlItem) {
           if (!qmlInfo.qmlId.isEmpty()) {
               return qmlInfo.qmlId;  // QML id replaces everything
           }
           // No QML id — use short type name with sibling disambiguation
           // Fall through to let the existing objectName check happen first
           // but if objectName is also empty, use shortTypeName instead of className
       }
       #endif
       ```

       The exact integration point: QML id takes HIGHEST priority (before objectName). If no QML id but objectName exists, use objectName (existing logic). If no QML id AND no objectName, use shortTypeName instead of className for the disambiguation segment. This means modifying the className fallback path to check for QML short type name.

    3. In `serializeObjectInfo()`, add QML metadata fields:
       ```cpp
       #ifdef QTMCP_HAS_QML
       QmlItemInfo qmlInfo = inspectQmlItem(obj);
       if (qmlInfo.isQmlItem) {
           result["isQmlItem"] = true;
           if (!qmlInfo.qmlId.isEmpty())
               result["qmlId"] = qmlInfo.qmlId;
           if (!qmlInfo.qmlFile.isEmpty())
               result["qmlFile"] = qmlInfo.qmlFile;
           result["qmlTypeName"] = qmlInfo.shortTypeName;
       }
       #endif
       ```

    4. In `serializeObjectTree()` (the recursive helper that builds tree nodes), also add the same QML metadata fields to each node so the full tree includes QML info, not just single-object info.

    IMPORTANT: All QML code must be inside `#ifdef QTMCP_HAS_QML` blocks. The existing behavior for non-QML builds must be completely unchanged.
  </action>
  <verify>
    Build with `cmake --build build/ --config Debug 2>&1`. Must compile with zero errors. Run existing tests: `ctest --test-dir build/ --output-on-failure -C Debug`. All 11 existing test suites must pass (QML changes must not break widget-only ID generation).
  </verify>
  <done>
    generateIdSegment() uses QML id as highest priority for QQuickItem subclasses, falls back to short type name for anonymous QML items. serializeObjectInfo() and serializeObjectTree() include isQmlItem, qmlId, qmlFile, qmlTypeName fields for QQuickItems. All 11 existing test suites pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build/ --config Debug` compiles cleanly
2. `ctest --test-dir build/ --output-on-failure -C Debug` — all 11 existing test suites pass
3. `grep -r "QTMCP_HAS_QML" src/probe/` shows compile guards in qml_inspector.h, qml_inspector.cpp, object_id.cpp
4. `grep -r "kModelNotFound\|kQmlNotAvailable" src/probe/api/error_codes.h` shows new error codes
</verification>

<success_criteria>
- QML inspector infrastructure compiles and is properly guarded behind QTMCP_HAS_QML
- Object ID generation uses QML id > objectName > shortTypeName > className priority for QQuickItems
- Tree serialization includes QML metadata fields (isQmlItem, qmlId, qmlFile, qmlTypeName)
- CMake correctly handles missing Qt Quick (graceful degradation, not build failure)
- All 11 existing test suites pass with zero regressions
- Error codes added for QML (-32080s) and Model (-32090s) domains
</success_criteria>

<output>
After completion, create `.planning/phases/06-extended-introspection/06-01-SUMMARY.md`
</output>
