---
phase: 06-extended-introspection
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/probe/api/native_mode_api.h
  - src/probe/api/native_mode_api.cpp
autonomous: true

must_haves:
  truths:
    - "Agent can call qt.models.list to discover all QAbstractItemModel instances"
    - "Agent can call qt.models.info to get model metadata (rows, columns, roles)"
    - "Agent can call qt.models.data to fetch model data with pagination and role filtering"
    - "Agent can pass a view objectId to qt.models.* and it auto-resolves to the underlying model"
    - "Agent can call qt.qml.inspect to get QML metadata for any object (qmlId, qmlFile, isQmlItem)"
    - "All new methods use ResponseEnvelope wrapping and ErrorCode constants"
  artifacts:
    - path: "src/probe/api/native_mode_api.h"
      provides: "registerQmlMethods() and registerModelMethods() declarations"
    - path: "src/probe/api/native_mode_api.cpp"
      provides: "qt.qml.inspect, qt.models.list, qt.models.info, qt.models.data method implementations"
  key_links:
    - from: "src/probe/api/native_mode_api.cpp"
      to: "src/probe/introspection/model_navigator.h"
      via: "ModelNavigator static methods called from qt.models.* handlers"
      pattern: "ModelNavigator"
    - from: "src/probe/api/native_mode_api.cpp"
      to: "src/probe/introspection/qml_inspector.h"
      via: "inspectQmlItem() called from qt.qml.inspect handler"
      pattern: "inspectQmlItem"
    - from: "src/probe/api/native_mode_api.cpp"
      to: "src/probe/api/response_envelope.h"
      via: "ResponseEnvelope::wrap() on all new method responses"
      pattern: "ResponseEnvelope::wrap"
---

<objective>
Wire QML and Model/View introspection into the NativeModeApi by adding new qt.qml.* and qt.models.* JSON-RPC methods.

Purpose: This is the API surface that agents actually call. Without these methods, the QmlInspector and ModelNavigator infrastructure from Plans 01 and 02 are unreachable. This plan completes the agent-facing API.

Output: 4+ new qt.* methods registered on JsonRpcHandler, all with proper error handling, response wrapping, and parameter validation.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-extended-introspection/06-CONTEXT.md
@.planning/phases/06-extended-introspection/06-RESEARCH.md
@.planning/phases/06-extended-introspection/06-01-SUMMARY.md
@.planning/phases/06-extended-introspection/06-02-SUMMARY.md
@src/probe/api/native_mode_api.h
@src/probe/api/native_mode_api.cpp
@src/probe/api/error_codes.h
@src/probe/api/response_envelope.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add qt.qml.inspect Method</name>
  <files>
    src/probe/api/native_mode_api.h
    src/probe/api/native_mode_api.cpp
  </files>
  <action>
    **native_mode_api.h:** Add `void registerQmlMethods();` to the private section.

    **native_mode_api.cpp:**
    1. Add `#include "introspection/qml_inspector.h"` at the top.
    2. Call `registerQmlMethods()` in the constructor.
    3. Implement `registerQmlMethods()`:

    Register `qt.qml.inspect`:
    - Params: `{ "objectId": string }` (required)
    - Resolve object via `resolveObjectParam(params)` (existing helper)
    - Call `inspectQmlItem(obj)` to get QmlItemInfo
    - If `!qmlInfo.isQmlItem`:
      - If QTMCP_HAS_QML is not defined: throw JsonRpcException with kQmlNotAvailable, "QML support not compiled (Qt Quick not found)"
      - If defined but not a QML item: return result with `isQmlItem: false` (not an error — just info)
    - If isQmlItem: return JSON with isQmlItem, qmlId, qmlFile, qmlTypeName
    - Wrap with ResponseEnvelope::wrap()

    NOTE: The QML metadata is ALREADY included in qt.objects.getTree and qt.objects.getInfo via the serializeObjectInfo/serializeObjectTree changes from Plan 01. The qt.qml.inspect method provides a dedicated way to query QML-specific metadata for a single object.
  </action>
  <verify>
    Build with `cmake --build build/ --config Debug 2>&1`. Must compile cleanly.
  </verify>
  <done>
    qt.qml.inspect registered on JsonRpcHandler. Returns QML metadata for any object, or isQmlItem:false for non-QML objects.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add qt.models.* Methods</name>
  <files>
    src/probe/api/native_mode_api.h
    src/probe/api/native_mode_api.cpp
  </files>
  <action>
    **native_mode_api.h:** Add `void registerModelMethods();` to the private section.

    **native_mode_api.cpp:**
    1. Add `#include "introspection/model_navigator.h"` at the top.
    2. Call `registerModelMethods()` in the constructor.
    3. Implement `registerModelMethods()`:

    **qt.models.list:**
    - No required params
    - Call `ModelNavigator::listModels()`
    - Wrap with ResponseEnvelope::wrap()

    **qt.models.info:**
    - Params: `{ "objectId": string }` (required)
    - Resolve object via resolveObjectParam(params)
    - Call `ModelNavigator::resolveModel(obj)` — this handles both model and view objectIds
    - If nullptr: throw JsonRpcException with kNotAModel, "Object is not a model and does not have an associated model"
    - Call `ModelNavigator::getModelInfo(model)`
    - Wrap with ResponseEnvelope::wrap()

    **qt.models.data:**
    - Params: `{ "objectId": string, "offset"?: int, "limit"?: int, "roles"?: array<string|int>, "parentRow"?: int, "parentCol"?: int }`
    - Resolve object, then model via resolveModel()
    - If nullptr: throw JsonRpcException with kNotAModel
    - Parse optional params with defaults: offset=0, limit=-1, parentRow=-1, parentCol=0
    - Resolve role params: if roles array contains strings, resolve each via ModelNavigator::resolveRoleName(). If contains ints, use directly. If role name not found, throw JsonRpcException with kModelRoleNotFound.
    - Validate parentRow/parentCol if specified: check against model->rowCount()/columnCount()
    - Call `ModelNavigator::getModelData(model, offset, limit, resolvedRoles, parentRow, parentCol)`
    - If offset >= totalRows and totalRows > 0: throw JsonRpcException with kModelIndexOutOfBounds
    - Wrap with ResponseEnvelope::wrap()

    Follow EXACT same patterns as existing qt.* methods:
    - Use anonymous namespace helpers (resolveObjectParam, resolveWidgetParam)
    - Use JsonRpcException for errors with ErrorCode constants
    - Use ResponseEnvelope::wrap() for all responses
    - Register via m_handler->registerMethod("qt.models.list", [this](const QJsonObject& params) { ... })
  </action>
  <verify>
    Build with `cmake --build build/ --config Debug 2>&1`. Must compile cleanly. Run `ctest --test-dir build/ --output-on-failure -C Debug` — all 11 existing test suites pass.
  </verify>
  <done>
    qt.models.list, qt.models.info, qt.models.data registered on JsonRpcHandler. Model discovery, info retrieval, and paginated data fetch all work through the API. View-to-model auto-resolution works. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build/ --config Debug` compiles cleanly
2. `ctest --test-dir build/ --output-on-failure -C Debug` — all 11 existing test suites pass
3. `grep -c "registerMethod.*qt\\.models\\|registerMethod.*qt\\.qml" src/probe/api/native_mode_api.cpp` shows 4 new method registrations
4. New methods use ResponseEnvelope::wrap() and ErrorCode constants
</verification>

<success_criteria>
- qt.qml.inspect returns QML metadata or isQmlItem:false for non-QML objects
- qt.models.list discovers and returns all QAbstractItemModel instances
- qt.models.info returns model metadata (rows, cols, roles)
- qt.models.data returns paginated model data with role filtering
- View objectIds auto-resolve to their model in all qt.models.* methods
- All methods follow existing NativeModeApi patterns (error handling, response wrapping)
- All 11 existing test suites pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-extended-introspection/06-03-SUMMARY.md`
</output>
