---
phase: 07-python-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python/pyproject.toml
  - python/src/qtmcp/__init__.py
  - python/src/qtmcp/__main__.py
  - python/src/qtmcp/cli.py
  - python/src/qtmcp/connection.py
  - python/src/qtmcp/server.py
  - python/src/qtmcp/status.py
  - python/src/qtmcp/tools/__init__.py
autonomous: true

must_haves:
  truths:
    - "ProbeConnection can send JSON-RPC requests over WebSocket and correlate responses by ID"
    - "ProbeConnection handles disconnection gracefully and tracks connection state"
    - "Server factory creates a FastMCP server with lifespan-managed WebSocket connection"
    - "CLI parses --mode, --ws-url, --target, --port, --launcher-path arguments"
    - "Status resource exposes probe connection state at qtmcp://status"
    - "python -m qtmcp --help shows usage without errors"
  artifacts:
    - path: "python/pyproject.toml"
      provides: "Package metadata, dependencies (fastmcp<3, websockets), CLI entry point"
    - path: "python/src/qtmcp/connection.py"
      provides: "ProbeConnection class with connect/disconnect/call/is_connected"
    - path: "python/src/qtmcp/server.py"
      provides: "create_server(mode, ws_url, ...) factory function"
    - path: "python/src/qtmcp/cli.py"
      provides: "main() entry point with argparse"
    - path: "python/src/qtmcp/status.py"
      provides: "register_status_resource(mcp, conn) function"
  key_links:
    - from: "python/src/qtmcp/cli.py"
      to: "python/src/qtmcp/server.py"
      via: "cli calls create_server() with parsed args"
      pattern: "create_server"
    - from: "python/src/qtmcp/server.py"
      to: "python/src/qtmcp/connection.py"
      via: "lifespan creates ProbeConnection and yields it"
      pattern: "ProbeConnection"
    - from: "python/src/qtmcp/__main__.py"
      to: "python/src/qtmcp/cli.py"
      via: "python -m qtmcp delegates to cli.main()"
      pattern: "from.*cli.*import.*main"
---

<objective>
Create the Python package skeleton and core infrastructure: ProbeConnection (WebSocket + JSON-RPC client), FastMCP server factory with lifespan pattern, CLI entry point with argparse, and status resource.

Purpose: This is the foundation that all tool definitions depend on. The connection class handles all probe communication, the server factory creates mode-specific FastMCP instances, and the CLI wires everything together.

Output: Complete `python/src/qtmcp/` package that can be installed and run (with no tools registered yet). `python -m qtmcp --help` works.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-python-integration/07-CONTEXT.md
@.planning/phases/07-python-integration/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Package skeleton + CLI + Connection class</name>
  <files>
    python/pyproject.toml
    python/src/qtmcp/__init__.py
    python/src/qtmcp/__main__.py
    python/src/qtmcp/cli.py
    python/src/qtmcp/connection.py
    python/src/qtmcp/tools/__init__.py
  </files>
  <action>
    **python/pyproject.toml:**
    ```toml
    [project]
    name = "qtmcp"
    version = "0.1.0"
    description = "MCP server for controlling Qt applications via QtMCP probe"
    requires-python = ">=3.11"
    dependencies = [
        "fastmcp>=2.0,<3",
        "websockets>=14.0",
    ]

    [project.scripts]
    qtmcp = "qtmcp.cli:main"

    [build-system]
    requires = ["hatchling"]
    build-backend = "hatchling.build"
    ```

    **python/src/qtmcp/__init__.py:**
    ```python
    """QtMCP - MCP server for controlling Qt applications."""
    __version__ = "0.1.0"
    ```

    **python/src/qtmcp/__main__.py:**
    ```python
    from qtmcp.cli import main
    main()
    ```

    **python/src/qtmcp/tools/__init__.py:** Empty file.

    **python/src/qtmcp/connection.py:**
    Create `ProbeConnection` class with:
    - `__init__(self, ws_url: str)` — stores URL, initializes `_ws = None`, `_next_id = 1`, `_pending: dict[int, asyncio.Future] = {}`, `_recv_task = None`, `_connected = False`
    - `async connect(self)` — connects via `websockets.asyncio.client.connect(self._ws_url)`, starts `_recv_loop` as background task, sets `_connected = True`
    - `async disconnect(self)` — cancels recv task, closes WebSocket, sets `_connected = False`, resolves all pending futures with ConnectionError
    - `@property is_connected(self) -> bool` — returns `_connected`
    - `@property ws_url(self) -> str` — returns `_ws_url`
    - `async call(self, method: str, params: dict) -> dict` — assigns sequential ID, sends JSON-RPC 2.0 request `{"jsonrpc":"2.0","method":method,"params":params,"id":N}`, creates Future, waits for response, returns result dict. If not connected, raise `ProbeError("Not connected to probe")`
    - `async _recv_loop(self)` — iterates over incoming WebSocket messages. For messages with `"id"` matching a pending future: if `"error"` in msg, set exception as `ProbeError`; else set result to `msg["result"]`. Ignore notifications (messages without `"id"` or with unmatched id). On WebSocket close, set `_connected = False` and cancel all pending futures.
    - Class `ProbeError(Exception)` with `code`, `message`, `data` fields — constructed from JSON-RPC error objects.

    IMPORTANT: Never print() or log to stdout. Use `logging` module with stderr handler only. Import logging at module level: `logger = logging.getLogger(__name__)`. Log connection events at DEBUG level.

    **python/src/qtmcp/cli.py:**
    Create `main()` function with argparse:
    - `--mode` (required, choices=["native", "cu", "chrome"]) — which API mode to expose
    - `--ws-url` (optional, default from QTMCP_WS_URL env or "ws://localhost:9222") — WebSocket URL to connect to
    - `--target` (optional) — path to Qt application exe to auto-launch
    - `--port` (optional, type=int, default from QTMCP_PORT env or 9222) — port for auto-launched probe
    - `--launcher-path` (optional, default from QTMCP_LAUNCHER env) — path to qtmcp-launch executable

    Main function logic:
    1. Parse args
    2. If `--target` provided, construct ws_url from port (ws://localhost:{port})
    3. Import `create_server` from `qtmcp.server`
    4. Call `server = create_server(mode=args.mode, ws_url=ws_url, target=args.target, port=args.port, launcher_path=args.launcher_path)`
    5. Call `server.run()` (FastMCP's run method handles stdio transport)

    Use `logging.basicConfig(level=logging.DEBUG, stream=sys.stderr)` at the start of main().
  </action>
  <verify>
    From the `python/` directory, run `python -c "from qtmcp.cli import main; print('import OK')"` (with PYTHONPATH=src). Verify `python -m qtmcp --help` shows usage with --mode, --ws-url, --target, --port, --launcher-path options. No stdout pollution (only argparse help output).
  </verify>
  <done>
    Package structure exists with pyproject.toml, __init__.py, __main__.py, cli.py, connection.py. CLI shows help with all expected arguments. ProbeConnection class has connect/disconnect/call/is_connected interface. ProbeError exception class defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Server factory + Status resource</name>
  <files>
    python/src/qtmcp/server.py
    python/src/qtmcp/status.py
  </files>
  <action>
    **python/src/qtmcp/server.py:**
    Create `create_server()` function:
    ```python
    def create_server(mode: str, ws_url: str, target: str | None = None,
                      port: int = 9222, launcher_path: str | None = None) -> FastMCP:
    ```

    Implementation:
    1. Define lifespan using `@lifespan` decorator from `fastmcp.server.lifespan`:
       - If `target` is provided:
         a. Resolve launcher path: `launcher_path` arg > `QTMCP_LAUNCHER` env > `"qtmcp-launch"` (on PATH)
         b. Launch subprocess: `asyncio.create_subprocess_exec(launcher, target, "--port", str(port), stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)`
         c. Wait briefly (1-2 seconds) for probe to start
         d. Construct ws_url = f"ws://localhost:{port}"
       - Create `ProbeConnection(ws_url)` and call `await conn.connect()`
       - Wrap in try/finally: `yield {"probe": conn}` in try, `await conn.disconnect()` in finally
       - If target subprocess exists, terminate it in finally block
    2. Create `FastMCP(f"QtMCP {mode.title()}", lifespan=lifespan_fn)`
    3. Based on mode, import and call the appropriate tool registration function:
       - "native" -> `from qtmcp.tools.native import register_native_tools; register_native_tools(mcp)`
       - "cu" -> `from qtmcp.tools.cu import register_cu_tools; register_cu_tools(mcp)`
       - "chrome" -> `from qtmcp.tools.chrome import register_chrome_tools; register_chrome_tools(mcp)`
    4. Call `register_status_resource(mcp)` from status module
    5. Return the FastMCP instance

    Note: The tool registration imports will fail until Plan 02/03 create the tool files. That's OK -- this plan establishes the factory pattern. Create placeholder register functions in tools/__init__.py or handle ImportError gracefully.

    Actually, to make this plan self-contained: create stub register functions in each tools file that do nothing. Plan 02 and 03 will replace the stubs with real tools.

    Create these stub files:
    - `python/src/qtmcp/tools/native.py`: `def register_native_tools(mcp): pass`
    - `python/src/qtmcp/tools/cu.py`: `def register_cu_tools(mcp): pass`
    - `python/src/qtmcp/tools/chrome.py`: `def register_chrome_tools(mcp): pass`

    **python/src/qtmcp/status.py:**
    Create `register_status_resource(mcp)` function:
    - Registers a resource at `"qtmcp://status"` using `@mcp.resource("qtmcp://status")`
    - The resource handler gets `probe` from `ctx.lifespan_context["probe"]`
    - Returns JSON string with: `connected` (bool), `ws_url` (str), `mode` (str from server name)

    IMPORTANT: Never print to stdout. All logging to stderr via logging module.
  </action>
  <verify>
    Run `python -c "from qtmcp.server import create_server; print('server import OK')"` and `python -c "from qtmcp.status import register_status_resource; print('status import OK')"` (with PYTHONPATH=python/src). Both imports succeed. `python -m qtmcp --help` still works.
  </verify>
  <done>
    create_server() factory creates FastMCP instance with lifespan, registers mode-specific tools (stubs for now), and wires status resource. Status resource returns connection state. Auto-launch subprocess management implemented for --target mode. Stub tool registration files exist for native, cu, chrome.
  </done>
</task>

</tasks>

<verification>
1. `cd python && python -m qtmcp --help` — shows all CLI args (--mode, --ws-url, --target, --port, --launcher-path)
2. `python -c "from qtmcp.connection import ProbeConnection, ProbeError"` — imports succeed
3. `python -c "from qtmcp.server import create_server"` — import succeeds
4. `python -c "from qtmcp.status import register_status_resource"` — import succeeds
5. No print() statements in any source file (grep confirms)
</verification>

<success_criteria>
- Complete package structure under python/src/qtmcp/
- pyproject.toml with correct dependencies and entry point
- ProbeConnection class with async connect/disconnect/call interface
- create_server() factory with lifespan pattern and auto-launch support
- CLI with all arguments parsed
- Status resource registered
- Stub tool registration files ready for Plans 02 and 03
- No stdout pollution — all logging to stderr
</success_criteria>

<output>
After completion, create `.planning/phases/07-python-integration/07-01-SUMMARY.md`
</output>
