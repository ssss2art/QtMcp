---
phase: 07-python-integration
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - python/src/qtmcp/tools/native.py
  - python/src/qtmcp/tools/cu.py
  - python/src/qtmcp/tools/chrome.py
autonomous: true

must_haves:
  truths:
    - "Native mode exposes ~33 qt_* tools matching all qt.* JSON-RPC methods on the probe"
    - "Computer Use mode exposes 13 cu_* tools matching all cu.* JSON-RPC methods on the probe"
    - "Chrome mode exposes 8 chr_* tools matching all chr.* JSON-RPC methods on the probe"
    - "Every tool is async, gets ProbeConnection from ctx.lifespan_context, and calls probe.call()"
    - "Tool descriptions are minimal (1-2 sentences + 1 example per tool)"
    - "Optional parameters use None defaults and are excluded from JSON-RPC params when not provided"
  artifacts:
    - path: "python/src/qtmcp/tools/native.py"
      provides: "register_native_tools(mcp) with ~33 @mcp.tool functions"
    - path: "python/src/qtmcp/tools/cu.py"
      provides: "register_cu_tools(mcp) with 13 @mcp.tool functions"
    - path: "python/src/qtmcp/tools/chrome.py"
      provides: "register_chrome_tools(mcp) with 8 @mcp.tool functions"
  key_links:
    - from: "python/src/qtmcp/tools/native.py"
      to: "python/src/qtmcp/connection.py"
      via: "each tool calls probe.call('qt.*', params)"
      pattern: "probe\\.call.*qt\\."
    - from: "python/src/qtmcp/tools/cu.py"
      to: "python/src/qtmcp/connection.py"
      via: "each tool calls probe.call('cu.*', params)"
      pattern: "probe\\.call.*cu\\."
    - from: "python/src/qtmcp/tools/chrome.py"
      to: "python/src/qtmcp/connection.py"
      via: "each tool calls probe.call('chr.*', params)"
      pattern: "probe\\.call.*chr\\."
---

<objective>
Implement all MCP tool definitions for all three API modes: Native (~33 tools), Computer Use (13 tools), and Chrome (8 tools). Each tool is a thin async bridge that forwards parameters to the probe via JSON-RPC.

Purpose: This plan delivers the complete tool surface that Claude uses to control Qt applications. Each tool maps 1:1 to a probe JSON-RPC method.

Output: Three complete tool files replacing the stubs from Plan 01. All ~54 tools registered.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-python-integration/07-CONTEXT.md
@.planning/phases/07-python-integration/07-RESEARCH.md
@.planning/phases/07-python-integration/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Native mode tools (~33 qt_* functions)</name>
  <files>python/src/qtmcp/tools/native.py</files>
  <action>
    Replace the stub in `python/src/qtmcp/tools/native.py` with a complete `register_native_tools(mcp)` function that registers all ~33 Native mode tools.

    **Pattern for every tool:**
    ```python
    @mcp.tool
    async def qt_tool_name(param1: type, param2: type | None = None, ctx: Context = None) -> dict:
        """One-line description.
        Example: qt_tool_name(param1="value")
        """
        probe = ctx.lifespan_context["probe"]
        params = {"param1": param1}
        if param2 is not None:
            params["param2"] = param2
        return await probe.call("qt.method.name", params)
    ```

    **Important conventions:**
    - Import `from fastmcp import Context` at top
    - All functions are `async`
    - Optional params default to `None` and are only included in the JSON-RPC params dict when provided
    - Tool names use underscores: `qt_objects_find` (not `qt.objects.find`)
    - Descriptions: 1 sentence + 1 example. Keep minimal to reduce Claude's tool context overhead.
    - Return type is always `dict` (raw JSON-RPC result from probe)

    **Complete tool list (from RESEARCH.md tool inventory):**

    1. `qt_ping()` -> `qt.ping` — no params
    2. `qt_version()` -> `qt.version` — no params
    3. `qt_modes()` -> `qt.modes` — no params
    4. `qt_objects_find(name: str, root: str | None = None)` -> `qt.objects.find`
    5. `qt_objects_findByClass(className: str, root: str | None = None)` -> `qt.objects.findByClass`
    6. `qt_objects_tree(root: str | None = None, maxDepth: int | None = None)` -> `qt.objects.tree`
    7. `qt_objects_info(objectId: str)` -> `qt.objects.info`
    8. `qt_objects_inspect(objectId: str)` -> `qt.objects.inspect`
    9. `qt_objects_query(className: str | None = None, properties: dict | None = None, root: str | None = None)` -> `qt.objects.query`
    10. `qt_properties_list(objectId: str)` -> `qt.properties.list`
    11. `qt_properties_get(objectId: str, name: str)` -> `qt.properties.get`
    12. `qt_properties_set(objectId: str, name: str, value: str | int | float | bool)` -> `qt.properties.set`
    13. `qt_methods_list(objectId: str)` -> `qt.methods.list`
    14. `qt_methods_invoke(objectId: str, method: str, args: list | None = None)` -> `qt.methods.invoke`
    15. `qt_signals_list(objectId: str)` -> `qt.signals.list`
    16. `qt_signals_subscribe(objectId: str, signal: str)` -> `qt.signals.subscribe`
    17. `qt_signals_unsubscribe(subscriptionId: str)` -> `qt.signals.unsubscribe`
    18. `qt_signals_setLifecycle(enabled: bool)` -> `qt.signals.setLifecycle`
    19. `qt_ui_click(objectId: str, button: str | None = None, position: dict | None = None)` -> `qt.ui.click`
    20. `qt_ui_sendKeys(objectId: str, text: str | None = None, sequence: str | None = None)` -> `qt.ui.sendKeys`
    21. `qt_ui_screenshot(objectId: str, fullWindow: bool | None = None, region: dict | None = None)` -> `qt.ui.screenshot`
    22. `qt_ui_geometry(objectId: str)` -> `qt.ui.geometry`
    23. `qt_ui_hitTest(x: int, y: int)` -> `qt.ui.hitTest`
    24. `qt_names_register(name: str, path: str)` -> `qt.names.register`
    25. `qt_names_unregister(name: str)` -> `qt.names.unregister`
    26. `qt_names_list()` -> `qt.names.list` — no params
    27. `qt_names_validate()` -> `qt.names.validate` — no params
    28. `qt_names_load(filePath: str)` -> `qt.names.load`
    29. `qt_qml_inspect(objectId: str)` -> `qt.qml.inspect`
    30. `qt_models_list()` -> `qt.models.list` — no params
    31. `qt_models_info(objectId: str)` -> `qt.models.info`
    32. `qt_models_data(objectId: str, row: int | None = None, column: int | None = None, role: str | int | None = None, offset: int | None = None, limit: int | None = None)` -> `qt.models.data`

    The `register_native_tools(mcp)` function defines all tool functions inside it (closure over `mcp`). This is how FastMCP works with dynamic registration.

    IMPORTANT: Do NOT use `@mcp.tool` directly since `mcp` is a parameter. Instead, define each function and register it:
    ```python
    def register_native_tools(mcp):
        @mcp.tool
        async def qt_ping(ctx: Context = None) -> dict:
            ...
        # ... all tools defined inside register_native_tools
    ```
  </action>
  <verify>
    Run `python -c "from qtmcp.tools.native import register_native_tools; print('native import OK')"` (PYTHONPATH=python/src). Verify with: `python -c "import ast; tree = ast.parse(open('python/src/qtmcp/tools/native.py').read()); funcs = [n.name for n in ast.walk(tree) if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))]; print(f'{len(funcs)} functions found'); assert len(funcs) >= 33, f'Expected >= 33, got {len(funcs)}'"`.
  </verify>
  <done>
    native.py contains register_native_tools() with ~33 @mcp.tool async functions, each mapping to the corresponding qt.* JSON-RPC method. All optional params handled with None defaults. Descriptions are minimal (1 sentence + example).
  </done>
</task>

<task type="auto">
  <name>Task 2: Computer Use + Chrome mode tools (21 functions)</name>
  <files>
    python/src/qtmcp/tools/cu.py
    python/src/qtmcp/tools/chrome.py
  </files>
  <action>
    **python/src/qtmcp/tools/cu.py:**
    Replace stub with `register_cu_tools(mcp)` containing 13 tool functions:

    1. `cu_screenshot()` -> `cu.screenshot` — no params
    2. `cu_leftClick(x: int, y: int, screenAbsolute: bool | None = None, delay_ms: int | None = None)` -> `cu.leftClick`
    3. `cu_rightClick(x: int, y: int, screenAbsolute: bool | None = None, delay_ms: int | None = None)` -> `cu.rightClick`
    4. `cu_middleClick(x: int, y: int, screenAbsolute: bool | None = None, delay_ms: int | None = None)` -> `cu.middleClick`
    5. `cu_doubleClick(x: int, y: int, screenAbsolute: bool | None = None, delay_ms: int | None = None)` -> `cu.doubleClick`
    6. `cu_mouseMove(x: int, y: int, screenAbsolute: bool | None = None)` -> `cu.mouseMove`
    7. `cu_mouseDrag(startX: int, startY: int, endX: int, endY: int, screenAbsolute: bool | None = None)` -> `cu.mouseDrag`
    8. `cu_mouseDown(x: int, y: int, button: str | None = None, screenAbsolute: bool | None = None)` -> `cu.mouseDown`
    9. `cu_mouseUp(x: int, y: int, button: str | None = None, screenAbsolute: bool | None = None)` -> `cu.mouseUp`
    10. `cu_type(text: str)` -> `cu.type`
    11. `cu_key(key: str)` -> `cu.key`
    12. `cu_scroll(x: int, y: int, direction: str, amount: int | None = None, screenAbsolute: bool | None = None)` -> `cu.scroll`
    13. `cu_cursorPosition()` -> `cu.cursorPosition` — no params

    Same pattern as native tools: async, Context, probe.call(), optional params excluded when None.

    **python/src/qtmcp/tools/chrome.py:**
    Replace stub with `register_chrome_tools(mcp)` containing 8 tool functions:

    1. `chr_readPage(filter: str | None = None, maxDepth: int | None = None)` -> `chr.readPage`
    2. `chr_click(ref: str)` -> `chr.click`
    3. `chr_formInput(ref: str, value: str | int | float | bool)` -> `chr.formInput`
    4. `chr_getPageText()` -> `chr.getPageText` — no params
    5. `chr_find(query: str)` -> `chr.find`
    6. `chr_navigate(ref: str)` -> `chr.navigate`
    7. `chr_tabsContext()` -> `chr.tabsContext` — no params
    8. `chr_readConsoleMessages(limit: int | None = None, pattern: str | None = None, clear: bool | None = None)` -> `chr.readConsoleMessages`

    Same thin bridge pattern. Same conventions.

    IMPORTANT: Both files use the same pattern as native.py — `register_*_tools(mcp)` defines all `@mcp.tool` functions inside it. Never print to stdout.
  </action>
  <verify>
    Run import checks: `python -c "from qtmcp.tools.cu import register_cu_tools; print('cu OK')"` and `python -c "from qtmcp.tools.chrome import register_chrome_tools; print('chrome OK')"` (PYTHONPATH=python/src). Count functions with ast module to verify 13 cu tools and 8 chrome tools.
  </verify>
  <done>
    cu.py has register_cu_tools() with 13 cu_* tools. chrome.py has register_chrome_tools() with 8 chr_* tools. All tools follow thin bridge pattern: async, gets probe from context, calls probe.call(), returns result. Total of 54+ tools across all three modes.
  </done>
</task>

</tasks>

<verification>
1. All three tool files import successfully
2. Native: >= 33 async tool functions defined
3. CU: 13 async tool functions defined
4. Chrome: 8 async tool functions defined
5. Every tool function has `ctx: Context = None` parameter
6. Every tool function calls `probe.call()` with correct JSON-RPC method name
7. No print() statements in any tool file
8. Tool descriptions are concise (not verbose)
</verification>

<success_criteria>
- All ~54 MCP tools implemented across three files
- Each tool maps 1:1 to a probe JSON-RPC method
- Optional parameters properly handled (None defaults, excluded when not provided)
- Tool descriptions minimal (1-2 sentences + 1 example each)
- All files import without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-python-integration/07-02-SUMMARY.md`
</output>
