---
phase: 07-python-integration
plan: 03
type: execute
wave: 3
depends_on: ["07-01", "07-02"]
files_modified:
  - python/README.md
  - python/tests/conftest.py
  - python/tests/test_connection.py
  - python/tests/test_tools.py
autonomous: true

must_haves:
  truths:
    - "README contains copy-paste Claude Desktop config for all three modes (native, cu, chrome)"
    - "README contains Claude Code config command for all three modes"
    - "README shows both connect-to-running and auto-launch config patterns"
    - "README documents Windows cmd /c wrapper pattern for Claude Desktop"
    - "Unit tests verify ProbeConnection JSON-RPC message format and response correlation"
    - "Unit tests verify tool functions send correct JSON-RPC method names"
  artifacts:
    - path: "python/README.md"
      provides: "Installation, config snippets for Claude Desktop/Code, mode descriptions"
    - path: "python/tests/conftest.py"
      provides: "Mock WebSocket fixtures for unit testing"
    - path: "python/tests/test_connection.py"
      provides: "ProbeConnection unit tests"
    - path: "python/tests/test_tools.py"
      provides: "Tool registration and method mapping tests"
  key_links:
    - from: "python/tests/conftest.py"
      to: "python/src/qtmcp/connection.py"
      via: "MockProbeConnection replaces real WebSocket for testing"
      pattern: "Mock|mock|ProbeConnection"
    - from: "python/README.md"
      to: "python/src/qtmcp/cli.py"
      via: "Config snippets reference CLI args (--mode, --ws-url, --target)"
      pattern: "--mode|--ws-url|--target"
---

<objective>
Create README with Claude configuration snippets and unit tests for the connection and tool layers.

Purpose: README enables users to immediately configure Claude Desktop or Claude Code to use QtMCP. Unit tests verify the JSON-RPC bridge works correctly without needing a running Qt application.

Output: Complete README.md and test suite.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-python-integration/07-CONTEXT.md
@.planning/phases/07-python-integration/07-RESEARCH.md
@.planning/phases/07-python-integration/07-01-SUMMARY.md
@.planning/phases/07-python-integration/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: README with configuration snippets</name>
  <files>python/README.md</files>
  <action>
    Create `python/README.md` with these sections:

    **1. Header + Overview:**
    - Title: "QtMCP Python Server"
    - One paragraph: MCP server that bridges Claude to Qt applications via the QtMCP probe. Supports three modes: Native (full Qt introspection), Computer Use (screenshot + coordinates), Chrome (accessibility tree + refs).

    **2. Installation:**
    - `pip install .` from the python/ directory
    - Or with uv: `uv pip install .`

    **3. Quick Start:**
    - Show the simplest usage: connect to already-running probe
    - `qtmcp --mode native --ws-url ws://localhost:9222`

    **4. Claude Desktop Configuration:**
    For each of the three modes, show complete JSON config blocks:

    a) **Native mode (connect to running probe):**
    ```json
    {
      "mcpServers": {
        "qtmcp-native": {
          "command": "uv",
          "args": ["run", "--with", "fastmcp<3", "--with", "websockets",
                   "python", "-m", "qtmcp", "--mode", "native",
                   "--ws-url", "ws://localhost:9222"]
        }
      }
    }
    ```

    b) **Native mode (auto-launch target app):**
    ```json
    {
      "mcpServers": {
        "qtmcp-native": {
          "command": "uv",
          "args": ["run", "--with", "fastmcp<3", "--with", "websockets",
                   "python", "-m", "qtmcp", "--mode", "native",
                   "--target", "/path/to/your/qt-app"]
        }
      }
    }
    ```

    c) **Computer Use mode:** Same pattern with `--mode cu`

    d) **Chrome mode:** Same pattern with `--mode chrome`

    e) **Windows (Claude Desktop):** Show the cmd /c wrapper:
    ```json
    {
      "mcpServers": {
        "qtmcp-native": {
          "command": "cmd",
          "args": ["/c", "uv", "run", "--with", "fastmcp<3", "--with", "websockets",
                   "python", "-m", "qtmcp", "--mode", "native",
                   "--ws-url", "ws://localhost:9222"]
        }
      }
    }
    ```

    **5. Claude Code Configuration:**
    ```bash
    claude mcp add --transport stdio qtmcp-native -- uv run --with "fastmcp<3" --with websockets python -m qtmcp --mode native --ws-url ws://localhost:9222
    ```
    Show for all three modes.

    **6. CLI Reference:**
    Table of all CLI arguments: --mode, --ws-url, --target, --port, --launcher-path plus QTMCP_WS_URL, QTMCP_PORT, QTMCP_LAUNCHER env vars.

    **7. Mode Descriptions:**
    Brief description of each mode:
    - Native (~33 tools): Full Qt object introspection — find objects, read/write properties, invoke methods, subscribe to signals, take screenshots
    - Computer Use (13 tools): Screenshot-based automation — take screenshot, click at coordinates, type text, scroll
    - Chrome (8 tools): Accessibility tree — read page structure with numbered refs, click refs, fill forms, find elements

    **8. Architecture:**
    Simple ASCII diagram: `Claude <-> stdio <-> QtMCP MCP Server <-> WebSocket <-> Qt Probe (injected in app)`
  </action>
  <verify>
    Verify README.md exists and contains all key sections: grep for "Claude Desktop", "Claude Code", "--mode native", "--mode cu", "--mode chrome", "cmd /c", "--target".
  </verify>
  <done>
    README.md contains complete configuration snippets for Claude Desktop (macOS/Linux + Windows) and Claude Code for all three modes, plus auto-launch patterns, CLI reference, and mode descriptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests with mock WebSocket</name>
  <files>
    python/tests/conftest.py
    python/tests/test_connection.py
    python/tests/test_tools.py
  </files>
  <action>
    **python/tests/conftest.py:**
    Create shared fixtures:
    - `MockWebSocket` class that simulates a WebSocket connection:
      - `sent_messages: list` — records all sent messages
      - `responses: dict[int, dict]` — pre-configured responses keyed by JSON-RPC id
      - `async send(msg)` — records msg in sent_messages, no-op otherwise
      - `async recv()` — returns the matching response for the next pending request
      - `async __aiter__` / `async __anext__` — yields responses
      - `async close()` — no-op
    - `mock_probe` fixture that creates a ProbeConnection with a patched WebSocket (using `unittest.mock.patch` to replace `websockets.asyncio.client.connect`)
    - `mock_mcp` fixture that creates a FastMCP instance for tool registration testing

    **python/tests/test_connection.py:**
    Test ProbeConnection:
    1. `test_call_sends_jsonrpc_format` — verify call() sends `{"jsonrpc":"2.0","method":"qt.ping","params":{},"id":1}`
    2. `test_call_increments_id` — two sequential calls produce id=1 and id=2
    3. `test_call_returns_result` — mock response `{"jsonrpc":"2.0","result":{"ok":true},"id":1}` -> call returns `{"ok":true}`
    4. `test_call_raises_probe_error` — mock error response -> call raises ProbeError with code and message
    5. `test_is_connected_property` — false before connect, true after connect, false after disconnect
    6. `test_call_when_disconnected_raises` — calling when not connected raises ProbeError

    Use `pytest` and `pytest-asyncio` for async tests. Add `pytest` and `pytest-asyncio` as dev dependencies (or just document them; they're not in pyproject.toml runtime deps).

    **python/tests/test_tools.py:**
    Test tool registration and method mapping:
    1. `test_native_tools_registered` — call `register_native_tools(mcp)`, verify mcp has >= 33 tools
    2. `test_cu_tools_registered` — call `register_cu_tools(mcp)`, verify mcp has 13 tools
    3. `test_chrome_tools_registered` — call `register_chrome_tools(mcp)`, verify mcp has 8 tools
    4. `test_native_tool_names` — verify key tool names present: qt_ping, qt_objects_find, qt_properties_get, qt_ui_click, qt_models_list
    5. `test_cu_tool_names` — verify key tool names: cu_screenshot, cu_leftClick, cu_type, cu_scroll
    6. `test_chrome_tool_names` — verify key tool names: chr_readPage, chr_click, chr_find, chr_formInput

    For tool name verification, check the FastMCP server's tool registry (mcp._tool_manager.tools or similar internal API — check FastMCP docs for how to list registered tools).

    Note: These are unit tests that don't require a running probe. They verify structure and wiring, not end-to-end behavior.
  </action>
  <verify>
    Run `cd python && python -m pytest tests/ -v` (with PYTHONPATH=src and pytest/pytest-asyncio installed). All tests pass.
  </verify>
  <done>
    Unit tests verify: ProbeConnection sends correct JSON-RPC format, correlates responses, handles errors, tracks connection state. Tool registration tests verify all three modes register the expected number and names of tools. All tests pass with mock WebSocket (no running probe needed).
  </done>
</task>

</tasks>

<verification>
1. `python/README.md` exists with all config sections
2. `python -m pytest python/tests/ -v` — all tests pass
3. README contains config for all 3 modes x 2 platforms (Desktop + Code)
4. README contains auto-launch config pattern
5. README contains Windows cmd /c pattern
6. Tests verify >= 33 native tools, 13 cu tools, 8 chrome tools registered
</verification>

<success_criteria>
- README enables zero-friction setup: user can copy-paste config into Claude Desktop or Claude Code
- Unit tests pass without a running Qt application
- ProbeConnection message format verified by tests
- Tool count and names verified by tests
- Windows and macOS/Linux configs both documented
</success_criteria>

<output>
After completion, create `.planning/phases/07-python-integration/07-03-SUMMARY.md`
</output>
