---
phase: 08-cmake-multi-qt-foundation
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - cmake/QtMCPConfig.cmake.in
  - cmake/qtmcp_inject_probe.cmake
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "A downstream project using Qt6 can find_package(QtMCP) and link QtMCP::Probe without errors"
    - "A downstream project using Qt5 can find_package(QtMCP) and link QtMCP::Probe without errors"
    - "qtmcp_inject_probe(target) is available after find_package(QtMCP)"
    - "find_package does not require nlohmann_json or spdlog (they are optional internal deps)"
    - "CMake config files use relative paths and are fully relocatable"
  artifacts:
    - path: "cmake/QtMCPConfig.cmake.in"
      provides: "Qt-version-aware package config that auto-detects consumer Qt version"
      contains: "QT_VERSION_MAJOR"
    - path: "cmake/qtmcp_inject_probe.cmake"
      provides: "Helper function for downstream consumers to inject probe into their targets"
      contains: "function(qtmcp_inject_probe"
  key_links:
    - from: "cmake/QtMCPConfig.cmake.in"
      to: "share/cmake/QtMCP/QtMCPTargets.cmake"
      via: "include() of generated targets file"
      pattern: "include.*QtMCPTargets"
    - from: "cmake/QtMCPConfig.cmake.in"
      to: "lib/qtmcp/qt${QT_VERSION_MAJOR}"
      via: "IMPORTED_LOCATION set to versioned path"
      pattern: "qtmcp.*qt"
    - from: "cmake/qtmcp_inject_probe.cmake"
      to: "QtMCP::Probe"
      via: "target_link_libraries in helper function"
      pattern: "QtMCP::Probe"
---

<objective>
Rewrite the CMake package config so that downstream consumers can `find_package(QtMCP)` regardless of whether they use Qt5 or Qt6, and provide a `qtmcp_inject_probe()` helper function for easy integration.

Purpose: BUILD-02 requires the config file to work for both Qt5 and Qt6 consumers. This plan creates the config template that auto-detects the consumer's Qt version and resolves to the correct versioned probe binary. It also creates the helper function that makes integration trivial.

Output: Working `find_package(QtMCP)` integration with `QtMCP::Probe` target and `qtmcp_inject_probe()` helper.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-cmake-multi-qt-foundation/08-CONTEXT.md
@.planning/phases/08-cmake-multi-qt-foundation/08-01-SUMMARY.md
@CMakeLists.txt
@cmake/QtMCPConfig.cmake.in
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite QtMCPConfig.cmake.in for dual Qt version support</name>
  <files>cmake/QtMCPConfig.cmake.in, cmake/qtmcp_inject_probe.cmake</files>
  <action>
**Rewrite `cmake/QtMCPConfig.cmake.in` from scratch:**

The current file hardcodes Qt5 and requires nlohmann_json/spdlog. Replace entirely with:

```cmake
@PACKAGE_INIT@

include(CMakeFindDependencyMacro)

# Detect which Qt version the consumer is using
# The consumer should have already called find_package(Qt6 ...) or find_package(Qt5 ...)
if(TARGET Qt6::Core)
    set(_qtmcp_qt_major 6)
    # Extract minor version
    get_target_property(_qt_version Qt6::Core VERSION)
    if(NOT _qt_version)
        set(_qt_version "${Qt6Core_VERSION}")
    endif()
elseif(TARGET Qt5::Core)
    set(_qtmcp_qt_major 5)
    get_target_property(_qt_version Qt5::Core VERSION)
    if(NOT _qt_version)
        set(_qt_version "${Qt5Core_VERSION}")
    endif()
else()
    # Try finding Qt ourselves
    find_package(Qt6 QUIET COMPONENTS Core)
    if(Qt6_FOUND)
        set(_qtmcp_qt_major 6)
        set(_qt_version "${Qt6_VERSION}")
    else()
        find_package(Qt5 5.15 QUIET COMPONENTS Core)
        if(Qt5_FOUND)
            set(_qtmcp_qt_major 5)
            set(_qt_version "${Qt5_VERSION}")
        else()
            set(QtMCP_FOUND FALSE)
            set(QtMCP_NOT_FOUND_MESSAGE "QtMCP requires Qt5 (5.15+) or Qt6. No Qt found. Call find_package(Qt6) or find_package(Qt5) before find_package(QtMCP).")
            return()
        endif()
    endif()
endif()

# Extract major.minor for versioned path lookup
string(REGEX MATCH "^([0-9]+)\\.([0-9]+)" _qtmcp_qt_version_tag "${_qt_version}")
set(_qtmcp_qt_version_tag "qt${_qtmcp_qt_version_tag}")

# Find Qt dependencies that QtMCP needs (consumer must have these)
if(_qtmcp_qt_major EQUAL 6)
    find_dependency(Qt6 COMPONENTS Core Network WebSockets Widgets)
else()
    find_dependency(Qt5 5.15 COMPONENTS Core Network WebSockets Widgets)
endif()

# Compute paths relative to this config file location
# Config is installed at: <prefix>/share/cmake/QtMCP/QtMCPConfig.cmake
# Libraries are at: <prefix>/lib/qtmcp/<qt-version-tag>/
set_and_check(QTMCP_CMAKE_DIR "${CMAKE_CURRENT_LIST_DIR}")
get_filename_component(QTMCP_PREFIX "${QTMCP_CMAKE_DIR}/../../.." ABSOLUTE)

set(QTMCP_LIB_DIR "${QTMCP_PREFIX}/lib/qtmcp/${_qtmcp_qt_version_tag}")
set(QTMCP_INCLUDE_DIR "${QTMCP_PREFIX}/include/qtmcp")

# Verify the versioned library directory exists
if(NOT EXISTS "${QTMCP_LIB_DIR}")
    set(QtMCP_FOUND FALSE)
    set(QtMCP_NOT_FOUND_MESSAGE "QtMCP was not built for ${_qtmcp_qt_version_tag}. Available builds: [check <prefix>/lib/qtmcp/]")
    return()
endif()

# Create imported target QtMCP::Probe
if(NOT TARGET QtMCP::Probe)
    add_library(QtMCP::Probe SHARED IMPORTED)

    # Set include directories
    set_target_properties(QtMCP::Probe PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${QTMCP_INCLUDE_DIR}"
    )

    # Find the actual library file
    set(_probe_base_name "qtmcp-probe-${_qtmcp_qt_version_tag}")

    if(WIN32)
        # Windows: DLL in lib dir, import lib also in lib dir
        find_file(_probe_dll
            NAMES "${_probe_base_name}.dll"
            PATHS "${QTMCP_LIB_DIR}"
            NO_DEFAULT_PATH
        )
        find_file(_probe_implib
            NAMES "${_probe_base_name}.lib" "${_probe_base_name}.dll.a"
            PATHS "${QTMCP_LIB_DIR}"
            NO_DEFAULT_PATH
        )
        if(_probe_dll)
            set_target_properties(QtMCP::Probe PROPERTIES
                IMPORTED_LOCATION "${_probe_dll}"
                IMPORTED_IMPLIB "${_probe_implib}"
            )
        endif()

        # Debug variant
        find_file(_probe_dll_d
            NAMES "${_probe_base_name}d.dll"
            PATHS "${QTMCP_LIB_DIR}"
            NO_DEFAULT_PATH
        )
        find_file(_probe_implib_d
            NAMES "${_probe_base_name}d.lib" "${_probe_base_name}d.dll.a"
            PATHS "${QTMCP_LIB_DIR}"
            NO_DEFAULT_PATH
        )
        if(_probe_dll_d)
            set_target_properties(QtMCP::Probe PROPERTIES
                IMPORTED_LOCATION_DEBUG "${_probe_dll_d}"
                IMPORTED_IMPLIB_DEBUG "${_probe_implib_d}"
            )
        endif()
    else()
        # Linux: .so in lib dir
        find_file(_probe_so
            NAMES "lib${_probe_base_name}.so"
            PATHS "${QTMCP_LIB_DIR}"
            NO_DEFAULT_PATH
        )
        if(_probe_so)
            set_target_properties(QtMCP::Probe PROPERTIES
                IMPORTED_LOCATION "${_probe_so}"
            )
        endif()

        # Debug variant
        find_file(_probe_so_d
            NAMES "lib${_probe_base_name}d.so"
            PATHS "${QTMCP_LIB_DIR}"
            NO_DEFAULT_PATH
        )
        if(_probe_so_d)
            set_target_properties(QtMCP::Probe PROPERTIES
                IMPORTED_LOCATION_DEBUG "${_probe_so_d}"
            )
        endif()
    endif()

    # Link Qt dependencies on the imported target
    if(_qtmcp_qt_major EQUAL 6)
        set_target_properties(QtMCP::Probe PROPERTIES
            INTERFACE_LINK_LIBRARIES "Qt6::Core;Qt6::Network;Qt6::WebSockets;Qt6::Widgets"
        )
    else()
        set_target_properties(QtMCP::Probe PROPERTIES
            INTERFACE_LINK_LIBRARIES "Qt5::Core;Qt5::Network;Qt5::WebSockets;Qt5::Widgets"
        )
    endif()
endif()

# Include helper functions
include("${CMAKE_CURRENT_LIST_DIR}/qtmcp_inject_probe.cmake")

# Clean up temporary variables
unset(_qtmcp_qt_major)
unset(_qt_version)
unset(_qtmcp_qt_version_tag)
unset(_probe_base_name)
unset(_probe_dll CACHE)
unset(_probe_implib CACHE)
unset(_probe_dll_d CACHE)
unset(_probe_implib_d CACHE)
unset(_probe_so CACHE)
unset(_probe_so_d CACHE)

check_required_components(QtMCP)
```

**Create `cmake/qtmcp_inject_probe.cmake`:**

```cmake
# qtmcp_inject_probe(target)
#
# Helper function to inject the QtMCP probe into a Qt application target.
# After calling this, the probe library will be available at runtime.
#
# On Windows: Copies the probe DLL next to the target executable.
# On Linux: Adds the probe library path for LD_PRELOAD usage.
#
# Usage:
#   find_package(QtMCP REQUIRED)
#   add_executable(myapp main.cpp)
#   qtmcp_inject_probe(myapp)
#
function(qtmcp_inject_probe TARGET_NAME)
    if(NOT TARGET QtMCP::Probe)
        message(FATAL_ERROR "qtmcp_inject_probe: QtMCP::Probe target not found. Call find_package(QtMCP) first.")
    endif()

    # Link the probe library
    target_link_libraries(${TARGET_NAME} PRIVATE QtMCP::Probe)

    # On Windows, copy the probe DLL next to the target executable for runtime
    if(WIN32)
        add_custom_command(TARGET ${TARGET_NAME} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "$<TARGET_FILE:QtMCP::Probe>"
                "$<TARGET_FILE_DIR:${TARGET_NAME}>"
            COMMENT "Copying QtMCP probe DLL for ${TARGET_NAME}"
            VERBATIM
        )
    endif()

    # On Linux, create a helper script for LD_PRELOAD injection
    if(UNIX AND NOT APPLE)
        get_target_property(_probe_location QtMCP::Probe IMPORTED_LOCATION)
        if(_probe_location)
            set(_preload_script "${CMAKE_CURRENT_BINARY_DIR}/qtmcp-preload-${TARGET_NAME}.sh")
            file(GENERATE OUTPUT "${_preload_script}"
                CONTENT "#!/bin/sh\nLD_PRELOAD=$<TARGET_FILE:QtMCP::Probe> exec $<TARGET_FILE:${TARGET_NAME}> \"$@\"\n"
            )
        endif()
    endif()
endfunction()
```

**Important considerations:**
- Do NOT use `include(QtMCPTargets.cmake)` in the config file. Since Plan 01 changed the install layout to versioned subdirs, the standard CMake EXPORT mechanism puts targets in the wrong paths. Instead, create the IMPORTED target manually in the config file using the versioned paths.
- nlohmann_json and spdlog are NOT declared as dependencies (they are optional internal deps, not interface deps).
- The `@PACKAGE_INIT@` macro is still used for relocatable path computation via `set_and_check`.
  </action>
  <verify>
1. Read both files and verify the Qt version detection logic, the IMPORTED target creation, and the helper function are complete
2. Run a configure to make sure the config file template processes without CMake errors:
   `cmake -B build_test -DQTMCP_BUILD_TESTS=OFF -DQTMCP_BUILD_TEST_APP=OFF`
3. Run install: `cmake --install build_test --prefix build_test/install --config Release`
4. Verify `build_test/install/share/cmake/QtMCP/QtMCPConfig.cmake` exists and contains Qt version detection logic
5. Verify `build_test/install/share/cmake/QtMCP/qtmcp_inject_probe.cmake` exists
  </verify>
  <done>
QtMCPConfig.cmake.in auto-detects consumer Qt version, creates QtMCP::Probe imported target pointing to correct versioned binary, and qtmcp_inject_probe() helper function is available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update root CMakeLists.txt install rules for new config approach</name>
  <files>CMakeLists.txt</files>
  <action>
Update the install section at the bottom of root CMakeLists.txt to:

1. **Remove the EXPORT-based install** since we are now creating IMPORTED targets manually in the config file. Remove:
   ```cmake
   install(EXPORT QtMCPTargets ...)
   ```
   And remove the `EXPORT QtMCPTargets` from the `install(TARGETS qtmcp_probe ...)` call. The targets install should just be:
   ```cmake
   install(TARGETS qtmcp_probe
       LIBRARY DESTINATION ${QTMCP_INSTALL_LIBDIR}
       ARCHIVE DESTINATION ${QTMCP_INSTALL_LIBDIR}
       RUNTIME DESTINATION ${QTMCP_INSTALL_LIBDIR}
   )
   ```
   Note: RUNTIME goes to the SAME versioned dir (not bin/) so that the config file can find DLLs in one known location.

2. **Install the launcher** (if built):
   ```cmake
   if(TARGET qtmcp_launcher)
       install(TARGETS qtmcp_launcher
           RUNTIME DESTINATION bin
       )
   endif()
   ```
   The launcher goes to regular bin/ since it is NOT Qt-version-specific in its install location (it is an executable, not a library).

3. **Install the helper cmake module**:
   ```cmake
   install(FILES
       "${CMAKE_CURRENT_SOURCE_DIR}/cmake/qtmcp_inject_probe.cmake"
       DESTINATION share/cmake/QtMCP
   )
   ```

4. **Keep** the header install, version file generation, and config file generation. Update the config file install destination to `share/cmake/QtMCP`:
   ```cmake
   configure_package_config_file(
       "${CMAKE_CURRENT_SOURCE_DIR}/cmake/QtMCPConfig.cmake.in"
       "${CMAKE_CURRENT_BINARY_DIR}/QtMCPConfig.cmake"
       INSTALL_DESTINATION share/cmake/QtMCP
   )

   install(FILES
       "${CMAKE_CURRENT_BINARY_DIR}/QtMCPConfig.cmake"
       "${CMAKE_CURRENT_BINARY_DIR}/QtMCPConfigVersion.cmake"
       DESTINATION share/cmake/QtMCP
   )
   ```

5. **Remove** the old `install(EXPORT QtMCPTargets ...)` line entirely. The QtMCPTargets.cmake file is no longer generated since we build the imported target in the config file itself.

Do NOT change anything above the "# Installation" comment. Only modify the install section.
  </action>
  <verify>
1. Full clean build + install cycle:
   ```
   cmake -B build_final -DQTMCP_BUILD_TESTS=OFF -DQTMCP_BUILD_TEST_APP=OFF
   cmake --build build_final --config Release
   cmake --install build_final --prefix build_final/install --config Release
   ```
2. Verify install tree structure:
   - `install/lib/qtmcp/qt{X}.{Y}/` contains the probe library (DLL or .so)
   - `install/include/qtmcp/` contains header files
   - `install/share/cmake/QtMCP/` contains QtMCPConfig.cmake, QtMCPConfigVersion.cmake, qtmcp_inject_probe.cmake
   - `install/bin/` contains the launcher executable (if built)
3. No QtMCPTargets.cmake should exist (we no longer generate it)
4. Verify the installed QtMCPConfig.cmake has the @PACKAGE_INIT@ expanded (not literal)
  </verify>
  <done>
cmake --install produces complete relocatable install tree: versioned probe in lib/qtmcp/qtX.Y/, headers in include/qtmcp/, CMake config in share/cmake/QtMCP/. BUILD-02 and BUILD-03 fully satisfied.
  </done>
</task>

</tasks>

<verification>
1. Full configure + build + install cycle succeeds
2. Install tree matches the layout defined in CONTEXT.md:
   - `lib/qtmcp/qt{X}.{Y}/` — probe library with versioned name
   - `include/qtmcp/` — headers
   - `share/cmake/QtMCP/` — CMake config files + helper module
3. QtMCPConfig.cmake contains Qt version auto-detection logic
4. qtmcp_inject_probe.cmake is installed alongside config
5. No hardcoded absolute paths in installed CMake files (grep for the build directory path - should find nothing)
6. Existing build targets (tests, test_app) still compile
</verification>

<success_criteria>
- BUILD-02 satisfied: QtMCPConfig.cmake.in works for both Qt5 and Qt6 consumers
- BUILD-03 fully satisfied: versioned, relocatable install layout with all components
- QtMCP::Probe target resolves to correct versioned binary
- qtmcp_inject_probe() helper function available after find_package
- No regression in existing build functionality
</success_criteria>

<output>
After completion, create `.planning/phases/08-cmake-multi-qt-foundation/08-02-SUMMARY.md`
</output>
