---
phase: 10-patched-qt-ci
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/actions/build-qt/action.yml
  - .ci/patches/5.15.1/README.md
autonomous: true

must_haves:
  truths:
    - "A reusable composite action at .github/actions/build-qt/action.yml downloads, patches, builds, installs, and caches Qt from source"
    - "Cache key includes hash of patch files + runner OS + Qt version (no restore-keys for safety)"
    - "All build steps after cache restore are skipped on cache hit"
    - "Patch directory .ci/patches/5.15.1/ exists with a README explaining the convention"
  artifacts:
    - path: ".github/actions/build-qt/action.yml"
      provides: "Reusable composite action for building patched Qt from source"
      contains: "actions/cache@v4"
    - path: ".ci/patches/5.15.1/README.md"
      provides: "Patch directory scaffold with documentation"
      contains: "patch"
  key_links:
    - from: ".github/actions/build-qt/action.yml"
      to: "actions/cache@v4"
      via: "Cache restore/save of Qt install prefix"
      pattern: "actions/cache@v4"
    - from: ".github/actions/build-qt/action.yml"
      to: ".ci/patches/5.15.1/"
      via: "patches-dir input parameter"
      pattern: "patches-dir"
---

<objective>
Create the reusable composite action for building patched Qt from source, plus the patch directory scaffold.

Purpose: Provide a single, cacheable action that both the CI workflow (this phase) and the release workflow (Phase 11) can call to get a patched Qt 5.15.1 installation. The composite action handles download, patch application, configure, build, install, and caching â€” all behind a simple interface.

Output: `.github/actions/build-qt/action.yml` composite action + `.ci/patches/5.15.1/README.md` scaffold.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-patched-qt-ci/10-CONTEXT.md
@.planning/phases/10-patched-qt-ci/10-RESEARCH.md
@CMakePresets.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create patch directory scaffold</name>
  <files>.ci/patches/5.15.1/README.md</files>
  <action>
Create the directory `.ci/patches/5.15.1/` and add a `README.md` explaining the patch convention:

- Patches are named with numeric prefix for ordering: `001-description.patch`, `002-description.patch`, etc.
- Patches are in `git diff` format (generated with `git diff` or `git format-patch`)
- Patches are applied with `git apply` in sorted filename order to the extracted Qt source tree
- The `patch -p1` strip level is assumed (standard for git-generated patches)
- Each patch should have a descriptive commit-style message in the patch header

Also create an empty `.gitkeep` file in the directory so git tracks it even with no patches yet.

The README should note that the cache key for CI is derived from `hashFiles('.ci/patches/5.15.1/**')`, so any change to patches (add/remove/edit) automatically invalidates the cached Qt build.
  </action>
  <verify>
Confirm `.ci/patches/5.15.1/README.md` exists and describes the patch naming convention and cache invalidation behavior.
  </verify>
  <done>Patch directory scaffold created with convention documentation</done>
</task>

<task type="auto">
  <name>Task 2: Create the composite action for building patched Qt</name>
  <files>.github/actions/build-qt/action.yml</files>
  <action>
Create `.github/actions/build-qt/action.yml` as a reusable composite action. This is the core deliverable of this plan.

**Inputs:**
- `qt-version` (required): Qt version string, e.g., "5.15.1"
- `patches-dir` (required): Path to directory containing .patch files relative to workspace, e.g., ".ci/patches/5.15.1"
- `install-prefix` (optional, default: `${{ github.workspace }}/qt-patched`): Where to install Qt

**Outputs:**
- `qt-dir`: Path to installed Qt (same as install-prefix), for use as CMAKE_PREFIX_PATH
- `cache-hit`: Whether the Qt cache was hit ("true"/"false")

**Steps (all use `shell: bash`):**

1. **Set paths** (id: `paths`): Output the qt-dir path. Compute and output a configure-flags constant hash (hardcode a version string like "v1" that gets bumped when configure flags change).

2. **Restore Qt cache** (id: `qt-cache`): Use `actions/cache@v4` with:
   - `path`: The install prefix
   - `key`: `patched-qt-${{ inputs.qt-version }}-${{ runner.os }}-${{ hashFiles(format('{0}/**', inputs.patches-dir)) }}-cfgv1`
   - NO `restore-keys` (partial match would restore wrong/unpatched Qt)

3. **Download Qt source** (if cache miss):
   - Compute download URL from version: `https://download.qt.io/archive/qt/${MAJOR}.${MINOR}/${VERSION}/single/qt-everywhere-src-${VERSION}.tar.xz`
   - Use `curl -L -o qt-src.tar.xz "$URL"` on Linux
   - On Windows, use `.zip` format instead (Windows built-in tar may not handle xz): URL ends with `.zip`
   - Extract: Linux `tar -xf qt-src.tar.xz`, Windows uses `7z x qt-src.zip` (7zip pre-installed on GH runners)
   - Clean up archive after extraction
   - Use platform detection via `$RUNNER_OS` to choose format

4. **Apply patches** (if cache miss):
   - `cd` into extracted source dir (`qt-everywhere-src-${VERSION}`)
   - `git init && git add -A && git commit -m "Qt ${VERSION} base" --quiet`
   - Loop over sorted .patch files in patches-dir: `git apply --verbose "$patch_file"`
   - Fail immediately if any patch fails
   - Log count of applied patches
   - Use `::group::` / `::endgroup::` for GH Actions log folding

5. **Install Linux build dependencies** (if cache miss AND runner.os == Linux):
   ```bash
   sudo apt-get update
   sudo apt-get install -y \
     build-essential perl python3 \
     libgl1-mesa-dev libglu1-mesa-dev \
     libfontconfig1-dev libfreetype6-dev \
     libx11-dev libx11-xcb-dev libxext-dev libxfixes-dev \
     libxi-dev libxrender-dev libxcb1-dev libxcb-glx0-dev \
     libxcb-keysyms1-dev libxcb-image0-dev libxcb-shm0-dev \
     libxcb-icccm4-dev libxcb-sync-dev libxcb-xfixes0-dev \
     libxcb-shape0-dev libxcb-randr0-dev libxcb-render-util0-dev \
     libxcb-xinerama0-dev libxcb-xkb-dev libxcb-cursor0 \
     libxkbcommon-dev libxkbcommon-x11-dev libxtst-dev
   ```

6. **Configure Qt (Linux)** (if cache miss AND runner.os == Linux):
   ```bash
   cd qt-everywhere-src-${VERSION}
   ./configure \
     -prefix ${INSTALL_PREFIX} \
     -opensource -confirm-license \
     -shared -release \
     -nomake examples -nomake tests \
     -skip qt3d -skip qtactiveqt -skip qtandroidextras \
     -skip qtcanvas3d -skip qtcharts -skip qtconnectivity \
     -skip qtdatavis3d -skip qtdoc -skip qtgamepad \
     -skip qtgraphicaleffects -skip qtimageformats -skip qtlocation \
     -skip qtlottie -skip qtmacextras -skip qtmultimedia \
     -skip qtnetworkauth -skip qtpurchasing -skip qtquick3d \
     -skip qtquickcontrols -skip qtquickcontrols2 -skip qtquicktimeline \
     -skip qtremoteobjects -skip qtscript -skip qtscxml \
     -skip qtsensors -skip qtserialbus -skip qtserialport \
     -skip qtspeech -skip qtsvg -skip qtvirtualkeyboard \
     -skip qtwayland -skip qtwebchannel -skip qtwebengine \
     -skip qtwebglplugin -skip qtwebview -skip qtx11extras \
     -skip qtxmlpatterns \
     -no-dbus -no-icu \
     -qt-pcre -qt-doubleconversion -qt-harfbuzz \
     -xcb
   ```
   This keeps: qtbase, qtwebsockets, qtdeclarative, qttools.

7. **Configure Qt (Windows)** (if cache miss AND runner.os == Windows):
   Same flags as Linux but using `configure.bat`, with `-opengl desktop -platform win32-msvc -mp` instead of `-xcb`. Run inside a bash shell that calls `cmd //c configure.bat ...` or use `shell: cmd` for this step specifically.

   IMPORTANT: Before configure on Windows, download and set up jom for parallel builds:
   ```bash
   curl -L -o jom.zip https://download.qt.io/official_releases/jom/jom.zip
   7z x jom.zip -ojom
   echo "${{ github.workspace }}/jom" >> $GITHUB_PATH
   ```

8. **Build Qt (Linux)** (if cache miss AND runner.os == Linux):
   ```bash
   cd qt-everywhere-src-${VERSION}
   make -j$(nproc)
   ```

9. **Build Qt (Windows)** (if cache miss AND runner.os == Windows):
   ```bash
   cd qt-everywhere-src-${VERSION}
   jom -j $NUMBER_OF_PROCESSORS
   ```
   Note: The MSVC dev environment must be set up by the CALLING workflow (using `ilammy/msvc-dev-cmd@v1`), not the composite action. Document this as a prerequisite in the action description.

10. **Install Qt** (if cache miss):
    ```bash
    cd qt-everywhere-src-${VERSION}
    make install  # Linux
    # or: jom install  # Windows
    ```

11. **Verify private headers** (if cache miss):
    Check that `${INSTALL_PREFIX}/include/QtCore/${VERSION}/QtCore/private/qhooks_p.h` exists. Fail if missing (critical for probe build).

12. **Set output** (always): Set `qt-dir` output to install prefix.

**Implementation notes:**
- All `if` conditions for cache miss: `if: steps.qt-cache.outputs.cache-hit != 'true'`
- Platform conditions: `if: steps.qt-cache.outputs.cache-hit != 'true' && runner.os == 'Linux'`
- The composite action does NOT set up MSVC environment. The calling workflow must do this with `ilammy/msvc-dev-cmd@v1` BEFORE calling the composite action.
- Use `shell: bash` for all steps (available on both platforms via Git Bash on Windows)
- For the Windows configure step, use `shell: cmd` since Qt's configure.bat needs a native cmd environment with MSVC vars
- Handle the source directory name: it will be `qt-everywhere-src-${QT_VERSION}` after extraction on both Linux and Windows

**Configure flags version constant:**
Append `-cfgv1` to the cache key. When configure flags change in the future, bump this to `-cfgv2` to invalidate caches. This avoids needing to hash the entire action.yml file.
  </action>
  <verify>
1. Read `.github/actions/build-qt/action.yml` and confirm:
   - It is a valid composite action with `runs: using: 'composite'`
   - inputs include qt-version, patches-dir, install-prefix
   - outputs include qt-dir and cache-hit
   - `actions/cache@v4` is used with a key that includes hashFiles of patches-dir
   - No `restore-keys` in cache step
   - All build steps have `if: steps.qt-cache.outputs.cache-hit != 'true'`
   - Linux and Windows configure/build steps are separate with correct conditions
   - Private header verification step exists
2. Validate YAML syntax: `python -c "import yaml; yaml.safe_load(open('.github/actions/build-qt/action.yml'))"`
  </verify>
  <done>Composite action created with download, patch, configure, build, install, cache, and verify steps for both Linux and Windows</done>
</task>

</tasks>

<verification>
1. `.github/actions/build-qt/action.yml` exists and is valid YAML
2. Action has inputs: qt-version, patches-dir, install-prefix
3. Action has outputs: qt-dir, cache-hit
4. Cache uses `actions/cache@v4` with key including `hashFiles` of patches-dir
5. No `restore-keys` in cache config (prevents partial-match cache hits)
6. All build steps conditional on cache miss
7. Separate configure/build steps for Linux and Windows
8. Private header verification step present
9. `.ci/patches/5.15.1/` directory exists with README.md
10. Action description documents the MSVC prerequisite
</verification>

<success_criteria>
- Composite action is syntactically valid YAML
- Cache key design prevents stale/mismatched cache hits
- Both Linux and Windows build paths are fully specified
- Patch application uses git apply with sorted ordering
- Install prefix is cached (not build tree)
</success_criteria>

<output>
After completion, create `.planning/phases/10-patched-qt-ci/10-01-SUMMARY.md`
</output>
