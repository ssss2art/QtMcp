---
phase: 11-release-automation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - .github/workflows/release.yml
autonomous: true

must_haves:
  truths:
    - "Pushing a v* tag triggers the release workflow"
    - "Release workflow calls both ci.yml and ci-patched-qt.yml to build all 10 artifacts"
    - "All 10 probe binaries appear on the GitHub Release page with correct filenames"
    - "A SHA256SUMS file is included in the release"
    - "Release is created automatically with tag name as title"
  artifacts:
    - path: ".github/workflows/release.yml"
      provides: "Tag-triggered release workflow"
      contains: "softprops/action-gh-release"
      min_lines: 60
  key_links:
    - from: ".github/workflows/release.yml"
      to: ".github/workflows/ci.yml"
      via: "uses: ./.github/workflows/ci.yml"
      pattern: "uses:.*ci\\.yml"
    - from: ".github/workflows/release.yml"
      to: ".github/workflows/ci-patched-qt.yml"
      via: "uses: ./.github/workflows/ci-patched-qt.yml"
      pattern: "uses:.*ci-patched-qt\\.yml"
    - from: ".github/workflows/release.yml"
      to: "GitHub Release"
      via: "softprops/action-gh-release@v2"
      pattern: "softprops/action-gh-release"
---

<objective>
Create the release workflow that triggers on v* tags, calls both CI workflows to build all 10 probe binaries, extracts and renames them, generates SHA256 checksums, and publishes a GitHub Release.

Purpose: Automates the entire release process so pushing a tag produces a complete release with no manual steps.
Output: `.github/workflows/release.yml` — a complete, production-ready release workflow.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-release-automation/11-01-SUMMARY.md
@.github/workflows/ci.yml
@.github/workflows/ci-patched-qt.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create release workflow</name>
  <files>.github/workflows/release.yml</files>
  <action>
Create `.github/workflows/release.yml` with the following structure:

**Name:** `Release`

**Trigger:**
```yaml
on:
  push:
    tags: ['v*']
```

**Permissions:**
```yaml
permissions:
  contents: write
```
(Required for creating releases and uploading assets.)

**Jobs:**

1. **build-standard** — calls ci.yml as reusable workflow:
```yaml
build-standard:
  uses: ./.github/workflows/ci.yml
```
No inputs needed. This produces 8 artifacts (qtmcp-qt5.15-linux-gcc through qtmcp-qt6.9-windows-msvc).

2. **build-patched** — calls ci-patched-qt.yml as reusable workflow:
```yaml
build-patched:
  uses: ./.github/workflows/ci-patched-qt.yml
```
No inputs needed. This produces 2 artifacts (qtmcp-qt5.15-patched-linux-gcc, qtmcp-qt5.15-patched-windows-msvc).

3. **release** — collects artifacts and creates GitHub Release:
```yaml
release:
  name: Create Release
  needs: [build-standard, build-patched]
  runs-on: ubuntu-latest
```

Steps for the release job:

a. **Download all artifacts** using `actions/download-artifact@v4` with `path: artifacts/` and `merge-multiple: false` (each artifact in its own subdirectory).

b. **Extract and rename probe binaries** — shell script that:
   - Creates a `release-assets/` directory
   - For each of the 10 artifact directories, finds the probe binary and copies it with the correct release filename
   - Linux artifacts: find `*.so` file, copy as `qtmcp-probe-{artifact_tag}-linux-gcc.so`
   - Windows artifacts: find `*.dll` file, copy as `qtmcp-probe-{artifact_tag}-windows-msvc.dll`

   The 10 artifact directory names and their expected probe paths:
   ```
   qtmcp-qt5.15-linux-gcc        -> lib/qtmcp/qt5.15/qtmcp-probe-qt5.15.so
   qtmcp-qt5.15-windows-msvc     -> lib/qtmcp/qt5.15/qtmcp-probe-qt5.15.dll
   qtmcp-qt6.2-linux-gcc         -> lib/qtmcp/qt6.2/qtmcp-probe-qt6.2.so
   qtmcp-qt6.2-windows-msvc      -> lib/qtmcp/qt6.2/qtmcp-probe-qt6.2.dll
   qtmcp-qt6.8-linux-gcc         -> lib/qtmcp/qt6.8/qtmcp-probe-qt6.8.so
   qtmcp-qt6.8-windows-msvc      -> lib/qtmcp/qt6.8/qtmcp-probe-qt6.8.dll
   qtmcp-qt6.9-linux-gcc         -> lib/qtmcp/qt6.9/qtmcp-probe-qt6.9.so
   qtmcp-qt6.9-windows-msvc      -> lib/qtmcp/qt6.9/qtmcp-probe-qt6.9.dll
   qtmcp-qt5.15-patched-linux-gcc    -> lib/qtmcp/qt5.15/qtmcp-probe-qt5.15.so
   qtmcp-qt5.15-patched-windows-msvc -> lib/qtmcp/qt5.15/qtmcp-probe-qt5.15.dll
   ```

   IMPORTANT: The artifacts are uploaded as the full install/ directory. So the probe path within each downloaded artifact is `ci-linux/lib/qtmcp/{tag}/...` or `ci-windows/lib/qtmcp/{tag}/...`. Use a find command to locate the .so or .dll reliably rather than hardcoding the full preset path.

   Release filenames must encode the platform to distinguish otherwise identically-named binaries:
   - Standard: `qtmcp-probe-{artifact_tag}-{platform}.{ext}` (e.g., `qtmcp-probe-qt6.8-linux-gcc.so`)
   - Patched: `qtmcp-probe-{artifact_tag}-patched-{platform}.{ext}` (e.g., `qtmcp-probe-qt5.15-patched-linux-gcc.so`)

   For Windows artifacts, also include the `.lib` import library with matching name pattern.

   Use a bash script with a mapping array or loop over known artifact names. Example approach:
   ```bash
   ARTIFACTS=(
     "qtmcp-qt5.15-linux-gcc:qt5.15:linux-gcc:so"
     "qtmcp-qt5.15-windows-msvc:qt5.15:windows-msvc:dll"
     "qtmcp-qt6.2-linux-gcc:qt6.2:linux-gcc:so"
     "qtmcp-qt6.2-windows-msvc:qt6.2:windows-msvc:dll"
     "qtmcp-qt6.8-linux-gcc:qt6.8:linux-gcc:so"
     "qtmcp-qt6.8-windows-msvc:qt6.8:windows-msvc:dll"
     "qtmcp-qt6.9-linux-gcc:qt6.9:linux-gcc:so"
     "qtmcp-qt6.9-windows-msvc:qt6.9:windows-msvc:dll"
     "qtmcp-qt5.15-patched-linux-gcc:qt5.15-patched:linux-gcc:so"
     "qtmcp-qt5.15-patched-windows-msvc:qt5.15-patched:windows-msvc:dll"
   )
   mkdir -p release-assets
   for entry in "${ARTIFACTS[@]}"; do
     IFS=: read -r dir tag platform ext <<< "$entry"
     probe=$(find "artifacts/$dir" -name "*.${ext}" -path "*/lib/qtmcp/*" | head -1)
     if [ -n "$probe" ]; then
       cp "$probe" "release-assets/qtmcp-probe-${tag}-${platform}.${ext}"
     fi
     # Also grab .lib for Windows
     if [ "$ext" = "dll" ]; then
       lib=$(find "artifacts/$dir" -name "*.lib" -path "*/lib/qtmcp/*" | head -1)
       if [ -n "$lib" ]; then
         cp "$lib" "release-assets/qtmcp-probe-${tag}-${platform}.lib"
       fi
     fi
   done
   ```

c. **Generate SHA256SUMS** — run `cd release-assets && sha256sum * > SHA256SUMS` to create the checksums file.

d. **List release assets** — `ls -la release-assets/` for debugging in the workflow log.

e. **Create GitHub Release** using `softprops/action-gh-release@v2`:
```yaml
- name: Create GitHub Release
  uses: softprops/action-gh-release@v2
  with:
    files: release-assets/*
    generate_release_notes: true
    fail_on_unmatched_files: true
```
The `fail_on_unmatched_files: true` ensures the step fails if any glob doesn't match. The `generate_release_notes: true` auto-generates changelog from commits since last tag.

No `GITHUB_TOKEN` needs to be explicitly passed — `softprops/action-gh-release@v2` uses `GITHUB_TOKEN` automatically when `permissions.contents: write` is set.

**CRITICAL details:**
- Do NOT use `actions/upload-artifact` merge pattern in release job. Instead use `actions/download-artifact@v4` to download all artifacts from the called workflows. Called workflows' artifacts are accessible to the caller.
- The workflow_call-ed workflows already upload artifacts via `actions/upload-artifact@v4`. The release job just downloads them.
- Ensure the release job `needs: [build-standard, build-patched]` so it waits for both to complete.
  </action>
  <verify>
1. Validate YAML: `python -c "import yaml; yaml.safe_load(open('.github/workflows/release.yml'))"`
2. Confirm the file contains: `softprops/action-gh-release@v2`, `sha256sum`, `workflow_call` references to both ci.yml and ci-patched-qt.yml
3. Confirm trigger is `push: tags: ['v*']`
4. Count that all 10 artifact names appear in the extraction script
  </verify>
  <done>
release.yml exists, is valid YAML, triggers on v* tags, calls both CI workflows, extracts all 10 probe binaries with correct release filenames, generates SHA256SUMS, and creates a GitHub Release.
  </done>
</task>

</tasks>

<verification>
1. `.github/workflows/release.yml` exists and is valid YAML
2. Trigger: `push.tags` contains `v*`
3. Jobs: `build-standard` uses ci.yml, `build-patched` uses ci-patched-qt.yml
4. Release job: downloads artifacts, extracts 10 binaries, generates SHA256SUMS, creates release
5. `softprops/action-gh-release@v2` is used with `fail_on_unmatched_files: true`
6. `permissions.contents: write` is set
</verification>

<success_criteria>
A complete release.yml workflow exists that, when triggered by a v* tag push, will:
1. Build all 10 probe binaries by calling both CI workflows
2. Extract and rename probes with platform-encoded filenames
3. Generate SHA256SUMS covering all assets
4. Create a GitHub Release with all binaries and checksums attached
</success_criteria>

<output>
After completion, create `.planning/phases/11-release-automation/11-02-SUMMARY.md`
</output>
