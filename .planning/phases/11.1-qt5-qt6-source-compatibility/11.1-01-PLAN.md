---
phase: 11.1-qt5-qt6-source-compatibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/compat/compat_core.h
  - src/compat/compat_gui.h
  - src/compat/compat_variant.h
  - src/probe/introspection/variant_json.cpp
  - src/probe/introspection/meta_inspector.cpp
  - src/probe/interaction/input_simulator.cpp
autonomous: true

must_haves:
  truths:
    - "Source compiles against Qt 5.15 without Qt6-only API calls at call sites"
    - "Source compiles against Qt 6.x without deprecation warnings"
    - "No inline #if QT_VERSION blocks remain in non-compat source files"
    - "All Qt version divergence is isolated in src/compat/ headers"
  artifacts:
    - path: "src/compat/compat_core.h"
      provides: "QMetaType::fromName polyfill, QT_DISABLE_DEPRECATED_BEFORE"
      contains: "namespace qtmcp::compat"
    - path: "src/compat/compat_gui.h"
      provides: "QKeyCombination extraction for Qt5/Qt6"
      contains: "extractKeyCombination"
    - path: "src/compat/compat_variant.h"
      provides: "variantTypeId, variantCanConvert, variantConvert, emptyVariantOfType"
      contains: "namespace qtmcp::compat"
    - path: "src/probe/introspection/variant_json.cpp"
      provides: "Qt5/Qt6 compatible variant-to-JSON conversion"
    - path: "src/probe/introspection/meta_inspector.cpp"
      provides: "Qt5/Qt6 compatible meta-object inspection"
    - path: "src/probe/interaction/input_simulator.cpp"
      provides: "Qt5/Qt6 compatible key sequence extraction"
  key_links:
    - from: "src/probe/introspection/variant_json.cpp"
      to: "src/compat/compat_variant.h"
      via: "#include and compat:: calls"
      pattern: "compat::metaTypeIdFromName|compat::variantCanConvert|compat::variantConvert"
    - from: "src/probe/introspection/meta_inspector.cpp"
      to: "src/compat/compat_variant.h"
      via: "#include and compat:: calls"
      pattern: "compat::variantConvert|compat::emptyVariantOfType"
    - from: "src/probe/interaction/input_simulator.cpp"
      to: "src/compat/compat_gui.h"
      via: "#include and compat:: calls"
      pattern: "compat::extractKeyCombination"
---

<objective>
Create per-module compatibility headers and update all source files that use Qt6-only APIs to use the compat layer instead.

Purpose: Isolate all Qt5/Qt6 API divergence into dedicated compat headers so the main source code compiles cleanly against both Qt 5.15 and Qt 6.x with zero inline version checks.

Output: Three compat headers in src/compat/ and three updated source files with all Qt6-only API calls replaced by compat-layer calls.
</objective>

<execution_context>
@C:\Users\stjohnson\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\stjohnson\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.1-qt5-qt6-source-compatibility/11.1-RESEARCH.md

Key source files to modify:
@src/probe/introspection/variant_json.cpp
@src/probe/introspection/meta_inspector.cpp
@src/probe/interaction/input_simulator.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compat headers</name>
  <files>
    src/compat/compat_core.h
    src/compat/compat_gui.h
    src/compat/compat_variant.h
  </files>
  <action>
First create directory `src/compat/` if it does not exist (`mkdir -p src/compat/`). Then create three compat headers under `src/compat/`. All headers use `#pragma once`, wrap content in `namespace qtmcp::compat {}`, and contain ONLY inline functions with `#if QT_VERSION` guards inside.

**src/compat/compat_core.h:**
- `metaTypeIdFromName(const char* name) -> int`: On Qt6 uses `QMetaType::fromName(name).id()`, on Qt5 uses `QMetaType::type(name)`.
- Include `<QMetaType>` and `<QtGlobal>` (for QT_VERSION_CHECK).

**src/compat/compat_variant.h:**
- `variantTypeId(const QVariant& v) -> int`: Returns `v.userType()` on both Qt5 and Qt6 (userType() works on both, typeId() is Qt6-only).
- `variantCanConvert(const QVariant& v, int typeId) -> bool`: On Qt6 uses `v.canConvert(QMetaType(typeId))`, on Qt5 uses `v.canConvert(typeId)`.
- `variantConvert(QVariant& v, int typeId) -> bool`: On Qt6 uses `v.convert(QMetaType(typeId))`, on Qt5 uses `v.convert(typeId)`.
- `emptyVariantOfType(int typeId) -> QVariant`: On Qt6 uses `QVariant(QMetaType(typeId))`, on Qt5 uses `QVariant(static_cast<QVariant::Type>(typeId))`. NOTE: For Qt5, `QVariant::Type` is the legacy enum but `QVariant(QVariant::Type)` constructor works for all registered metatypes.
- Include `<QVariant>` and `<QtGlobal>`.

**src/compat/compat_gui.h:**
- `extractKeyCombination(const QKeySequence& seq, int index, Qt::Key& key, Qt::KeyboardModifiers& mods)`: On Qt6 uses `seq[index].key()` and `seq[index].keyboardModifiers()`. On Qt5 uses bitmask extraction: `key = static_cast<Qt::Key>(seq[index] & ~Qt::KeyboardModifierMask)`, `mods = Qt::KeyboardModifiers(seq[index] & Qt::KeyboardModifierMask)`.
- Include `<QKeySequence>` and `<QtGlobal>`.

Each header must have copyright header matching project convention:
```cpp
// Copyright (c) 2024 QtMCP Contributors
// SPDX-License-Identifier: MIT
```
  </action>
  <verify>
All three files exist. Each contains `namespace qtmcp::compat`, `#pragma once`, appropriate `#if QT_VERSION` guards, and the specified inline functions. No compilation test yet (that happens after source files are updated).
  </verify>
  <done>Three compat headers exist in src/compat/ with all required polyfill functions.</done>
</task>

<task type="auto">
  <name>Task 2: Update source files to use compat layer</name>
  <files>
    src/probe/introspection/variant_json.cpp
    src/probe/introspection/meta_inspector.cpp
    src/probe/interaction/input_simulator.cpp
    src/probe/CMakeLists.txt
  </files>
  <action>
**variant_json.cpp changes:**
1. Add `#include "compat/compat_variant.h"` and `#include "compat/compat_core.h"` near the top includes.
2. Line 26: Replace `value.typeId()` with `value.userType()` (no compat header needed — `userType()` works on both Qt versions and is not deprecated).
3. Line 204: Replace `QMetaType::fromName(typeName.toLatin1().constData()).id()` with `qtmcp::compat::metaTypeIdFromName(typeName.toLatin1().constData())`.
4. Lines 398-399: Replace `result.canConvert(QMetaType(targetTypeId))` with `qtmcp::compat::variantCanConvert(result, targetTypeId)`. Replace `result.convert(QMetaType(targetTypeId))` with `qtmcp::compat::variantConvert(result, targetTypeId)`.

**meta_inspector.cpp changes:**
1. Add `#include "compat/compat_variant.h"` near the top includes.
2. Line 233: Replace `var.typeId() != prop.userType()` with `var.userType() != prop.userType()`. Replace `var.convert(QMetaType(prop.userType()))` with `qtmcp::compat::variantConvert(var, prop.userType())`.
3. Line 296: Replace `QVariant(QMetaType(foundMethod.returnType()))` with `qtmcp::compat::emptyVariantOfType(foundMethod.returnType())`.

**input_simulator.cpp changes:**
1. Add `#include "compat/compat_gui.h"` near the top includes.
2. Lines 80-86: Remove the entire `#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)` / `#else` / `#endif` block. Replace with:
```cpp
  Qt::Key extractedKey;
  Qt::KeyboardModifiers mods;
  qtmcp::compat::extractKeyCombination(keySeq, 0, extractedKey, mods);
```
Then update the QTest::keyClick call to use `extractedKey` instead of `static_cast<Qt::Key>(key)`.

**src/probe/CMakeLists.txt changes:**
Add the compat headers to the include path. Add `../../compat` to the PRIVATE include directories so that `#include "compat/compat_variant.h"` resolves correctly. Specifically, add a target_include_directories line:
```cmake
target_include_directories(qtmcp_probe PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../)
```
This allows `#include "compat/compat_variant.h"` from any probe source file since `src/` will be on the include path.

IMPORTANT: Do NOT add the compat headers to PROBE_SOURCES or PROBE_HEADERS — they are header-only and not part of the probe's public API.
  </action>
  <verify>
1. Grep all `.cpp` files under `src/probe/` for `typeId()` — should find zero matches (replaced with `userType()`).
2. Grep all `.cpp` files under `src/probe/` for `QMetaType::fromName` — should find zero matches.
3. Grep all `.cpp` files under `src/probe/` for `#if QT_VERSION` — should find zero matches.
4. Grep all `.cpp` files under `src/probe/` for `canConvert(QMetaType` — should find zero matches.
5. Grep all `.cpp` files under `src/probe/` for `convert(QMetaType` — should find zero matches.
6. Grep all `.cpp` files under `src/probe/` for `QVariant(QMetaType` — should find zero matches.
7. If a local Qt build environment is available, run `cmake --build build/ --parallel` to verify compilation.
  </verify>
  <done>All six Qt6-only API call sites replaced with compat-layer calls. Zero inline #if QT_VERSION blocks in non-compat source files. Probe CMakeLists.txt updated with compat include path.</done>
</task>

</tasks>

<verification>
1. `grep -r "typeId()" src/probe/ --include="*.cpp"` returns nothing
2. `grep -r "QMetaType::fromName" src/probe/ --include="*.cpp"` returns nothing
3. `grep -r "#if QT_VERSION" src/probe/ --include="*.cpp"` returns nothing
4. `grep -r "canConvert(QMetaType" src/probe/ --include="*.cpp"` returns nothing
5. `grep -r "QVariant(QMetaType" src/probe/ --include="*.cpp"` returns nothing
6. All compat headers exist and contain `namespace qtmcp::compat`
7. Local build passes (if available) or CI passes after push
</verification>

<success_criteria>
- Three compat headers exist in src/compat/ with inline polyfill functions
- All Qt6-only API calls in source files replaced with compat-layer equivalents
- Zero inline #if QT_VERSION blocks remain in any .cpp file under src/probe/
- Source files include the appropriate compat headers
- Probe CMakeLists.txt has compat include path
</success_criteria>

<output>
After completion, create `.planning/phases/11.1-qt5-qt6-source-compatibility/11.1-01-SUMMARY.md`
</output>
