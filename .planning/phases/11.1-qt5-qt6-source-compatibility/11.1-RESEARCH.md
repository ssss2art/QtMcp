# Phase 11.1: Qt 5.15 / Qt 6 Source Compatibility - Research

**Researched:** 2026-02-02
**Domain:** Qt cross-version source compatibility (C++17, Qt 5.15 + Qt 6.5+)
**Confidence:** HIGH

## Summary

A thorough audit of the QtMCP source code reveals **six categories of Qt5/Qt6 API divergence** that must be resolved through compat headers. The codebase is roughly 30 source files totaling ~4500 lines. The most critical incompatibilities are in `variant_json.cpp` and `input_simulator.cpp`, which already contain one inline `#if QT_VERSION` block that must be refactored.

The overall approach is well-suited to per-module compat headers because the divergence points cluster cleanly into three Qt module boundaries: Core (QVariant/QMetaType), GUI (QMouseEvent/QWheelEvent/QKeySequence), and a few miscellaneous items. The codebase already compiles against Qt 6 and uses Qt6-preferred APIs in most places, so the main work is adding Qt5 compatibility, not the reverse.

**Primary recommendation:** Create three compat headers (`compat_core.h`, `compat_gui.h`, `compat_variant.h`) that provide inline functions/macros mapping Qt6-only APIs to their Qt5 equivalents. Audit every `.cpp` file against the divergence table below and replace all Qt6-only calls with compat-header calls.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Qt Core | 5.15.1+ / 6.5+ | Core framework | Project requirement |
| Qt GUI | 5.15.1+ / 6.5+ | GUI events, input | Input simulation, screenshots |
| Qt Widgets | 5.15.1+ / 6.5+ | Widget introspection | Object tree, accessibility |
| Qt WebSockets | 5.15.1+ / 6.5+ | Transport | JSON-RPC transport |
| Qt Test | 5.15.1+ / 6.5+ | Input simulation | QTest::mouseClick etc. |
| CMake | 3.16+ | Build system | Already configured for dual Qt |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Qt CorePrivate | 5.15.1+ / 6.5+ | qhooks_p.h | Object registry hooks (stable across Qt5/Qt6) |
| Qt Accessibility | 5.15.1+ / 6.5+ | QAccessible API | Chrome mode tree walking (API stable) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Per-module compat headers | Inline #if QT_VERSION blocks | Compat headers are cleaner but add files; decided in CONTEXT.md |
| Qt5 canonical names | Qt6 canonical names | Qt5 canonical is decided; slightly more polyfills needed but safer for existing Qt5 users |

## Architecture Patterns

### Recommended Project Structure
```
src/
├── compat/                    # NEW: compatibility headers
│   ├── compat_core.h          # QMetaType, QVariant, Qt::SplitBehavior, etc.
│   ├── compat_gui.h           # QMouseEvent, QWheelEvent, QKeySequence
│   └── compat_variant.h       # variantTypeId(), variantCanConvert(), etc.
├── probe/                     # Existing source tree (unchanged structure)
│   ├── api/
│   ├── core/
│   ├── interaction/
│   ├── introspection/
│   ├── transport/
│   └── accessibility/
└── launcher/
```

### Pattern 1: Inline Function Polyfill
**What:** Provide an inline function in compat header that wraps Qt-version-specific calls.
**When to use:** When the Qt5 and Qt6 APIs have different names but the same semantics.
**Example:**
```cpp
// src/compat/compat_variant.h
#pragma once
#include <QVariant>
#include <QMetaType>

namespace qtmcp::compat {

/// Returns the QMetaType integer ID for a QVariant.
/// Qt6 has QVariant::typeId(); Qt5 has QVariant::userType().
/// QVariant::userType() works on BOTH Qt5 and Qt6 and returns the same int.
inline int variantTypeId(const QVariant& v) {
    return v.userType();  // Works on both Qt5 and Qt6
}

/// QMetaType::fromName() is Qt 6.5+ only.
/// Qt5 equivalent is QMetaType::type(const char*).
inline int metaTypeIdFromName(const char* name) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    return QMetaType::fromName(name).id();
#else
    return QMetaType::type(name);
#endif
}

/// QVariant::canConvert(QMetaType) is Qt6; Qt5 uses canConvert(int).
inline bool variantCanConvert(const QVariant& v, int targetTypeId) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    return v.canConvert(QMetaType(targetTypeId));
#else
    return v.canConvert(targetTypeId);
#endif
}

/// QVariant::convert(QMetaType) is Qt6; Qt5 uses convert(int).
inline bool variantConvert(QVariant& v, int targetTypeId) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    return v.convert(QMetaType(targetTypeId));
#else
    return v.convert(targetTypeId);
#endif
}

} // namespace qtmcp::compat
```

### Pattern 2: Typedef/Using Alias
**What:** Provide a type alias in compat header for types that exist only in one Qt version.
**When to use:** When Qt6 introduces a new type (e.g., QKeyCombination) not in Qt5.
**Example:**
```cpp
// src/compat/compat_gui.h
#pragma once
#include <QKeySequence>

namespace qtmcp::compat {

/// Extract key and modifiers from QKeySequence[0].
/// Qt6 returns QKeyCombination with .key() and .keyboardModifiers().
/// Qt5 returns int requiring bitmask extraction.
inline void extractKeyCombination(const QKeySequence& seq, int index,
                                   Qt::Key& key, Qt::KeyboardModifiers& mods) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    key = seq[index].key();
    mods = seq[index].keyboardModifiers();
#else
    int combined = seq[index];
    key = static_cast<Qt::Key>(combined & ~Qt::KeyboardModifierMask);
    mods = Qt::KeyboardModifiers(combined & Qt::KeyboardModifierMask);
#endif
}

} // namespace qtmcp::compat
```

### Pattern 3: Constructor Wrapper for Event Types
**What:** Factory function that constructs Qt input events correctly for each Qt version.
**When to use:** QMouseEvent and QWheelEvent constructors changed between Qt5 and Qt6.
**Example:**
```cpp
// src/compat/compat_gui.h
#include <QMouseEvent>

namespace qtmcp::compat {

inline QMouseEvent* createMouseEvent(QEvent::Type type, const QPointF& localPos,
                                      const QPointF& globalPos, Qt::MouseButton button,
                                      Qt::MouseButtons buttons, Qt::KeyboardModifiers mods) {
    // Both Qt5 and Qt6 have a constructor taking (type, localPos, globalPos, button, buttons, mods)
    // Qt5: (type, localPos, windowPos, screenPos, button, buttons, mods)
    // Qt6: (type, localPos, scenePos, globalPos, button, buttons, mods)
    // In both cases, passing localPos as the middle arg and globalPos as the last works
    // for in-process event delivery where window == local for our use case.
    return new QMouseEvent(type, localPos, localPos, globalPos, button, buttons, mods);
}

} // namespace qtmcp::compat
```

### Anti-Patterns to Avoid
- **Inline `#if QT_VERSION` at call sites:** This is explicitly prohibited by CONTEXT.md decisions. All version checks go in compat headers.
- **Using `QVariant::type()`:** Removed in Qt 6.3. Use `userType()` which works on both versions.
- **Using `QVariant::typeId()`:** Qt6-only. Use `userType()` which works identically.
- **Using `QMetaType::fromName()`:** Qt 6.5+ only. Use compat wrapper.
- **Using deprecated QMouseEvent constructors:** The 2-arg QMouseEvent(type, localPos) sets globalPos from QCursor::pos() which is unreliable. Always use the explicit 3-point form.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| QVariant type ID extraction | Custom #if blocks per call site | `QVariant::userType()` | Works on Qt5 AND Qt6 identically |
| QMetaType name lookup | Different code paths | Compat wrapper around `QMetaType::type()` (Qt5) / `QMetaType::fromName()` (Qt6) | One #if in compat, zero at call sites |
| QKeySequence key extraction | Repeated bitmask code | Compat `extractKeyCombination()` function | QKeyCombination only exists in Qt6 |
| Cross-version QMouseEvent creation | Multiple constructors per call site | Compat factory function | Constructor signatures differ |

**Key insight:** `QVariant::userType()` is the single most important cross-version API. It does exactly what `typeId()` does and has existed since Qt 5.0. Switching all `typeId()` calls to `userType()` eliminates the largest category of incompatibilities without any #if blocks at all.

## Common Pitfalls

### Pitfall 1: QVariant::typeId() Does Not Exist in Qt 5
**What goes wrong:** Code calls `value.typeId()` which compiles on Qt6 but fails on Qt5.
**Why it happens:** `typeId()` was introduced in Qt 6.0 as the replacement for `type()`.
**How to avoid:** Replace all `typeId()` calls with `userType()`. Both return `int` with the same value.
**Warning signs:** Any `.typeId()` call in source code.
**Files affected:** `variant_json.cpp` (line 26), `meta_inspector.cpp` (line 233).

### Pitfall 2: QMetaType::fromName() Does Not Exist in Qt 5
**What goes wrong:** `QMetaType::fromName(name).id()` compiles on Qt6 but not Qt5.
**Why it happens:** `fromName()` was added in Qt 6.0. Qt5 uses `QMetaType::type()` instead.
**How to avoid:** Use compat wrapper `metaTypeIdFromName()`.
**Warning signs:** Any `QMetaType::fromName()` call.
**Files affected:** `variant_json.cpp` (line 204).

### Pitfall 3: QVariant::canConvert/convert with QMetaType Parameter
**What goes wrong:** `var.canConvert(QMetaType(id))` and `var.convert(QMetaType(id))` are Qt6 overloads.
**Why it happens:** Qt5 only has `canConvert(int)` and `convert(int)`.
**How to avoid:** Use compat wrappers that select the right overload.
**Warning signs:** `canConvert(QMetaType(` or `convert(QMetaType(` patterns.
**Files affected:** `variant_json.cpp` (lines 398-399), `meta_inspector.cpp` (line 233).

### Pitfall 4: QVariant(QMetaType) Constructor
**What goes wrong:** `QVariant(QMetaType(returnType))` is Qt6 syntax for constructing a typed empty QVariant.
**Why it happens:** Qt5 uses `QVariant(QVariant::Type)` or `QVariant(int typeId, const void *copy)`.
**How to avoid:** Use compat wrapper that constructs an appropriately-typed empty QVariant.
**Warning signs:** `QVariant(QMetaType(` patterns.
**Files affected:** `meta_inspector.cpp` (line 296).

### Pitfall 5: QKeySequence[0] Returns Different Types
**What goes wrong:** `keySeq[0].key()` works on Qt6 (returns QKeyCombination) but fails on Qt5 (returns int).
**Why it happens:** Qt6 introduced QKeyCombination; Qt5 operator[] returns int.
**How to avoid:** Already has `#if QT_VERSION` guard in input_simulator.cpp:80. Move to compat header.
**Files affected:** `input_simulator.cpp` (lines 80-86).

### Pitfall 6: QMouseEvent and QWheelEvent Constructor Differences
**What goes wrong:** The code uses constructors that work on both versions (3-point form) but parameter semantics differ slightly.
**Why it happens:** Qt6 renamed parameters (windowPos -> scenePos, screenPos -> globalPos).
**How to avoid:** The current code happens to use a form compatible with both Qt5 and Qt6 (localPos, localPos, globalPos pattern). Verify this compiles cleanly on Qt5. If not, use compat factory.
**Warning signs:** Direct QMouseEvent/QWheelEvent construction.
**Files affected:** `input_simulator.cpp` (lines 127, 144, 158, 177, 201, 214, 220).

### Pitfall 7: std::as_const vs qAsConst
**What goes wrong:** `std::as_const` requires C++17. Qt5 projects on older compilers may not have it.
**Why it happens:** The project requires C++17, so this is actually fine. But `qAsConst` is deprecated in Qt 6.6+.
**How to avoid:** Since C++17 is required, `std::as_const` works on both Qt5 and Qt6. No change needed.
**Files affected:** `object_registry.cpp` (lines 210, 234) -- already uses `std::as_const`, which is correct.

### Pitfall 8: Qt::SkipEmptyParts Enum Value
**What goes wrong:** `Qt::SkipEmptyParts` was introduced in Qt 5.14 as a replacement for `QString::SkipEmptyParts`.
**Why it happens:** Qt5.14+ and Qt6 both have `Qt::SkipEmptyParts`. Since minimum is Qt 5.15.1, this is safe.
**How to avoid:** No change needed -- `Qt::SkipEmptyParts` works on Qt 5.15+ and Qt6.
**Files affected:** `main.cpp` (lines 120, 123), `object_id.cpp` (line 285).

### Pitfall 9: qEnvironmentVariable() Availability
**What goes wrong:** `qEnvironmentVariable()` returns QString and was introduced in Qt 5.10.
**Why it happens:** Since minimum is Qt 5.15.1, this is safe.
**How to avoid:** No change needed.
**Files affected:** `probe.cpp` (line 198).

### Pitfall 10: QT_DISABLE_DEPRECATED_BEFORE May Surface Hidden Issues
**What goes wrong:** Setting `QT_DISABLE_DEPRECATED_BEFORE=0x050F00` (Qt 5.15.0) will cause compile errors for any Qt API deprecated before 5.15.0.
**Why it happens:** Both Qt5 and Qt6 honor this macro, but Qt6 has additional deprecations.
**How to avoid:** Set it in CMakeLists.txt as a compile definition. Fix any resulting errors. The macro surfaces hidden use of old APIs that would otherwise silently compile.
**Warning signs:** Build errors mentioning "deprecated since" after adding the macro.

## Code Examples

### Complete Compat Header Pattern (compat_variant.h)
```cpp
// Source: Derived from Qt 5.15/6.x documentation analysis
#pragma once
#include <QMetaType>
#include <QVariant>

namespace qtmcp::compat {

// ---- QVariant type identification ----
// QVariant::typeId() is Qt6-only. QVariant::userType() works on BOTH.
inline int variantTypeId(const QVariant& v) {
    return v.userType();
}

// ---- QMetaType name lookup ----
// QMetaType::fromName() is Qt 6.0+. Qt5 uses QMetaType::type().
inline int metaTypeIdFromName(const char* name) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    return QMetaType::fromName(name).id();
#else
    return QMetaType::type(name);
#endif
}

// ---- QVariant conversion ----
inline bool variantCanConvert(const QVariant& v, int typeId) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    return v.canConvert(QMetaType(typeId));
#else
    return v.canConvert(typeId);
#endif
}

inline bool variantConvert(QVariant& v, int typeId) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    return v.convert(QMetaType(typeId));
#else
    return v.convert(typeId);
#endif
}

// ---- Construct typed empty QVariant ----
inline QVariant emptyVariantOfType(int typeId) {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    return QVariant(QMetaType(typeId));
#else
    return QVariant(typeId, nullptr);
#endif
}

} // namespace qtmcp::compat
```

### CMake Configuration for QT_DISABLE_DEPRECATED_BEFORE
```cmake
# Add to root CMakeLists.txt after Qt is found
# QT_DISABLE_DEPRECATED_BEFORE=0x050F00 means Qt 5.15.0
# Anything deprecated before 5.15.0 becomes a hard error
target_compile_definitions(qtmcp_probe PUBLIC
    QT_DISABLE_DEPRECATED_BEFORE=0x050F00
)
```

### CMake Minimum Version Enforcement
```cmake
# After finding Qt, enforce minimum versions
if(QT_VERSION_MAJOR EQUAL 5 AND QT_VERSION VERSION_LESS "5.15.1")
    message(FATAL_ERROR "Qt 5.15.1 or later is required. Found: ${QT_VERSION}")
elseif(QT_VERSION_MAJOR EQUAL 6 AND QT_VERSION VERSION_LESS "6.5")
    message(FATAL_ERROR "Qt 6.5 or later is required. Found: ${QT_VERSION}")
endif()
```

## Detailed Source File Audit

### Files Requiring Changes (Qt6-only APIs found)

| File | Line(s) | Issue | Fix |
|------|---------|-------|-----|
| `variant_json.cpp` | 26 | `value.typeId()` -- Qt6-only | Replace with `userType()` (no compat header needed) |
| `variant_json.cpp` | 204 | `QMetaType::fromName(name).id()` -- Qt6-only | Use `compat::metaTypeIdFromName()` |
| `variant_json.cpp` | 398-399 | `canConvert(QMetaType(id))`, `convert(QMetaType(id))` -- Qt6 overload | Use `compat::variantCanConvert/Convert()` |
| `meta_inspector.cpp` | 233 | `var.typeId()` and `var.convert(QMetaType(id))` -- Qt6-only | Use `userType()` + `compat::variantConvert()` |
| `meta_inspector.cpp` | 296 | `QVariant(QMetaType(returnType))` -- Qt6 constructor | Use `compat::emptyVariantOfType()` |
| `input_simulator.cpp` | 80-86 | Inline `#if QT_VERSION` block for QKeyCombination | Move to `compat::extractKeyCombination()` |

### Files Verified Clean (No Changes Needed)

| File | Notes |
|------|-------|
| `object_registry.cpp` | Uses `std::as_const` (C++17, OK); `Qt::FindChildrenRecursively` (Qt 5.15+) |
| `object_id.cpp` | Uses `Qt::SkipEmptyParts` (Qt 5.14+); `QLatin1Char`, `QLatin1String` (stable) |
| `signal_monitor.cpp` | QMetaMethod, QMetaObject -- stable across Qt5/Qt6 |
| `websocket_server.cpp` | QWebSocket, QWebSocketServer -- stable API |
| `probe.cpp` | `qgetenv`, `qEnvironmentVariable` (Qt 5.10+); `Q_GLOBAL_STATIC` (stable) |
| `screenshot.cpp` | `QScreen::grabWindow`, `QWidget::grab` -- stable API |
| `chrome_mode_api.cpp` | QAccessible API -- stable across Qt5/Qt6 |
| `accessibility_tree_walker.cpp` | QAccessible API -- stable |
| `role_mapper.cpp` | QAccessible::Role enum -- stable |
| `console_message_capture.cpp` | QRegularExpression -- available in both Qt5/Qt6 |
| `key_name_mapper.cpp` | No version-sensitive APIs |
| `hit_test.cpp` | QWidget geometry -- stable |
| `object_resolver.cpp` | `QStringView::mid().toInt()` -- available in Qt 5.10+ |
| `jsonrpc_handler.cpp` | QJsonDocument -- stable |
| `response_envelope.cpp` | QJsonObject -- stable |
| `symbolic_name_map.cpp` | QJsonDocument, qgetenv -- stable |
| `native_mode_api.cpp` | Routes to MetaInspector (which needs fixes) |
| `computer_use_mode_api.cpp` | Routes to InputSimulator (which needs fixes) |
| All launcher files | Simple Qt APIs, no version issues |
| All test files | Mirror the APIs used in source; will compile once source is fixed |

### QMouseEvent/QWheelEvent Constructor Analysis

The code in `input_simulator.cpp` creates QMouseEvent with the 7-arg form:
```cpp
QMouseEvent event(QEvent::MouseButtonPress, QPointF(localPos), QPointF(globalPos),
                  qtButton, qtButton, modifiers);
```

**Qt5 interprets this as:** `(type, localPos, screenPos, button, buttons, modifiers)` -- missing windowPos.
**Qt6 interprets this as:** `(type, localPos, globalPos, button, buttons, modifiers)` -- 2-point short form.

This 6-argument constructor exists in Qt 5.15 (as `QMouseEvent(Type, QPointF localPos, QPointF screenPos, Qt::MouseButton, Qt::MouseButtons, Qt::KeyboardModifiers)`) and in Qt 6 (as a convenience constructor). **No change needed** -- the current code compiles on both.

Similarly, QWheelEvent uses the 8-arg form:
```cpp
QWheelEvent event(QPointF(localPos), QPointF(globalPos), pixelDelta, angleDelta,
                  Qt::NoButton, modifiers, Qt::NoScrollPhase, false);
```

**Qt5 5.15:** Has constructor `(QPointF pos, QPointF globalPos, QPoint pixelDelta, QPoint angleDelta, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Qt::ScrollPhase phase, bool inverted)`. This matches.
**Qt6:** Same signature (removed old deprecated overloads but this one survived).
**No change needed** -- compiles on both.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `QVariant::type()` | `QVariant::typeId()` (Qt6) or `userType()` (cross-version) | Qt 6.0 | Must use `userType()` for compat |
| `QMetaType::type("name")` | `QMetaType::fromName("name").id()` | Qt 6.0 | Need compat wrapper |
| `QVariant::canConvert(int)` | `QVariant::canConvert(QMetaType)` | Qt 6.0 | Need compat wrapper |
| `qAsConst()` | `std::as_const()` | Qt 6.6 deprecated qAsConst | Already using std::as_const (C++17 required) |
| `QKeySequence[0]` returns int | Returns `QKeyCombination` | Qt 6.0 | Need compat wrapper |
| Qt 6.2 minimum | Qt 6.5 minimum | Phase 11.1 decision | Drop Qt 6.2 from CI matrix |

**Deprecated/outdated:**
- `QVariant::type()`: Removed in Qt 6.3; replaced by `typeId()` (Qt6) or `userType()` (both)
- `QString::SkipEmptyParts`: Replaced by `Qt::SkipEmptyParts` in Qt 5.14
- `QWheelEvent` old constructors with `qt4Delta`/`qt4Orientation`: Removed in Qt6

## CI Matrix Changes

The current CI matrix includes Qt 6.2.4 which is below the new minimum of Qt 6.5. Per CONTEXT.md, it should be replaced. Suggested matrix:

| Qt Version | Platforms | Rationale |
|------------|-----------|-----------|
| 5.15.2 | Linux, Windows | Minimum Qt5 version |
| 6.5.x | Linux, Windows | Minimum Qt6 version |
| 6.8.0 | Linux, Windows | Current LTS-adjacent |
| 6.9.0 | Linux, Windows | Latest |

The Qt 6.2.4 row should be replaced with Qt 6.5.x (e.g., 6.5.3).

## Open Questions

1. **QMouseEvent 6-arg constructor on Qt5 -- windowPos semantics**
   - What we know: The 6-arg form compiles on both Qt5 and Qt6. On Qt5, the middle QPointF is `screenPos`. On Qt6, it's the `globalPos`.
   - What's unclear: Whether the missing `windowPos` on Qt5 causes any behavioral difference in the in-process event delivery we use.
   - Recommendation: Test this during manual smoke testing on Qt5. If behavior differs, add a compat factory that uses the explicit 7-arg form with `localPos` as `windowPos`.

2. **QAccessible::State struct fields**
   - What we know: The accessibility_tree_walker.cpp reads many state fields (focused, disabled, checked, expanded, etc.)
   - What's unclear: Whether any of these struct fields were added after Qt 5.15.
   - Recommendation: LOW risk. The fields used are all long-standing. Verify during Qt5 CI build.

3. **Private header qhooks_p.h stability**
   - What we know: `qhooks_p.h` is a private header used for object tracking. Both Qt5 and Qt6 have it.
   - What's unclear: Whether the QHooks enum values or function signatures changed between Qt 5.15 and Qt 6.5.
   - Recommendation: LOW risk. The hooks API is very stable (used by GammaRay). The current code compiles on Qt6. Verify on Qt5 CI build.

## Sources

### Primary (HIGH confidence)
- Qt 5.15 QVariant documentation: https://doc.qt.io/archives/qt-5.15/qvariant.html -- Verified `userType()` availability, `type()` existence, no `typeId()`
- Qt 6 QVariant documentation: https://doc.qt.io/qt-6/qvariant.html -- Verified `typeId()` added in 6.0, `type()` deprecated/removed
- Qt 6 QMetaType documentation: https://doc.qt.io/qt-6/qmetatype.html -- Verified `fromName()` is Qt6-only
- Qt 5.15 QMetaType documentation: https://qthub.com/static/doc/qt5/qtcore/qmetatype.html -- Verified `type(const char*)` for name lookup
- Qt 6 Changes to Qt Core: https://doc.qt.io/qt-6/qtcore-changes-qt6.html -- Comprehensive change list
- Qt 6 QMouseEvent documentation: https://doc.qt.io/qt-6/qmouseevent.html -- Constructor changes verified
- Qt 5.15 QMouseEvent documentation: https://qthub.com/static/doc/qt5/qtgui/qmouseevent.html -- Qt5 constructors verified
- Qt Forum on QVariant::type() replacement: https://forum.qt.io/topic/139807/replacing-qvariant-type-when-moving-to-qt-6 -- `userType()` as cross-version solution

### Secondary (MEDIUM confidence)
- Qt blog on QMetaType/QVariant changes: https://www.qt.io/blog/whats-new-in-qmetatype-qvariant -- Explains Qt6 redesign
- KDAB on qAsConst: https://www.kdab.com/blog-qasconst-and-stdas_const/ -- std::as_const replacement confirmed
- Qt Porting Guide: https://doc.qt.io/qt-6/portingguide.html -- General migration guidance

### Tertiary (LOW confidence)
- Direct source code audit of QtMCP codebase -- All API usage patterns verified by reading actual source files

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Qt documentation is authoritative and well-verified
- Architecture: HIGH - Compat header pattern is well-established (used by KDE, GammaRay, etc.)
- Pitfalls: HIGH - Each pitfall verified against official Qt documentation for both versions
- Code examples: HIGH - Based on documented API signatures, cross-referenced between Qt5 and Qt6 docs

**Research date:** 2026-02-02
**Valid until:** 2026-04-02 (Qt APIs are stable; compat patterns are well-established)
