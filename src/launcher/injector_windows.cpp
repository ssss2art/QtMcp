// Copyright (c) 2024 QtMCP Contributors
// SPDX-License-Identifier: MIT

// Windows implementation of probe injection using CreateRemoteThread.
// This file is only compiled on Windows (see CMakeLists.txt).
//
// Injection pattern based on Pattern 4 from 01-RESEARCH.md:
// 1. Create process suspended
// 2. Allocate memory in target for DLL path
// 3. Write DLL path to target memory
// 4. Get address of LoadLibraryW in kernel32
// 5. Create remote thread to call LoadLibraryW with DLL path
// 6. Wait for injection thread to complete
// 7. Resume main thread
// 8. Optionally wait for process to exit

#include "injector.h"

#ifdef Q_OS_WIN

#include "process_inject_windows.h"

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>
#include <cstdio>

namespace {

/// @brief Build a command line string for CreateProcessW.
/// @param executable The executable path.
/// @param args The command line arguments.
/// @return A properly quoted command line string.
std::wstring buildCommandLine(const QString& executable, const QStringList& args) {
  QString cmdLine;

  // Quote the executable path if it contains spaces
  if (executable.contains(QLatin1Char(' '))) {
    cmdLine = QStringLiteral("\"%1\"").arg(executable);
  } else {
    cmdLine = executable;
  }

  // Append arguments, quoting as needed
  for (const QString& arg : args) {
    cmdLine += QLatin1Char(' ');
    if (arg.contains(QLatin1Char(' ')) || arg.contains(QLatin1Char('"'))) {
      // Quote and escape embedded quotes
      QString escaped = arg;
      escaped.replace(QLatin1Char('"'), QStringLiteral("\\\""));
      cmdLine += QStringLiteral("\"%1\"").arg(escaped);
    } else {
      cmdLine += arg;
    }
  }

  return cmdLine.toStdWString();
}

}  // namespace

namespace qtmcp {

qint64 launchWithProbe(const LaunchOptions& options) {
  // 1. Set up environment for the target process
  // Pass port to probe via QTMCP_PORT environment variable

  // Get current environment and add QTMCP_PORT
  QString portStr = QString::number(options.port);
  if (!SetEnvironmentVariableW(L"QTMCP_PORT", portStr.toStdWString().c_str())) {
    if (!options.quiet) {
      printWindowsError("Failed to set QTMCP_PORT", GetLastError());
    }
    // Continue anyway - probe has default port
  }

  // Enable child process injection if requested
  if (options.injectChildren) {
    SetEnvironmentVariableW(L"QTMCP_INJECT_CHILDREN", L"1");
  }

  // 2. Build command line
  std::wstring cmdLine = buildCommandLine(options.targetExecutable, options.targetArgs);

  if (!options.quiet) {
    fprintf(stderr, "[injector] Command line: %ls\n", cmdLine.c_str());
  }

  // 3. Create target process in suspended state
  STARTUPINFOW si = {};
  si.cb = sizeof(si);

  PROCESS_INFORMATION pi = {};

  // Need a mutable copy of cmdLine for CreateProcessW
  std::vector<wchar_t> cmdLineBuf(cmdLine.begin(), cmdLine.end());
  cmdLineBuf.push_back(L'\0');

  BOOL createResult = CreateProcessW(nullptr,            // Application name (use command line)
                                     cmdLineBuf.data(),  // Command line (mutable)
                                     nullptr,            // Process security attributes
                                     nullptr,            // Thread security attributes
                                     FALSE,              // Inherit handles
                                     CREATE_SUSPENDED,   // Creation flags - start suspended
                                     nullptr,            // Environment (inherit current)
                                     nullptr,            // Current directory
                                     &si,                // Startup info
                                     &pi                 // Process information
  );

  if (!createResult) {
    if (!options.quiet) {
      printWindowsError("CreateProcessW failed", GetLastError());
    }
    return -1;
  }

  // RAII guards for handles
  qtmcp::HandleGuard processHandle(pi.hProcess);
  qtmcp::HandleGuard threadHandle(pi.hThread);
  qint64 processId = static_cast<qint64>(pi.dwProcessId);

  if (!options.quiet) {
    fprintf(stderr, "[injector] Created process %lld (suspended)\n",
            static_cast<long long>(processId));
  }

  // 4. Inject probe DLL (LoadLibraryW + qtmcpProbeInit via shared utility)
  std::wstring dllPath = options.probePath.toStdWString();
  if (!qtmcp::injectProbeDll(processHandle.get(), pi.dwProcessId, dllPath.c_str(), options.quiet)) {
    TerminateProcess(processHandle.get(), 1);
    return -1;
  }

  // 5. Resume the main thread
  DWORD suspendCount = ResumeThread(threadHandle.get());
  if (suspendCount == static_cast<DWORD>(-1)) {
    if (!options.quiet) {
      printWindowsError("ResumeThread failed", GetLastError());
    }
    TerminateProcess(processHandle.get(), 1);
    return -1;
  }

  if (!options.quiet) {
    fprintf(stderr, "[injector] Resumed main thread (suspend count was %lu)\n", suspendCount);
  }

  // 6. Wait for process if not detaching
  if (!options.detach) {
    if (!options.quiet) {
      fprintf(stderr, "[injector] Waiting for process to exit...\n");
    }
    WaitForSingleObject(processHandle.get(), INFINITE);

    DWORD processExitCode = 0;
    GetExitCodeProcess(processHandle.get(), &processExitCode);

    if (!options.quiet) {
      fprintf(stderr, "[injector] Process exited with code %lu\n", processExitCode);
    }
  }

  return processId;
}

}  // namespace qtmcp

#endif  // Q_OS_WIN
